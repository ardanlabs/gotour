Embedding
Embedding types provide the final piece of sharing and reusing state and behavior between types. Through the use of inner type promotion, an inner type's fields and methods can be directly accessed by references of the outer type.

* Embedding

Embedding types provide the final piece of sharing and reusing state and behavior between types. Through the use of inner type promotion, an inner type's fields and methods can be directly accessed by references of the outer type.

** Code Review

- *Example* *1:* Declaring Fields
.play embedding/example1/example1.go
			   
- *Example* *2:* Embedding types
.play embedding/example2/example2.go
			   
- *Example* *3:* Embedded types and interfaces
.play embedding/example3/example3.go		   

- *Example* *4:* Outer and inner type interface implementations
.play embedding/example4/example4.go
	

This first example does not show embedding, just the declaration of two struct types working together as a field from one type to the other.

Listing 1

    type user struct {
        name  string
        email string
    }

    type admin struct {
        person user        // NOT Embedding
        level  string
    }

This is embedding.

Listing 2

    type user struct {
        name  string
        email string
    }

    type admin struct {
        user               // Value Semantic Embedding
        level  string
    }

The person field is removed and just the type name is left. I can also embed a type using pointer semantics.

Listing 3

    type user struct {
        name  string
        email string
    }

    type admin struct {
        *user              // Pointer Semantic Embedding
        level  string
    }

In this case, a pointer of the type is embedded. In either case, accessing the embedded value is done through the use of the type’s name.

The best way to think about embedding is to view the user type as an inner type and admin as an outer type. It’s this inner/outer type relationship that is magical because with embedding, everything related to the inner type (both fields and methods) can be promoted up to the outer type. 


Listing 4

    type user struct {
        name  string
        email string
    }

    func (u *user) notify() {
        fmt.Printf("Sending user email To %s<%s>\n",
            u.name,
            u.email)
    }

    type admin struct {
        *user              // Pointer Semantic Embedding
        level  string
    }

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        ad.user.notify()
        ad.notify() // Outer type promotion
    }

Output:

    Sending user email To john smith<john@yahoo.com>
    Sending user email To john smith<john@yahoo.com>

Once I add a method named notify for the user type and then a small main function, I can see the output is the same whether I call the notify method through the inner pointer value directly or through the outer type value. The notify method declared for the user type is accessible directly by the admin type value.

Though this looks like inheritance, I must be careful. This is not about reusing state, but about promoting behavior.

Listing 5

    type notifier interface {
        notify()
    }

    func sendNotification(n notifier) {
        n.notify()
    }

Now I add an interface and a polymorphic function that accepts any concrete value that implements the full method set of behavior defined by the notifier interface. Which is just a method named notify.

Because of embedding and promotion, values of type admin now implement the notifier interface.

Listing 6

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        sendNotification(&ad)
    }

Output:

    Sending user email To john smith<john@yahoo.com>

I can send the address of the admin value into the polymorphic function since embedding promotes the notify behavior up to the admin type.

Listing 7

    type admin struct {
        *user  // Pointer Semantic Embedding
        level  string
    }

    func (a *admin) notify() {
        fmt.Printf("Sending admin Email To %s<%s>\n",
            a.name,
            a.email)
    }

When the outer type implements a method already implemented by the inner type, the promotion doesn’t take place.

Listing 8

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        sendNotification(&ad)
    }

Output:
    
    Sending admin email To john smith<john@yahoo.com>

I can see the outer type’s method is now being executed.

** Notes

- Embedding types allow us to share state or behavior between types.
- The inner type never loses its identity.
- This is not inheritance.
- Through promotion, inner type fields and methods can be accessed through the outer type.
- The outer type can override the inner type's behavior.

** Links

- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methods, Interfaces and Embedded Types in Go]] - William Kennedy    
- [[https://rakyll.org/typesystem/][Embedding is not inheritance]] - JBD  


* Exercises

Exercise 1

Copy the code from the template. Add a new type CachingFeed which embeds Feed and overrides the Fetch method.

.play embedding/exercises/template1/template1.go

.play embedding/exercises/exercise1/exercise1.go
			 
             
All material is licensed under the [[http://www.apache.org/licenses/LICENSE-2.0][Apache License Version 2.0, January 2004]].
