Daten-Rennen
Ein Datenwettlauf liegt vor, wenn zwei oder mehr Goroutinen gleichzeitig versuchen, dieselbe Ressource zu lesen und zu beschreiben.

* Data Races

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Das Video ansehen]]
- Benötigen Sie finanzielle Unterstützung, nutzen Sie unser [[https://www.ardanlabs.com/scholarship/][Stipendienformular]]

Ein Datenwettlauf liegt vor, wenn zwei oder mehr Goroutinen gleichzeitig versuchen, auf denselben Speicherplatz zuzugreifen
Speicherplatz zuzugreifen, während mindestens eine Goroutine einen Schreibvorgang durchführt. Wenn
dies geschieht, ist es unmöglich, das Ergebnis vorherzusagen. Diese Arten von Fehlern sind schwer
zu finden, weil sie Probleme verursachen, die immer zufällig erscheinen.

Diese ~8 Minuten von Scott Meyers kann man sich hier gut anhören:

[[https://youtu.be/WDIkqP4JbkE?t=1809][CPU-Caches und warum Sie das interessiert 30:09-38:30]]

** Code-Überprüfung

- *Beispiel* *1:* Data Race
- *Beispiel* *2:* Atomare Inkremente
- *Beispiel* *3:* Mutex
- *Beispiel* *4:* Lese-/Schreib-Mutex
- *Beispiel* *5:* Map Data Race
- *Beispiel* *1:* Schnittstellenbasierte Race Condition

.play data_race/example1.go
.play data_race/example2.go
.play data_race/example3.go
.play data_race/example4.go
.play data_race/example5.go
.play data_race/example6.go

** Beispiel für ein Datenrennen

Dies ist ein großartiges Beispiel für ein Datenrennen und dafür, wie es jahrelang verborgen bleiben kann und
und schließlich zu ungeraden Zeiten auftauchen und Datenbeschädigungen verursachen.

var Zähler int

    func main() {
        const grs = 2

        var wg sync.WaitGroup
        wg.Add(grs)

        for g := 0; g < grs; g++ {
            go func() {
                for i := 0; i < 2; i++ {
                    Wert := Zähler
                    Wert++
                    Zähler = Wert
                }
                wg.Done()
            }()
        }

        wg.Wait()
        fmt.Println("Zähler:", Zähler)
    }

Dieses Programm erstellt zwei Goroutinen, die jeweils auf dieselbe Integer-Variable zugreifen,
wobei die Variable zweimal inkrementiert wird. Die Goroutine führt eine Lese-, Änderungs- und Schreib
Operation gegen den gemeinsamen Zustand manuell durch.

    var Zähler int

    func main() {
        . . .

        go func() {
            for i := 0; i < 2; i++ {
                Wert := Zähler
                Wert++
                Zähler = Wert
            }
            wg.Done()
        }()

        . . .
    }

Sie können den Zugriff auf den gemeinsamen Zustand innerhalb der for-Schleife sehen. Wenn Sie das Programm erstellen und ausführen
ausführen, erhalten Sie jedes Mal die richtige Antwort von 4.

    $ ./example1
    Endgültiger Zähler: 4

    $ ./example1
    Endgültiger Zähler: 4

    $ ./example1
    Endgültiger Zähler: 4

Wie funktioniert das?

    G1 Gemeinsamer Zustand: 0 G2
    ----------------------------------------------------------------------------
    Lesen: 0
    Ändern: 1
    Schreiben:  1 Shared State: 1
    Kontextwechsel
                                                                      Lesen: 1
                                                                    Ändern: 2
                                    Shared State: 2 Schreiben: 2
                                                               Kontext-Schalter
    Lesen: 2
    Ändern: 3
    Schreiben:  3 Gemeinsamer Zustand: 3
    Beenden:
                                                                      Lesen: 3
                                                                    Ändern: 4
                                    Geteilter Zustand: 4 Schreiben: 4
                                                                    Beenden:
    ----------------------------------------------------------------------------

Die Lese-, Änderungs- und Schreibvorgänge laufen ohne Unterbrechung ab. Nur weil ich
die richtige Antwort erhalte, heißt das nicht, dass es kein Problem gibt. Was passiert, wenn
Sie eine Protokollanweisung in der Mitte des Lese-, Änderungs- und Schreibvorgangs einfügen?

    var Zähler int

    func main() {
        . . .

        go func() {
            for i := 0; i < 2; i++ {
                Wert := Zähler
                Wert++
                log.Println("logging") <-- Logging hier hinzufügen
                counter = value
            }
            wg.Done()
        }()

        . . .
    }

Wenn Sie dieses Programm ausführen, erhalten Sie nicht mehr das gleiche Ergebnis von 4, sondern die Antwort 2.

    $ ./example1
    Endgültiger Zähler: 2

    $ ./example1
    Endgültiger Zähler: 2

    $ ./example1
    Endgültiger Zähler: 2


Was ist passiert? Sie stoßen auf einen Data-Race-Fehler, der schon vorher vorhanden war, aber
war aber nicht der Fall. Der Aufruf des Protokolls führt nun dazu, dass der Scheduler einen Kontextwechsel
Kontextwechsel zwischen den beiden Goroutinen zu einem ungünstigen Zeitpunkt.

    G1 Gemeinsamer Zustand: 0 G2
    ----------------------------------------------------------------------------
    Lesen: 0
    Ändern: 1
    Kontextwechsel
                                                                        Lesen: 0
                                                                        Ändern: 1
                                                                   Kontext-Schalter
    Schreiben:  1 Gemeinsamer Zustand: 1
    Lesen: 1
    Ändern: 2
    Kontextwechsel
                                    Geteilter Zustand: 1 Schreiben:  1
                                                                        Lesen: 1
                                                                        Ändern: 2
                                                                    Kontextwechsel
    Schreiben:  2 Gemeinsamer Zustand: 2
    Beenden
                                    Geteilter Zustand: 2 Schreiben:  2
                                                                        Beenden
    ----------------------------------------------------------------------------

Nach der Änderungsoperation findet ein Kontextwechsel statt. Die drei Operationen
sind nicht mehr ununterbrochen, und die Goroutine 2 hat am Ende einen falschen lokalen Wert
zu dem Zeitpunkt, an dem sie den Schreibvorgang abschließt. Sie haben großes Glück, dass dies jedes Mal geschieht
und Sie können es sehen. Normalerweise geschieht ein solcher Datenwettlauf jedoch "zufällig" und ist
unmöglich zu erkennen, bis es zu spät ist. Glücklicherweise hat Go einen Race-Detektor, der hilft
Datenrennen zu finden.

** Rassenerkennung

Es gibt mehrere Möglichkeiten, den Renndetektor einzusetzen. Sie können ihn mit den Befehlen run, build
und dem Befehl test. Wenn Sie ihn mit dem Build-Befehl verwenden, müssen Sie daran denken, das
Programm auszuführen. Es heißt, dass eine instrumentierte Binärdatei mein Programm um ~20% verlangsamen kann.

    $ go build -race
    $ ./example1

Mit dem Flag -race können Sie den Build mit dem Race-Detektor instrumentieren. Sie werden
wahrscheinlich mehr mit "go test" verwenden, aber in diesem Beispiel instrumentieren Sie die
Binärdatei instrumentieren und sie dann ausführen.

    2021/02/01 17:30:52 Protokollierung
    2021/02/01 17:30:52 Protokollierung
    2021/02/01 17:30:52 Protokollierung
    ==================
    WARNUNG: DATEN-RENNEN
    Schreiben bei 0x000001278d88 durch goroutine 8:
    main.main.func1()
        /data_race/example1/example1.go:41 +0xa6

    Vorheriges Lesen bei 0x000001278d88 durch goroutine 7:
    main.main.func1()
        /data_race/example1/example1.go:38 +0x4a

    Goroutine 8 (läuft) erstellt bei:
    main.main()
        /data_race/example1/example1.go:36 +0xaf

    Goroutine 7 (beendet) erstellt bei:
    main.main()
        /data_race/example1/example1.go:36 +0xaf
    ==================
    2021/02/01 17:30:52 Protokollierung
    Endgültiger Zähler: 2
    1 Daten-Race(s) gefunden

Sie können sehen, dass bei der Ausführung des Programms ein Wettlauf festgestellt wurde. Dies würde mit oder
ohne die eingefügte Protokollanweisung. Wenn ein Wettlauf erkannt wird, gerät das Programm in Panik und
liefert diesen Trace. Der Trace zeigt, wo ein unsynchronisierter Zugriff auf denselben
gleichen gemeinsamen Zustand gab, wobei mindestens ein Zugriff ein Schreibzugriff war.

In dieser Ablaufverfolgung führte eine Goroutine einen Schreibvorgang an der Adresse 0x000001278d88 in Zeile 41 durch,
und ein unsynchronisiertes Lesen an der gleichen Adresse durch eine andere Goroutine in
Zeile 38. Beide Goroutinen wurden in Zeile 36 erstellt.

    36 go func() {
    37 for i := 0; i < 2; i++ {
    38 Wert := Zähler
    39 wert++
    40 log.Println("Protokollierung")
    41 zähler = wert
    42 }
    43 wg.Done()
    44 }()

Man kann deutlich die unsynchronisierten Lese- und Schreibvorgänge erkennen. Nebenbei bemerkt, wäre die Operation plus plus
Operation in Zeile 39 wäre auch ein Data Race, wenn der Code auf die Zählervariable
Variable zugreifen würde. Die Plus-Plus-Operation ist eine Lese-, Änderungs- und Schreiboperation unter
und das Betriebssystem könnte in der Mitte des Vorgangs leicht den Kontext wechseln.

Wie können Sie also den Code korrigieren, um sicherzustellen, dass Sie den Datenwettlauf beseitigen? Es gibt zwei
Werkzeuge, die Sie verwenden können: atomare Anweisungen und Mutexe.

** Atomics

Atomics bietet eine Synchronisierung auf der Hardware-Ebene. Aus diesem Grund ist sie begrenzt
auf Wörter und Halbwörter von Daten. Sie eignen sich also hervorragend für Zähler oder schnelle Schalt
Mechanik. Die WaitGroup-APIs verwenden Atomics.

Welche Änderungen müssen Sie vornehmen, um Atomics auf den Code anzuwenden?

    var counter int32 <-- GEÄNDERT

    func main() {
        const grs = 2

        var wg sync.WaitGroup
        wg.Add(grs)

        for g := 0; g < grs; g++ {
            go func() {
                for i := 0; i < 2; i++ {
                    atomic.AddInt32(&counter, 1) <-- CHANGED
                }
                wg.Done()
            }()
        }

        wg.Wait()
        fmt.Println("Zähler:", Zähler)
    }

Sie müssen nur ein paar Dinge tun. Erstens, ändern Sie die Zählervariable so, dass sie eine
präzisionsbasierte Ganzzahl. Sie können das oben im Code-Listing sehen. Die atomaren
Funktionen funktionieren nur mit präzisionsbasierten Ganzzahlen. Zweitens, entfernen Sie den manuellen
Lesen, Ändern und Schreiben von Code für einen Aufruf von atomic.AddInt32. Dieser eine Aufruf erledigt
alles.

Alle Funktionen, die mit dem atomaren Paket verbunden sind, nehmen die Adresse des
gemeinsam genutzten Zustand, der synchronisiert werden soll. Die Synchronisierung erfolgt nur auf der Adressenebene.
Daher werden verschiedene Goroutinen, die dieselbe Funktion aufrufen, aber an einer anderen Adresse, nicht
synchronisiert werden.

Die API für Atomics sieht wie folgt aus:

    func AddInt32(addr *int32, delta int32) (new int32)
    func AddInt64(addr *int64, delta int64) (new int64)
    func AddUint32(addr *uint32, delta uint32) (new uint32)
    func AddUint64(addr *uint64, delta uint64) (new uint64)
    func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)

    func CompareAndSwapInt32(addr *int32, alt, neu int32) (swapped bool)
    func CompareAndSwapInt64(addr *int64, alt, neu int64) (swapped bool)
    func CompareAndSwapPointer(addr *unsafe.Pointer, alt, neu unsafe.Pointer) (swapped bool)
    func CompareAndSwapUint32(addr *uint32, alt, neu uint32) (swapped bool)
    func CompareAndSwapUint64(addr *uint64, alt, neu uint64) (swapped bool)
    func CompareAndSwapUintptr(addr *uintptr, alt, neu uintptr) (swapped bool)

    func LoadInt32(addr *int32) (val int32)
    func LoadInt64(addr *int64) (val int64)
    func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)
    func LoadUint32(addr *uint32) (val uint32)
    func LoadUint64(addr *uint64) (val uint64)
    func LoadUintptr(addr *uintptr) (val uintptr)

    func StoreInt32(addr *int32, val int32)
    func StoreInt64(addr *int64, val int64)
    func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)
    func StoreUint32(addr *uint32, val uint32)
    func StoreUint64(addr *uint64, val uint64)
    func StoreUintptr(addr *uintptr, val uintptr)

    func SwapInt32(addr *int32, neu int32) (alt int32)
    func SwapInt64(addr *int64, neu int64) (alt int64)
    func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (alt unsafe.Pointer)
    func SwapUint32(addr *uint32, neu uint32) (alt uint32)
    func SwapUint64(addr *uint64, neu uint64) (alt uint64)
    func SwapUintptr(addr *uintptr, neu uintptr) (alt uintptr)

    Typ Wert
        func (v *Wert) Laden() (x Schnittstelle{})
        func (v *Wert) Speichern(x Schnittstelle{})

Wie Sie sehen können, ist der erste Parameter immer die Adresse einer präzisionsbasierten
Ganzzahl oder Zeiger ist. Es gibt auch einen Typ namens Value, der einen synchronen
Wert mit einer kleinen API bietet.

** Mutexe

Was wäre, wenn Sie die drei Codezeilen, die Sie hatten, behalten wollten? Dann werden Atomics nicht
funktionieren. Was Sie dann brauchen, ist ein Mutex. Mit einem Mutex kann ich eine Gruppe von Code so verpacken, dass nur eine
Goroutine zur gleichen Zeit diesen Code ausführen kann.

    var Zähler int

    func main() {
        const grs = 2

        var wg sync.WaitGroup
        wg.Add(grs)

        var mu sync.Mutex <-- CHANGED

        for g := 0; g < grs; g++ {
            go func() {
                for i := 0; i < 2; i++ {
                    mu.Lock() <-- CHANGED
                    {
                        Wert := Zähler
                        wert++
                        zähler = wert
                    }
                    mu.Unlock() <-- CHANGED
                }
                wg.Done()
            }()
        }

        wg.Wait()
        fmt.Println("Zähler:", Zähler)
    }

Dieser Code wurde gegenüber dem Original in mehreren Punkten geändert. Sie haben die Konstruktion
der Variable mu als Mutex hinzugefügt, die auf ihren Nullwert gesetzt wird. Dann haben Sie innerhalb der for-Schleife,
haben Sie Aufrufe zum Sperren und Entsperren mit einem künstlichen Codeblock hinzugefügt. Innerhalb des Codeblocks
haben Sie den Code, der synchronisiert werden muss. Der Codeblock dient der besseren Lesbarkeit.

Mit diesem Code erlaubt der Scheduler nur einer Goroutine, den
Codeblock zu betreten. Es ist wichtig zu verstehen, dass ein Mutex keine Warteschlange ist.
Die erste Goroutine, die Lock aufruft, ist nicht unbedingt die erste Goroutine, die
die Sperre erhält. Es gibt einen auf Fairness basierenden Algorithmus, aber das geschieht absichtlich, damit Leute
Mutexe nicht als Warteschlangen verwenden.

Es ist wichtig, daran zu denken, dass die Sperre Gegendruck erzeugt, also je länger es dauert, von der
je länger es dauert, vom Sperren zum Entsperren zu kommen, desto größer ist die Chance, dass Goroutinen auf ihren Einsatz warten.
Wenn du vergisst, Unlock zu rufen, werden alle wartenden Goroutinen blockiert. Aus diesem Grund ist es
Deshalb ist es wichtig, dass der Aufruf von Lock und Unlock in derselben Funktion erfolgt. Stellen Sie sicher, dass ich
das absolute Minimum an Synchronisation, das Sie in dem Codeblock benötigen, aber zumindest das
Minimum.

Dies ist ein sehr schlechter Code, bei dem jemand versucht, die Sperre so schnell zu aktivieren und zu deaktivieren
dass die Synchronisation verloren geht und der Race Detector das Problem nicht einmal entdecken kann.
Problem.

    var Zähler int

    func main() {
        const grs = 2

        var wg sync.WaitGroup
        wg.Add(grs)

        var mu sync.Mutex

        for g := 0; g < grs; g++ {
            go func() {
                for i := 0; i < 2; i++ {
                    var Wert int
                    mu.Lock() <-- Schlechte Verwendung des Mutex
                    {
                        value = counter
                    }
                    mu.Unlock()

                    Wert++

                    mu.Lock() <-- Schlechte Verwendung des Mutex
                    {
                        counter = value
                    }
                    mu.Unlock()
                }
                wg.Done()
            }()
        }

        wg.Wait()
        fmt.Println("Zähler:", Zähler)
    }

Als allgemeine Richtlinie gilt: Wenn Sie einen Aufruf zum Sperren von derselben Mutex zweimal in derselben
Funktion sehen, brechen Sie die Überprüfung des Codes ab. Es liegt wahrscheinlich ein Fehler oder eine übermäßige Komplikation vor. Unter
diesem Fall werden die Aufrufe zum Lesen und Schreiben synchronisiert, aber zwei Goroutines
können jedoch in der Codezeile value++ mit demselben Wert enden. Das Datenrennen besteht weiterhin
und der Race-Detektor ist hilflos, ihn zu finden.

** Lese-/Schreib-Mutexe

Es gibt eine zweite Art von Mutex, die Lese-/Schreib-Mutex. Sie erlaubt es mir, die Sperren
die Sperren für Lese- und Schreibvorgänge zu trennen. Dies ist wichtig, da das Lesen von Daten keine Gefahr darstellt
nur dann eine Bedrohung darstellt, wenn eine Goroutine zur gleichen Zeit versucht zu schreiben. Diese Art von
Mutex erlaubt es also mehreren Goroutinen, denselben Speicher gleichzeitig zu lesen. Sobald
Sobald eine Schreibsperre angefordert wird, werden die Lesevorgänge nicht mehr ausgegeben, der Schreibvorgang findet statt,
können die Lesevorgänge wieder beginnen.

    Paket Haupt

    importieren (
        "fmt"
        "math/rand"
        "sync"
        "time"
    )

    var daten []string
    var rwMutex sync.RWMutex

    func main() {
        var wg sync.WaitGroup
        wg.Add(1)

        go func() {
            for i := 0; i < 10; i++ {
                writer(i)
            }
            wg.Done()
        }()

        for i := 0; i < 8; i++ {
            go func(id int) {
                for {
                    reader(id)
                }
            }(i)
        }

        wg.Wait()
        fmt.Println("Programm abgeschlossen")
    }

    func writer(i int) {
        rwMutex.Lock()
        {
            time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
            fmt.Println("****> : Performing Write")
            data = append(data, fmt.Sprintf("String: %d", i))
        }
        rwMutex.Unlock()
    }

    func reader(id int) {
        rwMutex.RLock()
        {
            time.Sleep(time.Duration(rand.Intn(10)) * time.Millisecond)
            fmt.Printf("%d : Performing Read : Length[%d]\n", id, len(data))
        }
        rwMutex.RUnlock()
    }

Sie können die Verwendung eines Lese-/Schreib-Mutex sehen, bei dem 8 Goroutinen die
Länge eines Slice im Abstand von 10 Millisekunden lesen, und 1 Goroutine, die innerhalb von
innerhalb von 100 Millisekunden aufwacht, um einen Wert an das Slice anzuhängen (zu schreiben).

Der Schlüssel liegt in der Implementierung der Writer- und Reader-Funktionen. Beachten Sie, dass Sie
Lock für den Writer und RLock für den Reader verwenden. Einer der größten Fehler, die man
ist es, die Unlock-Aufrufe mit der falschen Version zu verwechseln. Ein Lock
mit einem RUnlock zu verwechseln, wird nie gut ausgehen.

    7 : Lesen durchführen : Länge[0]
    5 : Ausführendes Lesen : Länge[0]
    0 : Ausführendes Lesen : Länge[0]
    3 : Ausführendes Lesen : Länge[0]
    7 : Ausführendes Lesen : Länge[0]
    2 : Ausführendes Lesen : Länge[0]
    1 : Ausführendes Lesen : Länge[0]
    ****> : Ausführendes Schreiben
    0 : Ausführendes Lesen : Länge[1]
    5 : Ausführendes Lesen : Länge[1]
    3 : Ausführendes Lesen : Länge[1]
    6 : Ausführendes Lesen : Länge[1]
    7 : Ausführendes Lesen : Länge[1]
    4 : Ausführendes Lesen : Länge[1]
    1 : Ausführendes Lesen : Länge[1]
    2 : Ausführendes Lesen : Länge[1]
    ****> : Schreiben durchführen
    7 : Performing Read : Länge[2]
    1 : Performing Read : Länge[2]
    3 : Ausführendes Lesen : Länge[2]

Die Ausgabe zeigt, dass mehrere Goroutinen gleichzeitig lesen, aber alle
das Lesen stoppt, wenn das Schreiben stattfindet.

** Anmerkungen

- Goroutinen müssen koordiniert und synchronisiert werden.
- Wenn zwei oder mehr Goroutinen versuchen, auf dieselbe Ressource zuzugreifen, kommt es zu einem Datenwettlauf.
- Atomare Funktionen und Mutexe können die nötige Unterstützung bieten.

** Cache-Kohärenz und Falsches Teilen

Dieser Inhalt wurde von Scott Meyers in seinem Vortrag auf der Dive 2014 zur Verfügung gestellt:

[[https://youtu.be/WDIkqP4JbkE?t=1809][CPU-Caches und warum Sie das interessiert (30:09-38:30)]]
[[https://github.com/ardanlabs/gotraining/blob/master/topics/go/testing/benchmarks/falseshare/README.md][Codebeispiel]]

.image /tour/eng/static/img/figure1_data_race.png

** Cache-Kohärenz und Falsches Sharing Hinweise

- Der Thread-Speicherzugriff ist wichtig.
- Wenn Ihr Algorithmus nicht skaliert, suchen Sie nach False-Sharing-Problemen.

** Extra Lesen

- [[http://www.drdobbs.com/parallel/eliminate-false-sharing/217500206][Falsches Teilen beseitigen]] - Herb Sutter
- [[https://golang.org/ref/mem][Das Go-Speicher-Modell]]
- [[http://blog.golang.org/race-detector][Einführung in den Go-Race-Detektor]] - Dmitry Vyukov und Andrew Gerrand
- [[https://www.ardanlabs.com/blog/2013/09/detecting-race-conditions-with-go.html][Erkennung von Wettlaufbedingungen mit Go]] - William Kennedy
- [[https://golang.org/doc/articles/race_detector.html][Data Race Detector]]

* Übungen

Verwenden Sie die Vorlage als Ausgangspunkt, um die Aufgaben zu lösen. Eine mögliche Lösung ist angegeben.

** Übung 1

Verwenden Sie in dem folgenden Programm den Race-Detektor, um den Daten-Race zu finden und zu korrigieren.

.play data_race/exercise1.go
.play data_race/answer1.go
