io - Standard Library
The ability to stream and pass data around is incredibility important. Data is constantly coming at our programs whether over a socket, file, device, etc.

* io - Standard Library

The ability to stream and pass data around is incredibility important. Data is constantly coming at our programs whether over a socket, file, device, etc. Many times this data needs to just be moved from one stream. Sometimes it needs to be encrypted, hashed or stored for safe keeping. The Writer and Reader interfaces may be the most heavily used and supported interfaces in both the standard library and the community.

** Code Review


- *Example* *1:* Standard Library Working Together
.play io/example1/example1.go
   

- *Example* *2:* Simple curl with io.Reader and io.Writer
.play io/example2/example2.go
   

- *Example* *3:* MultiWriters with curl example
.play io/example3/example3.go
   

- *Example* *4:* Stream processing
.play io/example4/example4.go
   

- *Example* *1:* TeeReader and io composition
.play io/advanced/example1/example1.go
   

- *Example* *2:* Gzip and Md5 support with curl example
.play io/advanced/example2/example2.go

** Notes

- The standard library provides all the infrastructure we need to stream and work with data.
- If we implement the Reader and Writer interfaces in our own types, we get this functionality for free.
- Implementing interfaces to existing functionality saves us from both development time and bugs.

** Documentation

*Writes/Reader* *Interfaces* *-* *Standard* *Library*

*Writer*

	type Writer interface {
	        Write(p []byte) (n int, err error)
	}

- The implementation of the Write method should attempt to write the entire length
  of the byte slice that is passed in.

- If the entire slice could not be written, the number of bytes successfully written
  along with a non-nil error must be returned.

- Otherwise, when completely successful, the returned `n` must equal `len(p)` and a
  nil error should be returned.

- The Writer implementation must never modify the provided byte slice at any time.

*Reader*

	type Reader interface {
	        Read(p []byte) (n int, err error)
	}

- The implementation should fill the provided byte slice with all the data that is
  immediately available, up to `len(p)` bytes.

- If no data is immediately available, Read should block.

- `io.EOF` is a special `error` value used to signal an end-of-file condition: no more
  data will follow.

- When an error or EOF condition occurs, Reader implementations can choose either
  to return the error value immediately from that same Read call, or may wait and return
  `n == 0` along with the error on the next Read call. Code using Readers should be able
  to handle both situations.

- Anytime the Read method returns bytes, those bytes should be processed first before
  checking the error value for an EOF or other error value.

- The implementation must never return a 0 byte read count with an error value of nil.
  Reads that result in no bytes read should always return an error.

** Links

- [[https://golang.org/pkg/io/][io package]]     
- [[https://medium.com/@benbjohnson/go-walkthrough-io-package-8ac5e95a9fbd#.d2ebstv0q][Go Walkthrough: io package]] - Ben Johnson    

 

* Exercises

Exercise 1

Download any document from the web and display the content in the terminal and write it to a file at the same time.

.play io/exercises/template1/template1.go
 
.play io/exercises/exercise1/exercise1.go
 


All material is licensed under the [[http://www.apache.org/licenses/LICENSE-2.0][Apache License Version 2.0, January 2004]].
