Methods
Methods are functions that give data the ability to exhibit behavior.

* Methods

A function is called a method when that function has a receiver declared. The receiver is the parameter that is declared between the keyword func and the function name. There are two types of receivers, value receivers for implementing value semantics and pointer receivers for implementing pointer semantics.

** Code Review

- *Example* *1:* Declare and receiver behavior
.play methods/example1/example1.go
			   

- *Example* *5:* Value and Pointer semantics
.play methods/example5/example5.go
			   

- *Example* *2:* Named typed methods
.play methods/example2/example2.go
			   

- *Example* *3:* Function/Method variables
.play methods/example3/example3.go
			   

- *Example* *4:* Function Types
.play methods/example4/example4.go

Listing 1

    type user struct {
        name  string
        email string
    }

    func (u user) notify() {
        fmt.Printf("Sending User Email To %s<%s>\n", u.name, u.email)
    }

    func (u *user) changeEmail(email string) {
        u.email = email
        fmt.Printf("Changed User Email To %s\n", email)
    }

The notify function is implemented with a value receiver. This means the method operates under value semantics and will operate on its own copy of the value used to make the call.

The changeEmail function is implemented with a pointer receiver. This means the method operates under pointer semantics and will operate on shared access to the value used to make the call.

Outside of a few exceptions, a method set for a type should not contain a mix of value and pointer receivers. Data semantic consistency is critically important and this includes declaring methods.

** Method Calls
When making a method call, the compiler doesn’t care if the value used to make the call matches the receiver’s data semantics exactly. The compiler just wants a value or pointer of the same type.


Listing 2

    bill := user{"Bill", "bill@email.com"}
    bill.notify()
    bill.changeEmail("bill@hotmail.com")

I can see that a value of type user is constructed and assigned to the bill variable. In the case of the notify call, the bill variable matches the receiver type which is using a value receiver. In the case of the changeEmail call, the bill variable doesn’t match the receiver type which is using a pointer receiver. However, the compiler accepts the method call and shares the bill variable with the method. Go will adjust to make the call.

This works the same when the variable used to make the call is a pointer variable.

Listing 3

    bill := &user{"Bill", "bill@email.com"}
    bill.notify()
    bill.changeEmail("bill@hotmail.com")

In this case, the bill variable is a pointer variable to a value of type user. Once again, Go adjusts to make the method call when calling the notify method.

If Go didn’t adjust, then this is what I would have to do to make those same method calls. 

Listing 4

    bill := user{"Bill", "bill@email.com"}
    (&bill).changeEmail("bill@hotmail.com")

    bill := &user{"Bill", "bill@email.com"}
    (*bill).notify()

I’m glad I don’t have to do that to make method calls in Go.

** Data Semantic Guideline For Internal Types
As a guideline, if the data I’m working with is an internal type (slice, map, channel, function, interface) then use value semantics to move the data around my program. This includes declaring fields on a type. However, when I’m reading and writing I need to remember I’m using pointer semantics.

Listing 5

    type IP []byte
    type IPMask []byte

These types are declared in the net package that is part of the standard library. They are declared with an underlying type which is a slice of bytes. Because of this, these types follow the guidelines for internal types.

Listing 6

    func (ip IP) Mask(mask IPMask) IP {
        if len(mask) == IPv6len && len(ip) == IPv4len && allFF(mask[:12]) {
            mask = mask[12:]
        }
        if len(mask) == IPv4len && len(ip) == IPv6len &&
            bytesEqual(ip[:12], v4InV6Prefix) {
            ip = ip[12:]
        }
        n := len(ip)
        if n != len(mask) {
            return nil
        }
        out := make(IP, n)
        for i := 0; i < n; i++ {
            out[i] = ip[i] & mask[i]
        }
        return out
    }

With the Mask method, value semantics are in play for both the receiver, parameter, and return argument. This method accepts its own copy of a Mask value, it mutates that value and then it returns a copy of the mutation. This method is using value semantic mutation. This is not an accident or random.

A function can decide what data input and output it needs. What it can’t decide is the data semantics for how the data flows in or out. The data drives that decision and the function must comply. This is why Mask implements a value semantic mutation api. It must respect how a slice is designed to be moved around the program.

Listing 7

    func ipEmptyString(ip IP) string {
        if len(ip) == 0 {
            return ""
        }
        return ip.String()
    }

The `ipEmptyString` function is also using value semantics for the input and output. This function accepts its own copy of an IP value and returns a string value. No use of pointer semantics because the data dictates the data semantics and not the function.

One exception to using value semantics is when I need to share a slice or map with a function that performs unmarshaling or decoding.

** Data Semantic Guideline For Struct Types
As a guideline, if the data I’m working with is a struct type then I have to think about what the data represents to make a decision. Though it would be great to choose value semantics for everything, when I’m not sure, evaluate if the data is safe to be copied. If it’s safe to be copied, start with value semantics. If it’s not safe for copying or that’s not even clear, start with pointer semantics.

After some time working with a new data type, the data semantic could become self-evident and refactoring the data semantic is what I want to do. Don’t become paralyzed if it’s not self-evident from the start.

Listing 8

    type Time struct {
        sec  int64
        nsec int32
        loc  *Location
    }

Here is the Time struct from the time package. If I was being asked to implement the API for this data structure, what should I choose, value or pointer semantics?

Sometimes I can ask these question:

- Does a change in the data completely create a new data point?
- Is the data specific to a context, and are mutations isolated to that context?
- Should there only ever be one instance of this data?

If I’m looking at an existing code base and I want to know what data semantic was chosen, look for a factory function. The return type of a factory function should dictate the data semantics.

Listing 9

    func Now() Time {
        sec, nsec := now()
        return Time{sec + unixToInternal, nsec, Local}
    }

This is the factory function for constructing Time values. Look at the return, it’s using value semantics. This tells me that I should be using value semantics for Time values which means every function gets its own copy of a Time value and fields in a struct should be declared as values of type Time.


Listing 10

    func (t Time) Add(d Duration) Time {
        t.sec += int64(d / 1e9)
        nsec := int32(t.nsec) + int32(d%1e9)
        if nsec >= 1e9 {
            t.sec++
            nsec -= 1e9
        } else if nsec < 0 {
            t.sec--
            nsec += 1e9
        }
        t.nsec = nsec
        return t
    }

Add is a method that needs to perform a mutation operation. If I look closely, I will see the function is using value semantic mutation. The Add method gets its own copy of the Time value used to make the call, it mutates its own copy, then it returns a copy back to the caller. Once again, this is the safest way to perform a mutation operation.

Listing 11

    func div(t Time, d Duration) (qmod2 int, r Duration) {}

Here is another example where the div function accepts a value of type Time and Duration (int64), then returns values of type int and Duration. Value semantics for the Time type and for all the built-in types. Duration has an underlying type of int64.

Listing 12

    func (t *Time) UnmarshalBinary(data []byte) error {}
    func (t *Time) GobDecode(data []byte) error {}
    func (t *Time) UnmarshalJSON(data []byte) error {}
    func (t *Time) UnmarshalText(data []byte) error {}

These four methods from the Time package seem to break the rules for data semantic consistency. They are using pointer semantics, why? Because they are implementing an interface where the method signature is locked in. Since the implementation requires a mutation, pointer semantics are the only choice.

Here is a guideline: If value semantics are at play, I can switch to pointer semantics for some functions as long as I don’t let the data in the remaining call chain switch back to value semantics. Once I switch to pointer semantics, all future calls from that point need to stick to pointer semantics. I can never, ever, never, go from pointer to value. It’s never safe to make a copy of a value that a pointer points to.


Listing 13

    func Open(name string) (file *File, err error) {
        return OpenFile(name, O_RDONLY, 0)
    }

The Open function from the os package shows that when using a value of type File, pointer semantics are at play. File values need to be shared and should never be copied.

Listing 14

    func (f *File) Chdir() error {
        if f == nil {
            return ErrInvalid
        }
        if e := syscall.Fchdir(f.fd); e != nil {
            return &PathError{"chdir", f.name, e}
        }
        return nil
    }

The method Chdir is using a pointer receiver even though this method does not mutate the File value. This is because File values need to be shared and can’t be copied.

Listing 15

    func epipecheck(file *File, e error) {
        if e == syscall.EPIPE {
            if atomic.AddInt32(&file.nepipe, 1) >= 10 {
                sigpipe()
            }
        } else {
            atomic.StoreInt32(&file.nepipe, 0)
        }
    }

The epipecheck function as well accepts File values using pointer semantics.

** Methods Are Just Functions
Methods are really just functions that provide syntactic sugar to provide the ability for data to exhibit behavior.


Listing 16

    type data struct {
        name string
        age  int
    }

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

A type and two methods are declared. The displayName method is using value semantics and setAge is using pointer semantics.

Note: Do not implement setters and getters in Go. These are not apis with purpose and in these cases it’s better to make those fields exported.

Listing 17
    
    d := data{
        name: "Bill",
    }

    d.displayName()
    d.setAge(21)

A value of type data is constructed and method calls are made.

Listing 18

    data.displayName(d)
    (*data).setAge(&d, 21)

Since methods are really just functions with syntactic sugar, the methods can be executed like functions. I can see that the receiver is really a parameter, it’s the first parameter. When I call a method, the compiler converts that to a function call underneath.

Note: Do not execute methods like this, but I may see this syntax in tooling messages.

** Know The Behavior of the Code
If I know the data semantics at play, then I know the behavior of the code. If I know the behavior of the code, then I know the cost of the code. Once I know the cost, I’m engineering.

Given this type and method set.

Listing 19

    type data struct {
        name string
        age  int
    }

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

I can write the following code.

Listing 20

    func main() {
        d := data{
            name: "Bill",
        }

        f1 := d.displayName
        f1()
        d.name = "Joan"
        f1()
    }

Output:

    My Name Is Bill
    My Name Is Bill

I start with constructing a value of type Data assigning it to the variable d. Then I take the method displayName, bound to d, and assign that to a variable named f1. This is not a method call but an assignment which creates a level of indirection. Functions are values in Go and belong to the set of internal types.

After the assignment, I can call the method indirectly through the use of the f1 variable. This displays the name Bill. Then I change the data so the name is now Joan, and call the method once again through the f1 variable. I don’t see the change. Bill is the output once again. So Why?


Figure 1

.image /tour/static/img/m1.png

It has to do with the data semantics at play. The displayName method is using a value receiver so value semantics are at play.

Listing 21

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

This means that the f1 variable maintains and operates against its own copy of d. So calling the method through the f1 variable, will always use the copy and that copy is protected against change. This is what I want with value semantics.
Now I will do the same thing but with the setAge method.

Listing 22

    func main() {
        d := data{
            name: "Bill",
        }

        f2 := d.setAge
        f2(45)
        d.name = "Sammy"
        f2(45)
    }

Output:

    Bill Is Age 45
    Sammy Is Age 45

This time the setAge method is assigned to the variable f2. Once again, the method is executed indirectly through the f2 variable passing 45 for Bill’s age. Then Bill’s name is changed to Sammy and the f2 variable is used again to make the call. This time I see the name has changed.


Figure 2

.image /tour/static/img/m2.png

The setAge function is using a pointer receiver so setAge doesn’t operate on its own copy of the d variable, but is operating directly on the d variable. Therefore, f2 is operating on shared access and I see the change.

Listing 23

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

Without knowing the data semantics at play, I won’t know the behavior of the code. These data semantics are real and affect the behavior.


** Notes

- Methods are functions that declare a receiver variable.
- Receivers bind a method to a type and can use value or pointer semantics.
- Value semantics mean a copy of the value is passed across program boundaries.
- Pointer semantics mean a copy of the values address is passed across program boundaries.
- Stick to a single semantic for a given type and be consistent.

** Quotes

"Methods are valid when it is practical or reasonable for a piece of data to expose a capability." - William Kennedy

** Links

- [[https://golang.org/doc/effective_go.html#methods][Methods]]    
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methods, Interfaces and Embedded Types in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2018/01/escape-analysis-flaws.html][Escape-Analysis Flaws]] - William Kennedy  

			 
* Exercises

Exercise 1

Declare a struct that represents a baseball player. Include name, atBats and hits. Declare a method that calculates a players batting average. The formula is Hits / AtBats. Declare a slice of this type and initialize the slice with several players. Iterate over the slice displaying the players name and batting average.

.play methods/exercises/template1/template1.go
			 

.play methods/exercises/exercise1/exercise1.go
			 

All material is licensed under the [[http://www.apache.org/licenses/LICENSE-2.0][Apache License Version 2.0, January 2004]].
