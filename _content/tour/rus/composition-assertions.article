Преобразования типов и утверждения
Как работают преобразования и утверждения типов.

* Преобразования типов и Утверждения

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Преобразование типа позволяет данным одного типа преобразовываться в другой тип.
Утверждение типа позволяет задать вопрос, содержится ли значение заданного типа
внутри интерфейса.

** Обзор кода

- *Пример* *1:* Преобразование Интерфейсов
- *Пример* *2:* Утверждения типов во время выполнения
- *Пример* *3:* Изменение Поведения

.play composition/assertions/example1.go
.play composition/assertions/example2.go
.play composition/assertions/example3.go

** Неявные преобразования интерфейса

Как вы видели в последнем примере, значение интерфейса одного типа может быть представлено
в виде интерфейса другого типа, если конкретное значение, хранящееся в интерфейсе,
реализует оба поведения. Это можно считать неявным преобразованием интерфейса, но лучше рассматривать
это с точки зрения того, как конкретные данные перемещаются через интерфейсы в выделенном состоянии.

    type Mover interface {
        Move()
    }

    type Locker interface {
        Lock()
        Unlock()
    }

    type MoveLocker interface {
        Mover
        Locker
    }

Имея эти три интерфейса, можно сказать что MoveLocker - это композиция Mover и Locker.

    type bike struct{}

    func (bike) Move() {
        fmt.Println("Moving the bike")
    }

    func (bike) Lock() {
        fmt.Println("Locking the bike")
    }

    func (bike) Unlock() {
        fmt.Println("Unlocking the bike")
    }

Имея конкретный тип bike, реализующий все три интерфейса. Что вы можете сделать?

    var ml MoveLocker
    var m Mover

Вы можете создать значение типа MoveLocker и Mover в состоянии его нулевого значения.
Это интерфейсное значение, которое действительно не несёт в себе каких-либо данных.

    ml = bike{}

Затем вы можете создать значение типа bike в состоянии его нулевого значения
и присвоить копию переменной MoveLocker ml. Это возможно, потому что bike реализует
все три поведения, и компилятор видит, что реализация существует.

    m = ml

Затем вы можете присвоить переменную MoveLocker ml переменной Mover m. Это возможно,
потому что я не присваиваю значение интерфейса ml, а конкретное значение, хранящееся в ml,
которое является значением bike. Компилятор знает, что любое конкретное значение,
хранящееся в ml, также должно реализовать интерфейс Mover.

Следующая операция, однако, недопустима.

    ml = m

Вывод:

    cannot use m (type Mover) as type MoveLocker in assignment:
        Mover does not implement MoveLocker (missing Lock method)

Вы не можете присвоить переменную Mover m переменной MoveLocker ml, потому что
компилятор может гарантировать только то, что конкретное значение, хранящееся в m,
знает, как выполнять Move. На момент компиляции неизвестно,  знает ли конкретное значение также,
как выполнять Lock и Unlock.

** Механика Утверждения Типа

Утверждение типа позволяет вам во время выполнения задать вопрос: хранится ли значение заданного типа,
внутри интерфейса. Это можно проверить с помощью синтаксиса m.(bike).

    b := m.(bike)
    ml = b

В этом случае вы спрашиваете, хранится ли, на момент выполнения кода, значение bike внутри m.
Если да, то переменной b присваивается копия значения bike. Затем копия может быть скопирована
внутрь переменной интерфейса ml.

Если значение bike внутри значения интерфейса отсутствует, программа вызывает панику.
Это хорошо в ситуации, если там абсолютно должно было быть значение bike. А если есть шанс того,
что его нет, и это допустимо? Тогда вам нужна вторая форма утверждения типа.

    b, ok := m.(bike)

В этой форме, если ok равно true, внутри интерфейса хранится значение bike.
Если ok равно false, тогда его нет, и программа не вызывает панику.
Однако переменная b по-прежнему имеет тип bike, но в состоянии нулевого значения.

    func main() {
        mvs := []fmt.Stringer{
            Car{},
            Cloud{},
        }

        for i := 0; i < 10; i++ {
            rn := rand.Intn(2)

            if v, is := mvs[rn].(Cloud); is {
                fmt.Println("Got Lucky:", v)
                continue
            }

            fmt.Println("Got Unlucky")
        }
    }

Предполагая, что в программе объявлены два типа с именами Car и Cloud, каждый из которых
реализует интерфейс fmt.Stringer, вы можете создать коллекцию, которая позволяет хранить
значения как Car, так и Cloud. Затем 10 раз случайным образом выбирается число от 0 до 1,
и выполняется утверждение типа для проверки, содержит ли значение в этом случайном индексе
значение типа Cloud. Поскольку существует возможность, что это не тип Cloud, вторая форма
утверждения типа крайне важна в этом контексте.
