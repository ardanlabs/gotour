Базовые типы
Вы можете объявить дженерики, используя базовый тип.

* Дженерики - базовые типы

Вы можете объявить дженерик, используя базовый тип.

** Видео

Посмотрите лекцию о дженериках, в которой я рассказываю обо всех
примерах в этом разделе.

.html generics-video.html

** Обзор кода

- *Пример* *1*: vector для конкретного типа
- *Пример* *2*: vector пустых интерфейсов
- *Пример* *3*: vector с использованием дженериков

.play generics/underlying-types/example1.go
.play generics/underlying-types/example2.go
.play generics/underlying-types/example3.go

** Объяснения

Что, если вы хотите объявить свой собственный дженерик, используя базовый тип?

    type vector[T any] []T

    func (v vector[T]) last() (T, error) {
        var zero T
        
        if len(v) == 0 {
            return zero, errors.New("empty")
        }
        
        return v[len(v)-1], nil
    }

В этом примере показан дженерик vector, который ограничивает его построение
только одним типом данных. Использование квадратных скобок объявляет, что тип T является дженериком, который будет определен во время компиляции. Использование ограничения "any" описывает
что нет никаких ограничений на то, каким типом может стать T.

Последний метод объявлен с приемником значения типа `vector[T]` для представления
значение типа `vector` с базовым срезом некоторого типа T. Метод возвращает значение того же типа T.

    func main() {
        fmt.Print("vector[int] : ")

        vGenInt := vector[int]{10, -1}

        i, err := vGenInt.last()
        if err != nil {
            fmt.Print("ERROR:", err)
            return
        }

        if i < 0 {
            fmt.Print("negative integer: ")
        }

        fmt.Printf("value: %d\n", i)

        // -------------------------------------------------------------------------

        fmt.Print("vector[string] : ")

        vGenStr := vector[string]{"A", "B", string([]byte{0xff})}

        s, err := vGenStr.last()
        if err != nil {
            fmt.Print("ERROR:", err)
            return
        }

        if !utf8.ValidString(s) {
            fmt.Print("non-valid string: ")
        }

        fmt.Printf("value: %q\n", s)
    }

Output:

    vector[int] : negative integer: value: -1
    vector[string] : non-valid string: value: "\xff"

Вот как сконструировать значение типа `vector` с базовым типом int, когда мы
будем задавать значения  вектора при построении. Важным аспектом этого кода являются
вызов конструкции.

    // Zero Value Construction
    var vGenInt vector[int]
    var vGenStr vector[string]
    
    // Non-Zero Value Construction
    vGenInt := vector{10, -1}
    vGenStr := vector{"A", "B", string([]byte{0xff})}

Когда дело доходит до конструирования дженериков до их нулевого значения, это не возможно,
компилятор не может вывести тип. Однако в тех случаях, когда
инициализация при построении, компилятор может вывести тип.

Существует аспект спецификации, который фокусируется на построении дженерик типа до
его состояния с нулевым значением.

    type vector[T any] []T
    
    func (v vector[T]) last() (T, error) {
        var zero T
        
        if len(v) == 0 {
            return zero, errors.New("empty")
        }
        
        return v[len(v)-1], nil
    }

Обратите внимание на объявление метода last и на то, как он возвращает значение дженерик типа T.
возвращает значение дженерик типа T. При первом возврате возникает ситуация, когда необходимо
вернуть нулевое значение для типа T. Текущая реализация предоставляет два решения этой проблемы.
этого кода. Первое решение вы уже видели. Переменная  `zero` конструируется до
состояния нулевого значения типа T, а затем эта переменная используется для возврата.

Другой вариант - использовать встроенную функцию `new` и разыменовать возвращаемый
указатель в операторе возврата.

    type vector[T any] []T
    
    func (v vector[T]) last() (T, error) {
        if len(v) == 0 {
            return *new(T), errors.New("empty")
        }
        
        return v[len(v)-1], nil
    }

Эта версия последнего метода использует встроенную функцию `new` для построения нулевого значения
и разыменования возвращаемого указателя для удовлетворения возвращаемого типа T.

Примечание: Вы можете подумать, почему бы не использовать T{} для построения нулевого значения? Но
проблема в том, что этот синтаксис работает не со всеми типами, например со скалярными типами (int,
string, bool). Так что это не вариант.

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Приведены возможные решения.

** Упражнение 1

Объявите дженерик тип с именем `keymap`, который использует базовый тип `map`
с ключом типа `string` и значением некоторого типа T. Объявите метод
`set`, который принимает ключ типа `string` и значение типа T. Объявите
метод `get`, который принимает ключ типа `string` и возвращает значение
типа `T` и `true` или `false`, если ключ найден. Затем напишите `main` функцию
которая использует эти методы.

.play generics/underlying-types/exercise1.go 
.play generics/underlying-types/answer1.go
