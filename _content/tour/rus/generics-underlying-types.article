Базовые типы
Вы можете объявить дженерики, используя базовый тип.

* Дженерики - базовые типы

Вы можете объявить дженерик, используя базовый тип.

** Видео

Посмотрите лекцию о дженериках, в которой я рассказываю обо всех
примерах в этом разделе.

.html generics-video.html

** Обзор кода

- *Пример* *1*: vector для конкретного типа
- *Пример* *2*: vector пустых интерфейсов
- *Пример* *3*: vector с использованием дженериков

.play generics/underlying-types/example1.go
.play generics/underlying-types/example2.go
.play generics/underlying-types/example3.go

** Объяснения

Что, если вы хотите объявить свой собственный дженерик, используя базовый тип?

    type vector[T any] []T

    func (v vector[T]) last() (T, error) {
        var zero T
        
        if len(v) == 0 {
            return zero, errors.New("empty")
        }
        
        return v[len(v)-1], nil
    }

В этом примере показан дженерик vector, который ограничивает его построение
только одним типом данных. Использование квадратных скобок объявляет, что тип T является дженериком, который будет определен во время компиляции. Использование ограничения "any" описывает
что нет никаких ограничений на то, каким типом может стать T.

Метод last объявлен с индентификатором типа `vector[T]` для представления
значения типа `vector` как среза некоторого типа T. Метод возвращает значение того же типа T.

    func main() {
        fmt.Print("vector[int] : ")

        vGenInt := vector[int]{10, -1}

        i, err := vGenInt.last()
        if err != nil {
            fmt.Print("ERROR:", err)
            return
        }

        if i < 0 {
            fmt.Print("negative integer: ")
        }

        fmt.Printf("value: %d\n", i)

        // -------------------------------------------------------------------------

        fmt.Print("vector[string] : ")

        vGenStr := vector[string]{"A", "B", string([]byte{0xff})}

        s, err := vGenStr.last()
        if err != nil {
            fmt.Print("ERROR:", err)
            return
        }

        if !utf8.ValidString(s) {
            fmt.Print("non-valid string: ")
        }

        fmt.Printf("value: %q\n", s)
    }

Output:

    vector[int] : negative integer: value: -1
    vector[string] : non-valid string: value: "\xff"

Вот как сконструировать значение типа `vector` с базовым типом int, когда мы
хотим задать его значение при построении. Важным аспектом этого кода является
вызывающая конструкция.

    // Zero Value Construction
    var vGenInt vector[int]
    var vGenStr vector[string]
    
    // Non-Zero Value Construction
    vGenInt := vector{10, -1}
    vGenStr := vector{"A", "B", string([]byte{0xff})}

Обычно, когда дело доходит до конструирования нулевого значения дженериков, у компилятора нет возможности вывести тип.
Однако, это возможно в случае явной инициализации значения.
инициализация при построении, компилятор может вывести тип.

В спецификации языка есть отдельный аспект, фокусирующийся на построении нулевого значения дженерик типа.
его состояния с нулевым значением.

    type vector[T any] []T
    
    func (v vector[T]) last() (T, error) {
        var zero T
        
        if len(v) == 0 {
            return zero, errors.New("empty")
        }
        
        return v[len(v)-1], nil
    }

Обратите внимание на объявление метода last и на то, как он возвращает значение дженерик типа T.
возвращает значение дженерик типа T. При первом возврате возникает ситуация, когда необходимо
вернуть нулевое значение для типа T. Текущая реализация предоставляет два решения этой проблемы.
Первое решение вы уже видели. Переменная  `zero` конструируется в состоянии нулевого значения,
а затем эта переменная используется для возврата.

Другой вариант - использовать встроенную функцию `new` и разыменовать возвращаемый
указатель в операторе возврата.

    type vector[T any] []T
    
    func (v vector[T]) last() (T, error) {
        if len(v) == 0 {
            return *new(T), errors.New("empty")
        }
        
        return v[len(v)-1], nil
    }

Эта версия метода last использует встроенную функцию `new` для построения нулевого значения
и разыменования возвращаемого указателя для удовлетворения возвращаемого типа T.

Примечание: Вы можете подумать, почему бы не использовать T{} для построения нулевого значения? Но
проблема в том, что этот синтаксис работает не со всеми типами, например со скалярными типами (int,
string, bool). Так что это не вариант.

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Приведены возможные решения.

** Упражнение 1

Объявите дженерик тип с именем `keymap`, который использует базовый тип `map`
с ключом типа `string` и значением некоторого типа T. Объявите метод
`set`, который принимает ключ типа `string` и значение типа T. Объявите
метод `get`, который принимает ключ типа `string` и возвращает значение
типа `T` и `true` или `false`, если ключ найден. Затем напишите `main` функцию
которая использует эти методы.

.play generics/underlying-types/exercise1.go 
.play generics/underlying-types/answer1.go
