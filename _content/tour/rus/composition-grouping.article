Группировка с использованием типов
Важно помнить, что в Go концепции подтипов или наследования действительно не существует, и этих шаблонов проектирования следует избегать.

* Группировка с использованием типов

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Важно помнить, что в Go концепции подтипов или наследования действительно не существует, и этих шаблонов проектирования следует избегать.

** Обзор кода

- *Пример* *1:* Группировка по состоянию
- *Пример* *2:* Группировка по поведению

.play composition/grouping/example1.go
.play composition/grouping/example2.go

** Группировка разных типов данных

Важно помнить, что в Go концепции подтипов или наследования действительно не существует,
и этих шаблонов проектирования следует избегать.

Следующий код - это антипаттерн, который не стоит использовать или реализовывать на практике.

    type Animal struct {
        Name string
        IsMammal bool
    }

Тип Animal объявляется как базовый тип, который пытается объявить данные, общие для всех животных.
Он также пытается описать некоторое общее поведение свойственное животным.

    func (a *Animal) Speak() {
        fmt.Println("UGH!",
        "My name is", a.Name, ", it is", a.IsMammal, "I am a mammal")
    }

У большинства животных есть способность, так или иначе, говорить.
Однако попытка применить это общее поведение к животному не имеет смысла.
На данном этапе вы не знаете, какой звук издает это животное, поэтому вы пишете `UGH`.

    type Dog struct {
        Animal
        PackFactor int
    }

Теперь начинаются настоящие проблемы. Мы пытаемся использовать встраивание, чтобы сделать Dog всем,
чем является Animal и даже более того. На первый взгляд это может показаться работающим решением,
но вскоре у нас возникнут проблемы. Несмотря на это, у собаки есть конкретный способ разговаривать.

    func (d *Dog) Speak() {
        fmt.Println("Woof!",
            "My name is", d.Name,
            ", it is", d.IsMammal,
            "I am a mammal with a pack factor of", d.PackFactor)
    }

В реализации метода Speak можно заменить UGH на Woof.
Это специфика того, как говорит собака.

    type Cat struct {
        Animal
        ClimbFactor int
    }

Если у нас есть собака, представляющая Animal, то у нас должна быть и кошка.
Используя встраивание, Cat - это все, чем является Animal и даже более того.

    func (c *Cat) Speak() {
        fmt.Println("Meow!",
            "My name is", c.Name,
            ", it is", c.IsMammal,
            "I am a mammal with a climb factor of", c.ClimbFactor)
    }

В реализации метода Speak можно заменить UGH на Meow.
Это конкретная реализация для того, как говорит кошка.

Все вроде бы идёт хороши, и выглядит так, будто встраивание предоставляет ту же функциональность,
что и наследование в других языках. Затем мы пытаемся сгруппировать собак и кошек по тому факту,
что у них есть общее ДНК животного.

    animals := []Animal{
        Dog{
            Animal: Animal{
                Name: "Fido",
                IsMammal: true,
            },
            PackFactor: 5,
        },

        Cat{
            Animal: Animal{
                Name: "Milo",
                IsMammal: true,
            },
            ClimbFactor: 4,
        },
    }

    for _, animal := range animals {
        animal.Speak()
    }

Когда мы пытаемся это сделать, компилятор жалуется, что Dog и Cat не являются Animal, и это правда.
Встраивание не то же самое, что и наследование, и это шаблон, от которого нужно держаться подальше.
Dog - это Dog, Cat - это Cat, и Animal - это Animal. Нельзя передавать Dog и Cat, как если бы они
были Animal, потому что это не так.

Такая механика также не очень гибка. Она требует настройки со стороны разработчика, и если у вас
нет доступа к коду, вы не сможете по мере необходимости вносить конфигурационные изменения.

Если таким образом мы не можем создавать коллекции собак и кошек, то как иначе мы можем это реализовать в Go?
Здесь речь идёт не о группировке через общее ДНК, а о группировке через общее поведение.
Поведение является ключевым элементом.

    type Speaker interface {
        Speak()
    }

Если мы используем интерфейс, то мы можем определить общий набор методов поведения,
который возможно использовать для группировки разных типов данных.

    speakers := []Speaker{
        &Dog{
            Animal: Animal{
                Name: "Fido",
                IsMammal: true,
            },
            PackFactor: 5,
        },
        &Cat{
            Animal: Animal{
                Name: "Milo",
                IsMammal: true,
            },
            ClimbFactor: 4,
        },
    }

    for _, speaker := range speakers {
        speaker.Speak()
    }

В новом коде теперь можно группировать вместе собак и кошек на основе их общего набора поведения,
а именно того, что собаки и кошки могут говорить.

По факту, тип Animal действительно является мусорным, потому что объявление типа
просто для хранения набора общих состояний - это плохой шаблон и его следует избегать.

    type Dog struct {
        Name string
        IsMammal bool
        PackFactor int
    }

    type Cat struct {
        Name string
        IsMammal bool
        ClimbFactor int
    }

В этом конкретном случае мы, вероятно, предпочли бы удалить тип Animal и скопировать его поля
в типы Dog и Cat. Позже мы рассмотрим заметки с лучшими шаблонами, которые полностью устраняют проблемы такого характера.

Вот признаки плохого кода в нашей первичной реализации:

- Тип Animal предоставляет абстрактный слой повторно используемого состояния.
- Программа никогда не должна создавать или использовать значение типа Animal в чистом виде.
- Реализация метода Speak для типа Animal является обобщенной.
- Метод Speak для типа Animal никогда не будет вызван.

Рекомендации по объявлению типов:

- Объявляйте типы, представляющие собой что-то новое или уникальное.
- Не создавайте псевдонимы только для улучшения читабельности.
- Убедитесь в том, что значение любого типа создается или используется самостоятельно.
- Встраивайте типы не потому, что вам нужно состояние, а потому, что вам нужно поведение.
- Если вы не думаете о поведении, вы привязываете себя к дизайну, который вы не сможете развивать в будущем без каскадных изменений в коде.
- Подвергайте сомнению типы, которые являются псевдонимами или абстракциями существующего типа.
- Подвергайте сомнению типы, чьей единственной целью является общий набор состояний.

** Не проектируйте с использованием интерфейсов

К сожалению, слишком большое количество разработчиков подходят к задачам с попытки решить проблемы абстракций.
Они сразу фокусируются на интерфейсах, и это приводит к загрязнению интерфейсами. Как разработчик
вы существуете в одном из двух режимов: в первую очередь вы программист, а уже затем - вы инженер.

Когда вы программируете, вы сосредоточены на том, чтобы написать работающий код.
Вы пытаетесь решить проблему и сломать стены. Доказать, что ваши первоначальные идеи работают.
Это всё что вас интересует на данном этапе. Этот тип программирования следует выполнять в начальной фазе
и код полученный таким путём никогда полностью не готов.

Как только у нас есть прототип кода решающий проблему, нам нужно переключиться в режим инженера.
Нам нужно сосредоточиться на том, чтобы написать код на микроуровне для семантики данных и читабельности,
а затем на макроуровне для умственных моделей и поддерживаемости. Мы также должны фокусироваться
на ошибках и состояниях при которых система может дать сбой.

Эта работа выполняется в цикле рефакторинга. Рефакторинг для читаемости, эффективности, абстракции
и тестируемости. Абстрагирование - это всего лишь одна из нескольких стадий рефакторинга, которые
необходимо пройти. Это работает лучше всего, когда мы начинаем с конкретного кода и ЗАТЕМ НАХОДИМ интерфейсы,
которые будет необходимы. Не применяйте абстракции, до тех пор пока без них уже нельзя обойтись.

Каждую проблему, которую мы решаем с помощью кода, можно рассматривать как проблему с данными,
требующую написания преобразований данных. Если вы не понимаете данные, вы не понимаете проблему.
Если вы не понимаете проблему, вы не можете написать код. Очень важно начинать с конкретного решения
на основе конкретных структур данных. Как сказал Роб Пайк,

"Данные доминируют. Если вы выбрали правильные структуры данных и все хорошо организовали,
алгоритмы почти всегда станут очевидными."

В каких случаях абстракция необходима? Абстракция необходима, когда вы находите место в коде,
где данные могут измениться, и вы хотите минимизировать каскадные эффекты изменений в коде.
Вы можете использовать абстракцию, чтобы облегчить тестирование кода, но по возможности старайтесь избегать этого.
Лучшие тестируемые функции - это функции, которые принимают необработанные данные и возвращают необработанные данные.
Неважно, откуда идут данные и куда они направляются.

В конечном итоге начинайте с конкретного решения для каждой проблемы. Даже если большая часть этого
сводится к программированию. Затем находите интерфейсы, которые абсолютно необходимы для вашего кода сегодня.

"Не проектируйте на основе интерфейсов, а находите их". - Роб Пайк
