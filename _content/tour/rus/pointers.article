Указатели
Указатели служат для передачи значений через границы внутри программы.

* Указатели

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Указатели служат для передачи значений через границы внутри программы. Существует
несколько типов программных границ. Наиболее распространенная - между вызовами функций.
Существует также граница между горутинами, которые мы обсудим позже.

** Обзор кода

- *Пример* *1:* Передача по значению
- *Пример* *2:* Совместное использование данных (часть 1)
- *Пример* *3:* Совместное использование данных (часть 2)
- *Пример* *4:* Анализ побега (из стэка на кучу)
- *Пример* *5:* Рост стека

.play pointers/example1.go
.play pointers/example2.go
.play pointers/example3.go
.play pointers/example4.go
.play pointers/example5.go

При запуске Go-программы среда выполнения Go создает горутину. Горутины - это
облегченные потоки на уровне приложения во многом схожие с потоками операционной системы.
Их задача - управлять выполнением отдельного набора инструкций. В каждой программе на Go
есть как минимум одна горутина, которую мы называем главной горутиной.

Каждой горутине отводится свой блок памяти, называемый стеком. При создании, под стек  выделяется
2048 байт (2k) памяти. Это очень немного, но со временем стек может увеличиваться в размерах.

.image /tour/eng/static/img/p1.png

Каждый раз, при вызове функции, под выполнение инструкций связанных с этой функцией,
горутине на стэке выделяется блок памяти. Каждый такой блок называется фреймом.

Размер фрейма для каждой функции определяется при компиляции. Значение не может быть
создано на стеке, если на этапе компиляции компилятор не знает размера этого значения.
Если компилятор не знает размера значения на этапе компиляции, значение вынужденно 
создается на куче.

Стеки являются самоочищающимися, и нулевые значения облегчают инициализацию стека.
Каждый раз, при вызове функции, под фрейм выделяется блок памяти; память этого фрейма
инициализируется, что позволяет самоочищение стека. При возврате из функции
память фрейма остается нетронутой, поскольку неизвестно, потребуется ли эта память снова.
Инициализация памяти при возврате была бы неэффективной.

*Передача* *по* *значению*

По ходу выполнения программы, все данные передаются по значению. Это означает, что при
передаче данных через границы программы, каждая функция или горутина получают свою
собственную копию данных. Существуют два типа данных, с которыми вы будете работать:
само значение (int, string, пользователь) или адрес значения. Адреса - это данные,
которые необходимо копировать и сохранять при передаче через границы программы.

Следующий код пытается это более подробно продемонстрировать.

    func main() {

        // Объявление переменной типа int со значением 10.
        count := 10

        // Чтобы получить адрес значения, используйте оператор &.
        println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

        // Передача копии "значения" `count` (то, что находится в коробке)
        // функции increment1.
        increment1(count)

        // Вывод "значения" и "адреса" переменной счет.
        // Значение счета не изменится после вызова функции.
        println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

        // Передача копии "адреса" счета (где находится коробка)
        // функции increment2. Это все равно считается передачей по значению,
        // а не передачей по ссылке, потому что адреса - это значения.
        increment2(&count)

        // Вывод "значения" и "адреса" счета.
        // Значение счета изменилось после вызова функции.
        println(
            "count:\tValue Of[",
            count, "]\tAddr Of[", &count, "]")
    }

    // increment1 объявляет функцию, создающую свою собственной копию
    // целочисленного значения.
    func increment1(inc int) {

        // Увеличить локальную копию целочисленного значения.
        inc++
        println("inc1:\tValue Of[", inc, "]\tAddr Of[", &inc, "]")
    }

    // increment2 объявляет функцию, принимающую копию адреса,
    // указывающего на целочисленное значение.
    // Переменные-указатели - это литеральные типы которые объявляются с помощью *.
    func increment2(inc *int) {

        // Увеличить целочисленное значение вызывающего через указатель.
        *inc++
        println(
            "inc2:\tValue Of[",
            inc, "]\tAddr Of[", &inc,
            "]\tPoints To[", *inc, "]")
    }

Результат:

    count:  Value Of[ 10 ]  Addr Of[ 0xc000050738 ]
    inc1:   Value Of[ 11 ]  Addr Of[ 0xc000050730 ]
    count:  Value Of[ 10 ]  Addr Of[ 0xc000050738 ]
    inc2:   Value Of[ 0xc000050738 ] Addr Of[ 0xc000050748 ] Points To[ 11 ]
    count:  Value Of[ 11 ]  Addr Of[ 0xc000050738 ]

** Заметки

- Используйте указатели для обмена данными.
- Значения в Go всегда передаются по значению.
- "Значение", то, что находится в коробке. "Адрес" ( & ), это где находится коробка.
- Оператор ( * ) объявляет переменную-указатель и "Значение, на которое указывает указатель".

** Анализ побега (памяти со стэка на кучу)

Алгоритм, который компилятор использует для определения, следует ли создавать значение
на стеке или куче, называется "анализом побега". Название алгоритма может создать
впечатление, будто значения сначала создаются на стеке, а затем "убегают" (или перемещаются)
на кучу, когда это необходимо. Это НЕ так. Создание значения происходит только один раз,
и алгоритм анализа побега решает, где это произойдет (стек или куча). Только создание
на куче называется выделением памяти в Go.

Анализ побега требует понимания того кто владеет значением. Идея заключается
в том, что когда значение создается внутри функции, то эта функция владеет значением.
Затем возникает вопрос, должно ли значение, которое создается, все еще существовать
когда после завершения работы функция-владелец возвращает значение? Если ответ - нет,
то значение может быть создано на стеке. Если ответ - да, значение должно быть
создано на куче.

Примечание: Правило владения - это хорошее базовое правило для идентификации кода, который
приводит к выделению памяти. Однако нужно понимать, что анализ побега имеет недостатки,
которые могут привести к неочевидным выделениям. Кроме того, алгоритм использует оптимизации
компилятора для уменьшения количества выделений памяти.

    // user представляет собой пользователя в системе.
    type user struct {
        name  string
        email string
    }

    func stayOnStack() user {
        u := user{
            name:  "Bill",
            email: "bill@email.com",
        }

        return u
    }

Функция stayOnStack использует семантику значения для возврата значения
user вызывающему. Другими словами, вызывающий получает собственную  копию
значения user, созданного функцией stayOnStack.

Когда функция stayOnStack завершает работу, значение user, которое она создает,
больше не должно существовать, так как вызывающий получает собственную копию.
Поэтому создание значения user в рамках stayOnStack может происходить на стеке.
Выделения памяти на куче не происходит.

    type user struct {
        name  string
        email string
    }

    func escapeToHeap() *user {
        u := user{
            name:  "Bill",
            email: "bill@email.com",
        }

        return &u
    }

Функция escapeToHeap использует семантику указателя для возврата значения user
в вызывающую функцию. Другими словами, вызывающая функция получает доступ (адрес) к
создаваемому значению user.

Когда функция escapeToHeap вызывается и завершает выполнение, значение user, которое она создает,
все равно должно существовать, так как вызывающая функция получает общий доступ к значению.
Поэтому создание значения внутри функции escapeToHeap не может происходить в стеке,
оно должно происходить в куче. Да, это выделение памяти в куче.

Подумайте о том, что произойдет, если значение user в последнем примере произойдет в стеке
используя семантику указателя при возврате.

.image /tour/eng/static/img/p2.png

Вызывающая функция получит копию адреса стека из предыдущего фрейма, и целостность
будет потеряна. Как только управление возвращается в вызывающую функцию, память на
стеке, где находится значение user, становится снова доступной для использования.
В момент, когда вызывающая функция выполняет очередной вызов функции, создается
новый фрейм, и память будет перезаписана, уничтожив общее значение.

Вот почему стоит думать о стеке как о самоочищающемся. Инициализация нулевым значением
помогает очищать каждый стековый фрейм, без использования сборщика мусора (GC). Стек
самоочищающийся, так как для выполнения каждого вызова функции берется и инициализируется
фрейм. Очистка стека происходит во время вызова функций, а не при возвратах, потому
что компилятор не знает, потребуется ли в будущем эта память на стеке.

Анализ побега определяет, создается ли значение на стеке (по умолчанию) или
в куче (при побеге). С функцией stayOnStack мы передаем копию значения обратно вызывающей
функции, поэтому безопасно оставить значение на стеке. С функцией escapeToHeap мы передаем
копию адреса значения обратно вызывающей функции (давая общий доступ к стеку),
поэтому небезопасно оставлять значение на стеке.

Существует множество мелких деталей, связанных с анализом побега. Чтобы лучше разобраться
в этой теме читайте пост в главе 14 под названием "Механика анализа побега".

Примечание: Начиная с версии 1.17, Go изменил ABI (бинарный интерфейс приложения),
и перешел на новый способ передачи аргументов ввода и вывода функций с использованием
регистров вместо памяти на стеке. Это работает на 64-разрядной архитектуре x86
Linux, MacOS и Windows. Это означает, что некоторые аргументы функций не будут копироваться
в стек, но некоторые (в зависимости от возможности использования регистров) могут.
Это не изменяет семантики, описанной в этой главе.

** Примечания

- Когда значение может быть использовано после возврата функции, которая его создает.
- Когда компилятор определяет, что размер значения слишком велик для размещения на стеке.
- Когда компилятор не знает размера значения на этапе компиляции.
- Когда значение отделяется посредством использованием функций или интерфейсов.

** Семантика сборки мусора:

Как только значение создано в куче, включается механизм сборки мусора (GC).
Самая важная часть GC - это алгоритм планирования. Он определяет частоту/темп, с
которым GC должен выполняться, чтобы поддерживать наименьший объем кучи
в сочетании с наилучшей производительностью приложения.

- [[https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html][Семантика сборки мусора, часть I]] - Уильям Кеннеди

** Стек против Кучи

"Стек предназначен для данных, которые должны существовать только в течение времени
выполнения функции, которая их создает, и он освобождаются без каких-либо затрат при выходе
из функции. Куча предназначена для данных, которые должны существовать после завершения функции,
которая их создала, и ее освобождение требует (иной раз дорогостоящей), сборки мусора." - Айян Джордж

** Рост стека

Размер фрейма для каждой функции вычисляется на этапе компиляции. Это означает,
что если компилятор не знает размер значения на этапе компиляции, значение должно
быть создано в куче. Примером может послужить использование встроенной функции make
для создания среза, размер которого зависит от переменной.

    b := make([]byte, size) // Массив создается в куче.

Go использует вариант непрерывного стек, чтобы определить, как стеки растут и уменьшаются.
Одной из альтернатив, которую мог бы использовать Go - реализация сегментированного стека,
которая используется в некоторых операционных системах.

Каждый вызов функции сопровождается небольшой преамбулой, которая спрашивает: "Достаточно ли
места на стеке для этого нового фрейма?". Если да, то проблем нет, и фрейм инициализируется.
Если нет, то должен быть создан новый, более крупный стек, и память на существующем стеке
должна быть скопирована в новый. Это требует изменения указателей, которые ссылаются на память
на стеке. Преимущества непрерывной памяти и линейного обхода современного оборудования
являются компромиссом ценой которого являются затраты на копирование.

Из-за использования непрерывных стеков, ни одна горутина не может иметь указателя на стек
другой горутины. Затраты среды выполнения, по отслеживанию каждого указателя на каждый стек
и корректировки этих указателей для нового местоположения, были бы слишком велики.

** Дополнительное чтение

**Механика* *Указателей*

- [[https://golang.org/doc/effective_go.html#pointers_vs_values][Указатели против Значений]]
- [[https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html][Механика языка по стекам и указателям]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2014/12/using-pointers-in-go.html][Использование указателей в Go]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2013/07/understanding-pointers-and-memory.html][Понимание указателей и выделения памяти]] - Уильям Кеннеди

*Стеки*

- [[https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub][Предложение о непрерывном стеке]]

*Анализ* *Побега* *и* *Встраивание*

- [[https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw][Недостатки анализа побега Go]]
- [[https://github.com/golang/go/wiki/CompilerOptimizations][Оптимизации компилятора]]

*Сборка* *Мусора*

- [[http://gchandbook.org/][Справочник по Сборке Мусора]]
- [[https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md][Пересмотр сборки мусора - 2021]] - Майкл Книсзек
- [[https://en.wikipedia.org/wiki/Tracing_garbage_collection][Сборка мусора с отслеживанием]]
- [[https://blog.golang.org/go15gc][Блог Go - Сборка мусора версии 1.5]]
- [[https://www.youtube.com/watch?v=aiv1JOfMjm0&index=16&list=PL2ntRZ1ySWBf-_z-gHCOR2N156Nw930Hm][Сборка мусора в Go: решение проблемы латентности]]
- [[http://rubinius.com/2013/06/22/concurrent-garbage-collection][Параллельная сборка мусора]]
- [[https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit][Планирование сборки мусора в Go 1.5]]
- [[https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md][Ликвидация повторного сканирования стека]]
- [[https://groups.google.com/forum/m/#!topic/golang-nuts/KJiyv2mV2pU][Почему сборщик мусора Go не реализует компактную сборку мусора?]] - Иэн Ланс Тейлор
- [[https://blog.golang.org/ismmkeynote][Достигая Go: Путешествие сборщика мусора Go]] - Рик Хадсон
- [[https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html][Сборка мусора в Go, часть I - Семантика]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html][Сборка мусора в Go, часть II - Трассировки GC]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html][Сборка мусора в Go, часть III - Регулировка GC]] - Уильям Кеннеди
- [[https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/][Балласт памяти Go: Как я научился не волноваться и полюбил кучу]] - Росс Энгерс

*Оптимизации* *Статического* *Единичного* *Присваивания*

- [[https://www.youtube.com/watch?v=D2-gaMvWfQY][GopherCon 2015: Бен Джонсон - Статический анализ кода с использованием SSA]]
- [[https://godoc.org/golang.org/x/tools/go/ssa][Пакет SSA]]
- [[https://www.youtube.com/watch?v=FnGCDLhaxKU][Понимание оптимизации компилятора]]

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1:

*Часть* *А*: Объявите переменную типа int и проинициализируйте ее значением 20.
Выведите "адрес" и "значение" переменной.

*Часть* *Б*: Объявите и инициализируйте переменную-указатель на тип int, указывающую
на переменную, которую вы создали в предыдущем задании. Выведите "адрес", "значение"
и "значение, на которое указывает указатель".

** Упражнение 2:

Объявите тип структуры и создайте значение этого типа. Объявите функцию, которая
может изменить значение какого-либо поля в этом типе структуры. Выведите значение до
и после вызова вашей функции.

.play pointers/exercise1.go
.play pointers/answer1.go
.play pointers/exercise2.go
.play pointers/answer2.go
