Экспортирование
Экспортирование предоставляет возможность объявить, доступен ли идентификатор для кода за пределами пакета, в котором он объявлен.

* Экспортирование

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Watch The Video]]
- Need Financial Assistance, Use Our [[https://www.ardanlabs.com/scholarship/][Scholarship Form]]

Экспортирование предоставляет возможность объявить, доступен ли идентификатор для кода за пределами пакета,
в котором он объявлен.

** Обзор кода

- *Пример* *1:* Объявление и доступ к экспортированным идентификаторам
- *Пример* *2:* Объявление неэкспортированных идентификаторов и ограничения
- *Пример* *3:* Доступ к значениям неэкспортированных идентификаторов
- *Пример* *4:* Неэкспортированные поля структурного типа
- *Пример* *5:* Неэкспортированные встроенные типы

.play exporting/example1.go
.play exporting/example2.go
.play exporting/example3.go
.play exporting/example4.go
.play exporting/example5.go

** Механика экспортирования

Пакет - это основная единица скомпилированного кода в Go. Он представляет собой физически скомпилированную
единицу кода, обычно в виде скомпилированной библиотеки в операционной системе хоста. Экспортирование
определяет доступ к идентификаторам через границы пакета.

    package counters

    type AlertCounter int

В этом случае, поскольку в имени типа AlertCounter используется заглавная буква,
тип экспортируется и может быть использован кодом за пределами пакета counters.

    package counters

    type alertCounter int

Теперь, когда вы изменили имя типа, чтобы оно начиналось с маленькой буквы, тип
не экспортируется. Это означает, что только код внутри пакета counters может ссылаться
на этот тип напрямую.

    package counters

    type alertCounter int

    func New(value int) alertCounter {
        return alertCounter(value)
    }

Несмотря на то, что этот код является синтаксически правильным и будет успешно компилироваться, в нем нет смысла.
Возвращение значения неэкспортируемого типа вводит путаницу, поскольку вызывающая сторона
(которая, вероятно, находится в другом пакете) не может ссылаться на имя типа напрямую.

    package main

    import (
        "fmt"

        "github.com/ardanlabs/.../exporting/example3/counters"
    )

    func main() {
        counter := counters.New(10)
        fmt.Printf("Counter: %d\n", counter)
    }

В этом случае функция main в пакете main успешно вызывает функцию counters.New
и компилятор может объявить и создать переменную неэкспортируемого типа. Это не означает,
что так следует поступать, и это не означает, что построив код таким образом, вы получите
какую-либо реальную защиту. Этого следует избегать, и если New возвращает значение,
оно должно быть экспортированного типа.

    package users

    type User struct {
        Name string
        ID   int

        password string
    }

Когда речь идет о полях в структуре, первая буква объявляет, доступно ли поле
коду за пределами пакета, в котором оно объявлено. В этом случае Name
и ID доступны, но password - нет. Разделение экспортированных и неэкспортированных полей
в этом стиле, считается идиоматическим в случае, когда такое разделение разумно или практично.
Обычно все поля были бы одним либо другим.

    package users

    type user struct {
        Name string
        ID   int
    }

    type Manager struct {
        Title string
        user
    }

В этом сценарии, даже если тип user неэкспортируем, у него есть два экспортированных
поля. Это означает, что когда тип user встроен в экспортированный тип Manager,
поля user продвигаются и становятся доступными. Часто бывает, что типы являются
неэкспортируемыми с экспортированными полями, поскольку пакет рефлексии может
работать только с экспортированными полями. Маршаллеры иначе не будут работать.

Этот пример создает плохую ситуацию, когда код за пределами пакета users может
создать Manager, но поскольку встроенный тип user неэкспортируем, поля для
этих типов могут быть инициализированы. Это создает проблемы с частичной
конструкцией, которые приведут к ошибкам. Необходимо соблюдать последовательность
экспортирования и неэкспортирования.

** Заметки

- Код Go компилируется в пакеты, а затем связывается вместе.
- Идентификаторы экспортируются (или остаются неэкспортированными) на основе регистра букв.
- Мы импортируем пакеты для доступа к экспортированным идентификаторам.
- Любой пакет может использовать значение неэкспортируемого типа, но это считается плохой практикой.

** Дополнительное чтение

[[https://www.ardanlabs.com/blog/2014/03/exportedunexported-identifiers-in-go.html][Экспортированные/Неэкспортированные идентификаторы в Go]] - Уильям Кеннеди

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1

*Часть* *A:* Создайте пакет с именем toy с единственным экспортированным структурным типом Toy.
Добавьте экспортированные поля Name и Weight. Затем добавьте два неэкспортированных поля с именами onHand
и sold. Объявите фабричную функцию с именем New для создания значений типа toy и принимайте параметры
для экспортированных полей. Затем объявите методы, возвращающие и обновляющие значения для неэкспортированных полей.

*Часть* *B:* Создайте программу, импортирующую пакет toy. Используйте функцию New для
создания значения типа toy. Затем используйте методы для установки счетчиков и отображения
значений полей этого значения toy.

.play exporting/exercise1.go
.play exporting/answer1.go
