Разделение
Композиция выходит за рамки механики встраивания типов и представляет собой нечто большее чем просто парадигму.

* Разделение

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Лучший способ воспользоваться встраиванием - через паттерн композиционного дизайна.
Это ключ к обеспечению стабильности в вашем программном обеспечении, позволяющий 
адаптироваться к ожидаемым изменениям в структуре данных и их трансформации.

** Обзор Кода

- *Пример* *1:* Структурная Композиция
- *Пример* *2:* Разделение с помощью Интерфейсов
- *Пример* *3:* Композиция Интерфейсов
- *Пример* *4:* Разделение с Композицией Интерфейсов
- *Пример* *5:* Удаление Интерфейсного Загрязнения
- *Пример* *6:* Более Точный API

.play composition/decoupling/example1.go
.play composition/decoupling/example2.go
.play composition/decoupling/example3.go
.play composition/decoupling/example4.go
.play composition/decoupling/example5.go
.play composition/decoupling/example6.go

** Механика Разделения

Идея состоит в том, чтобы создавать более крупные типы из более мелких
и сосредотачиваться на композиции поведения.

    type Xenia struct {
        Host    string
        Timeout time.Duration
    }

    func (*Xenia) Pull(d *Data) error {
        switch rand.Intn(10) {
        case 1, 9:
            return io.EOF
        case 5:
            return errors.New("Error reading data from Xenia")
        default:
            d.Line = "Data"
            fmt.Println("In:", d.Line)
            return nil
        }
    }

Тип Xenia представляет собой систему, из которой вам нужно извлечь данные.
Реализация не важна. Важно то, что метод Pull может быть успешным, неудачным
или не иметь данных для извлечения.

    type Pillar struct {
        Host    string
        Timeout time.Duration
    }

    func (*Pillar) Store(d *Data) error {
        fmt.Println("Out:", d.Line)
        return nil
    }

Тип Pillar представляет собой систему, в которую вам нужно сохранять данные.
Важно то, что метод Store так же может быть удачным или неудачным.

Эти два типа представляют собой первоначальный слой кода, который предоставляет
базовое поведение, необходимое для решения бизнес-проблемы извлечения данных
из Xenia и сохранения этих данных в Pillar.

    func Pull(x *Xenia, data []Data) (int, error) {
        for i := range data {
            if err := x.Pull(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

    func Store(p *Pillar, data []Data) (int, error) {
        for i := range data {
            if err := p.Store(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

Следующий слой кода представлен двумя функциями, Pull и Store. Они строятся
на первоначальном слое кода, принимая коллекцию значений данных для извлечения
или сохранения в соответствующих системах. Эти функции сосредотачиваются
на конкретных типах Xenia и Pillar, так как именно с ними программа должна
взаимодействовать в данный момент.

    func Copy(sys *System, batch int) error {
        data := make([]Data, batch)

        for {
            i, err := Pull(&sys.Xenia, data)
            if i > 0 {
                if _, err := Store(&sys.Pillar, data[:i]); err != nil {
                    return err
                }
            }

            if err != nil {
                return err
            }
        }
    }

Функция Copy строится поверх функций Pull и Store, чтобы перемещать все данные,
которые необходимы для каждого запуска. Если вы обратите внимание на первый параметр Copy,
это тип с именем System.

    type System struct {
        Xenia
        Pillar
    }

Исходная идея типа System заключается в том, чтобы составить систему, которая знает,
как выполнить операции Pull и Store. В данном случае компоновка способностей
Pull и Store из Xenia и Pillar.

    func main() {
        sys := System{
            Xenia: Xenia{
                Host:    "localhost:8000",
                Timeout: time.Second,
            },
            Pillar: Pillar{
                Host:    "localhost:9000",
                Timeout: time.Second,
            },
        }

        if err := Copy(&sys, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Наконец, функция main может быть написана для создания Xenia и Pillar
внутри композиции System. Затем System можно передать в функцию Copy
и начать передачу данных между двумя подсистемами.

С этим кодом у нас теперь есть первый черновик конкретного решения для конкретной
проблемы.

** Разделение с помощью Интерфейсов

Следующий шаг - понять, что может измениться в программе. В данном случае - что
может измениться, так это сами подсистемы. Сегодня это Xenia и Pillar, завтра может
быть Alice и Bob. Зная это, вы хотите защитить вашу реализацию от этих изменений. 
Для этого вы хотите заменить конкретные функции полиморфными.

    func Pull(p Puller, data []Data) (int, error) {
        for i := range data {
            if err := p.Pull(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

    func Store(s Storer, data []Data) (int, error) {
        for i := range data {
            if err := s.Store(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

На данный момент функция Pull принимает значение Xenia, а функция Store - значение
Pillar. В конце концов, важно не то, чтобы ваша реализация работала с Xenia и Pillar, 
важно чтобы конкретное значение умело выполнить действия Pull и Store.
Вы можете изменить эти конкретные функции на полиморфные, запрашивая данные на основе того, 
что они могут делать, а не на основе того, что они из себя представляют.

    type Puller interface {
        Pull(d *Data) error
    }

    type Storer interface {
        Store(d *Data) error
    }

Эти два интерфейса описывают, что должны делать конкретные данные,
и именно они заменяются в объявлении функций Pull и Store. Теперь
эти функции полиморфны. Когда Alice и Bob объявлены и реализованы как Puller
и Storer, их можно передать в эти функции.

Мы еще не закончили. Функция Copy также должна быть полиморфной.

    func Copy(ps PullStorer, batch int) error {
        data := make([]Data, batch)

        for {
            i, err := Pull(ps, data)
            if i > 0 {
                if _, err := Store(ps, data[:i]); err != nil {
                    return err
                }
            }

            if err != nil {
                return err
            }
        }
    }

Функция Copy больше не ожидает значение System, а любое конкретное значение,
знающее, как выполнить действия Pull, и Store.

    type PullStorer interface {
        Puller
        Storer
    }

Интерфейс PullStorer объявлен с использованием композиции. Он состоит
из интерфейсов Puller и Storer. Мы движемся в сторону композиции более крупных интерфейсов
из более мелких.

Обратите внимание, как переменная PullStorer теперь передается в функции Pull и Store.
Как это возможно, когда информация о типе различна?

    // func Pull(p Puller, data []Data) (int, error) {
    i, err := Pull(ps, data)

    // func Store(s Storer, data []Data) (int, error) {
    if _, err := Store(ps, data[:i]); err != nil {

Всегда нужно помнить, что вы никогда не передаете по программе значение интерфейса,
поскольку они не существуют и не несут в себе значения. Вы можете передать только конкретные данные.
Поэтому конкретное значение, хранящееся внутри переменной интерфейса ps, передаётся
в функции Pull и Store. Верно ли, что конкретное значение, хранящееся внутри ps, должно
знать, как выполнить действия Pull и Store?

.image /tour/rus/static/img/comp1.png

Поскольку System составлен из Xenia и Pillar, то System реализует интерфейс PullStorer.
С этими изменениями вы можете создавать новые конкретные типы, реализующие
интерфейс PullStorer.

    type System1 struct {
        Xenia
        Pillar
    }

    type System2 struct {
        Alice
        Bob
    }

    type System3 struct {
        Xenia
        Bob
    }

    type System4 struct {
        Alice
        Pillar
    }

Думая об этом подробнее, объявление различных типов System для всех возможных
комбинаций не является реалистичным. Это будет работать, но управление этим будет
настоящим кошмаром, поэтому нам нужно решение получше.

** Композиция Интерфейсов

Что, если бы вы решили составить свой конкретный тип из двух типов интерфейсов?

    type System struct {
        Puller
        Storer
    }

Это интересное решение. Это позволило бы приложению принять конкретные Puller 
или Storer при запуске приложения.

    func main() {
        sys := System{
            Puller: &Xenia{
                Host:    "localhost:8000",
                Timeout: time.Second,
            },
            Storer: &Pillar{
                Host:    "localhost:9000",
                Timeout: time.Second,
            },
        }

        if err := Copy(&sys, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Этот тип системы реализует интерфейс PullStorer для всех возможных
комбинаций конкретных типов.

.image /tour/rus/static/img/comp2.png

С этим изменением приложение полностью отделено от изменений в новой системе,
которая может появиться со временем.

** Обзор Точности

Вопрос, который следует задать, — дают ли нам полиморфные функции, максимальный
уровень точности? Этот этап инженерного процесса нельзя пропустить. Ответ — нет,
можно внести два изменения.

    func Copy(sys *System, batch int) error {

Функции Copy больше не нужно быть полиморфной, поскольку будет только один тип System.
Интерфейсный тип PullStorer можно удалить из программы. Помните, что вы переместили
полиморфизм внутрь типа, когда использовали композицию с интерфейсными типами.

    func Copy(p Puller, s Storer, batch int) error {

Еще одно изменение, которое можно внести в функцию Copy. Это изменение делает функцию
более точной и снова полиморфной. Теперь функция запрашивает ровно то, что ей нужно,
основываясь на том, что может делать конкретные данные.

.image /tour/rus/static/img/comp3.png

С этим изменением тип System можно также удалить из программы.

.image /tour/rus/static/img/comp3.png

С этим изменением тип System также можно удалить из программы.

    func main() {
        x := Xenia{
            Host:    "localhost:8000",
            Timeout: time.Second,
        }

        p := Pillar{
            Host:    "localhost:9000",
            Timeout: time.Second,
        }

        if err := Copy(&x, &p, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Убрав типы PullStorer и System, программа упрощается. Функция main может
сосредоточиться на создании конкретных значений Puller и Storer, необходимых
для перемещения данных. Система типов и API становятся более точными.
Эта идея точности происходит от Эдсгера В. Дейкстры:

"Целью абстракции не является быть неопределённой, а создать новый семантический
уровень, на котором можно быть абсолютно точным." - Эдсгер В. Дейкстра

** Примечания

- Это гораздо больше, чем механика встраивания типов.
- Объявляйте типы и реализуйте рабочие процессы с учетом композиции.
- Сначала поймите проблему, которую вы пытаетесь решить. Для этого вам потребуется понять данные.
- Цель — минимизировать каскадные изменения в вашем программном обеспечении.
- Интерфейсы обеспечивают самую высокую форму композиции.
- Группируйте типы не общим ДНК, а общим поведением.
- Все могут работать вместе, когда мы сосредотачиваемся на том, что мы делаем, а не на том, что мы из себя представляем.

** Цитаты

"Хороший API не только легко использовать - его ещё сложно использовать неправильно." - Джон Бенгтсон

"Встраивать просто. Гораздо сложнее разбивать большие существующие интерфейсы, как только они укоренились. Держите интерфейсы маленькими." - Джон Бенгтсон

"Не проектируйте с интерфейсами, а обнаруживайте их." - Роб Пайк

"Дублирование гораздо дешевле неправильной абстракции." - Санди Мец

** Рекомендации по проектированию

Изучите [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#interface-and-composition-design][рекомендации по проектированию]] для композиции.

** Дополнительное чтение

- [[https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and][Повторяйтесь, делайте больше одной вещи и переписывайте всё]] - Теф
- [[https://golang.org/doc/effective_go.html#embedding][Встраивание]]
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Методы, интерфейсы и встраивание]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2015/09/composition-with-go.html][Композиция в Go]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2016/10/reducing-type-hierarchies.html][Сокращение иерархий типов]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2016/10/avoid-interface-pollution.html][Избегайте загрязнения интерфейсами]] - Уильям Кеннеди

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений.  Здесь представлен возможный вариант решения.

** Упражнение 1

Используя шаблон, объявите набор конкретных типов, реализующих набор предопределенных
интерфейсных типов. Затем создайте значения этих типов и используйте их для выполнения
набора предопределенных задач.

.play composition/decoupling/exercise1.go
.play composition/decoupling/answer1.go
