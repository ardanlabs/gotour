Встраивание
Встраивание типов является финальным механизмом обмена и повторного использования состояния и поведения типов.

* Встраивание

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Встраивание типов является финальным механизмом обмена и повторного использования состояния и поведения типов. 
С помощью механизма продвижения внутреннего типа можно, через ссылку внешнего типа, напрямую обращаться 
к полям и методам внутреннего типа.

** Обзор кода

- *Пример* *1:* Объявление полей
- *Пример* *2:* Встраивание типов
- *Пример* *3:* Встроенные типы и интерфейсы
- *Пример* *4:* Реализации интерфейсов внешнего и внутреннего типов
	
.play embedding/example1.go
.play embedding/example2.go
.play embedding/example3.go
.play embedding/example4.go

** Механика встраивания

Первый пример не демонстрирует встраивание, а только объявление двух структурных типов
работающих вместе как поле одного типа в рамках другого.

    type user struct {
        name  string
        email string
    }

    type admin struct {
        person user        // НЕ встраивание
        level  string
    }

А вот это уже встраивание.

    type user struct {
        name  string
        email string
    }

    type admin struct {
        user               // Встраивание семантики значения
        level  string
    }

Поле person удалено, и осталось только имя типа. Вы также можете встроить тип,
используя семантику указателя.

    type user struct {
        name  string
        email string
    }

    type admin struct {
        *user              // Встраивание семантики указателя
        level  string
    }

В этом случае встраивается указатель типа. В обоих случаях доступ к встроенному значению
осуществляется через имя типа.

Лучший способ думать о встраивании - это рассматривать тип user как внутренний тип,
а admin как внешний тип. Именно в этой внутренней/внешней связи типов кроется магия,
потому что с встраиванием всё, что связано с внутренним типом (как поля, так и методы),
может быть продвинуто к внешнему типу.

    type user struct {
        name  string
        email string
    }

    func (u *user) notify() {
        fmt.Printf("Sending user email To %s<%s>\n",
            u.name,
            u.email)
    }

    type admin struct {
        *user              // Встраивание семантики указателя
        level  string
    }

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        ad.user.notify()
        ad.notify() // Продвижение внешнего типа
    }

Вывод:

    Sending user email To john smith<john@yahoo.com>
    Sending user email To john smith<john@yahoo.com>

Как только вы добавите метод с именем notify для типа user, а затем небольшую основную функцию
вы увидите, что вывод одинаков, независимо от того, вызываете ли вы метод notify напрямую
через указатель внутреннего значения или через значение внешнего типа. Метод notify, объявленный
для типа user, доступен напрямую через значение типа admin.

Хотя это похоже на наследование, будьте осторожны. Речь идёт не о повторном использовании состояния,
а о продвижении поведения.

    type notifier interface {
        notify()
    }

    func sendNotification(n notifier) {
        n.notify()
    }

Теперь добавьте интерфейс и полиморфную функцию, которая принимает любое конкретное значение,
реализующее полный набор методов поведения, определенных интерфейсом notifier. Который просто
содержит метод с именем notify.

Благодаря встраиванию и продвижению, значения типа admin теперь реализуют интерфейс notifier.

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        sendNotification(&ad)
    }

Вывод:

    Sending user email To john smith<john@yahoo.com>

Вы можете передать адрес значения admin в полиморфную функцию, поскольку встраивание
продвигает поведение notify вверх к типу admin.

    type admin struct {
        *user  // Встраивание семантики указателя
        level  string
    }

    func (a *admin) notify() {
        fmt.Printf("Sending admin Email To %s<%s>\n",
            a.name,
            a.email)
    }

Когда внешний тип реализует метод, уже реализованный внутренним типом,
продвижение не происходит.

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        sendNotification(&ad)
    }

Вывод:
    
    Sending admin email To john smith<john@yahoo.com>

Вы видите, что теперь выполняется метод внешнего типа.

** Заметки

- Встраивание типов позволяют нам обмениваться состоянием или поведением между типами.
- Внутренний тип никогда не теряется.
- Это не наследование.
- Благодаря продвижению, поля и методы внутреннего типа могут быть доступны через внешний тип.
- Внешний тип может переопределить поведение внутреннего типа.

** Дополнительное чтение

- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Методы, интерфейсы и встроенные типы в Go]] - Уильям Кеннеди    
- [[https://rakyll.org/typesystem/][Встраивание не является наследованием]] - JBD  

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1

Отредактируйте код из шаблона. Добавьте новый тип CachingFeed, который встраивает Feed
и переопределяет метод Fetch.

.play embedding/exercise1.go
.play embedding/answer1.go
