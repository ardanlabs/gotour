Карты
Карта - это структура данных, которая обеспечивает поддержку хранения и доступа к данным по ключу.

* Карты

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Карта - это структура данных, которая обеспечивает поддержку хранения и доступа к данным по ключу.
В основе карт лежат хеш-карты и системы корзин, позволяющие использовать непрерывный блок памяти.

** Обзор кода

- *Пример* *1:* Объявление, запись, чтение и удаление
- *Пример* *2:* Отсутствующие ключи
- *Пример* *3:* Ограничения ключа карты
- *Пример* *4:* Литералы карты и диапазон
- *Пример* *5:* Сортировка карты по ключу
- *Пример* *6:* Получение адреса элемента
- *Пример* *7:* Карты - ссылочные типы

.play maps/example1.go
.play maps/example2.go
.play maps/example3.go
.play maps/example4.go
.play maps/example5.go
.play maps/example6.go
.play maps/example7.go

** Объявление и создание карт

Объявить и создать карту можно несколькими способами.

    type user struct {
        name     string
        username string
    }

    // Создать карту, установленную в нулевое значение,
    // которая может хранить значения типа `user` на основе ключа типа string.
    // Попытка использовать эту карту приведет к ошибке времени выполнения (панике).
    var users map[string]user

    // Создать карту, инициализированную с помощью функции `make`,
    // которая может хранить значения типа `user` на основе ключа типа string.
    users := make(map[string]user)

    // Создать карту, инициализированную пустым литералом,
    // которая может хранить значения типа `user` на основе ключа типа string.
    users := map[string]user{}

Карта, установленная в своё нулевое значение, не может быть использована
и приведет к аварийному завершению программы. Использование встроенной функции `make`
и литеральной конструкции создает карту, готовую к использованию.

    func main() {
        users := make(map[string]user)

        users["Roy"] = user{"Rob", "Roy"}
        users["Ford"] = user{"Henry", "Ford"}
        users["Mouse"] = user{"Mickey", "Mouse"}
        users["Jackson"] = user{"Michael", "Jackson"}

        for key, value := range users {
            fmt.Println(key, value)
        }
    }

Вывод:

    Roy {Rob Roy}
    Ford {Henry Ford}
    Mouse {Mickey Mouse}
    Jackson {Michael Jackson}

Если встроенная функция make используется для создания карты, оператор присваивания
может использоваться для добавления и изменения значений в карте. Порядок возврата ключей/значений
при итерировании по карте не определён спецификацией и зависит от компилятора.

    func main() {
        users := map[string]user{
            "Roy":     {"Rob", "Roy"},
            "Ford":    {"Henry", "Ford"},
            "Mouse":   {"Mickey", "Mouse"},
            "Jackson": {"Michael", "Jackson"},
        }

        for key, value := range users {
            fmt.Println(key, value)
        }
    }

Вывод:

    Ford {Henry Ford}
    Jackson {Michael Jackson}
    Roy {Rob Roy}
    Mouse {Mickey Mouse}

В этом случае результат был возвращён в порядке отличным от объявления при инициализации.
Текущий алгоритм для версии 1.16 вернет результаты в случайном порядке, как только
количество значений достигнет определенного предела. Опять же, это реализация компилятора,
которая может измениться. На неё нельзя полагаться.

** Поиск и удаление ключей карты

Для данных хранящихся в карте, извлечение значений выполняется поиском по ключу.

    user1, exists1 := users["Bill"]
    user2, exists2 := users["Ford"]

    fmt.Println("Bill:", exists1, user1)
    fmt.Println("Ford:", exists2, user2)

Вывод:

    Bill: false { }
    Ford: true {Henry Ford}

Для поиска по ключу, используются квадратные скобки следующие за переменной карты.
Операция поиска по карте может вернуть два значения: значение и булево значение, указывающее
нашелось значение или нет. Если вам этого не нужно знать, вы можете опустить переменную "exists".

Когда ключ в карте не найден, операция возвращает нулевое значение типа карты.
В этом можно убедиться при поиске ключа "Bill". Не используйте нулевое значение для определения того,
существует ли ключ в карте или нет, поскольку нулевое значение может быть допустимым и
фактически хранится в карте для данного ключа.

    delete(users, "Roy")

Существует встроенная функция  delete, которая позволяет удалять данные
из карты на основе ключа.

** Ограничения ключа карты

Не все типы могут использоваться в качестве ключа.

    type slice []user
    Users := make(map[slice]user)

Ошибка компиляции:

    invalid map key type users

Срез является хорошим примером типа, который нельзя использовать в качестве ключа.
В качестве ключа могут быть использованы только значения, которые могут пройти
через хеш-функцию. Удобный способ для определения типов, которые могут быть ключом -
ответить на вопрос, можно ли использовать тип в операции сравнения.
Вы не можете сравнивать два значения среза.

** Заметки

- Карты используются для хранения и извлечения пар ключ/значение.
- Чтение отсутствующего ключа возвращает нулевое значение для типа значения карты.
- Итерация по карте всегда происходит в случайном порядке.
- Ключ карты должен быть значением, которое можно сравнивать.
- Элементы в карте не могут быть адресованы.
- Карты - это ссылочный тип.

** Ссылки

- [[https://blog.golang.org/go-maps-in-action][Карты Go в действии]] - Эндрю Герранд
- [[https://www.ardanlabs.com/blog/2013/12/macro-view-of-map-internals-in-go.html][Макро-вид на карты в Go]] - Уильям Кеннеди
- [[https://www.youtube.com/watch?v=Tl7mi9QmLns][Внутренняя реализация карт]] - Кит Рэндалл
- [[https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics][Как среда выполнения Go эффективно реализует карты (без дженериков)]] - Дейв Чени

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1

Объявите и создайте карту целочисленных значений с ключом в виде строки. Заполните карту
пятью значениями и выполните итерацию по карте для отображения пар ключ/значение.

.play maps/exercise1.go
.play maps/answer1.go
