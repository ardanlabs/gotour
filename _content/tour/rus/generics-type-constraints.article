Тип как Ограничение
Это новый для Go концепт, когда ограничение основано на наборе конкретных типов.

* Дженерики - Тип как Ограничение

Это новый для Go концепт, когда ограничение основано на наборе конкретных типов.
Работает только с дженериками

** Видео

Посмотрите рассказ про Дженерики ниже, который проведет вас через все 
примеры секции Тура.

.html generics-video.html

** Обзор Кода

- *Пример* *1*: Ограничение, основанное на типе
- *Пример* *2*: Встроенное ограничение типов "comparable"
- *Пример* *3*: Комбинация ограничений на типе и поведении

.play generics/type-constraints/example1.go
.play generics/type-constraints/example2.go
.play generics/type-constraints/example3.go

** Объяснение

Дженерики создают новый тип ограничений, которые не могут быть описаны объявлением
набора методов.

    func Add[T ???](v1 T, v2 T) T {
        return v1 + v2
    }

Эта функция ожидает два значения некоторого типа Т, складывает их и возвращает назад их сумму. 
Эта проблема интересна тем, что нам необходимо дать понять компилятору, что эта функция
может вызываться только для значений, поддерживающих операцию сложения. На данный момент, у нас нет 
механизма для определения такого рода ограничений.

Решением стало продолжить использовать интерфейсы для описания ограничений, добавив при
этом в них кое-что новое.

    type addOnly interface {
        string | int | int8 | int16 | int32 | int64 | float64
    }

Вы можете описать интерфейс, определяющий набор типов, которые станут ограничением и
использовать этот интерфейс в заголовке функции.

    func Add[T addOnly](v1 T, v2 T) T {
        return v1 + v2
    }

Теперь компилятор может проверить, что набор типов соответствует операциям, которые функция 
должна выполнять над значениями этих типов. Когда интерфейс использует встроенные типы, 
его можно использовать в разных пакетах. Когда список типов представляет собой 
пользовательские типы из пакета, вы должны помнить, что эти дженерик функции привязаны к этому пакету.

Интерфейсы, содержащие в себе набор типов, не могут быть использованы в традиционных
полиморфных функциях. Эта особенность ощущается выбивающейся из философии Go, так как
это нововведение не является ортогональным другим особенностям языка. 

Одна из идей это заранее объявить идентификаторы для ограничений, связанных с общими операциями.

    func index[T comparable](list []T, find T) int {
        for i, v := range list {
            if v == find {
                return i
            }
        }
        
        return -1
    }

Ограничение comparable является встроенным и ограничивает множество типов до тех типов,
которые могут быть использованы в операции сравнения. В данном примере, обе переменные v и find 
имеют одинаковый тип и могут быть сравнены между собой. Это встроенное ограничение является отражением
идеи о том, что стандартная библиотека могла бы предоставлять набор наиболее общих ограничений.

Объявления интерфейсов могут содержать как наборы типов, так и методов.

    type matcher[T any] interface {
        type person, food
        match(v T) bool
    }
        
    func match[T matcher[T]](list []T, find T) int {
        for i, v := range list {
            if v.match(find) {
                return i
            }
        }
        
        return -1
    }

Выше объявлен интерфейс, в котором T - тип значения, передаваемого в метод match. Также
интерфейс ограничивает возможные типы до заданных пользователем типов person и food.

Заметим, что нет очевидной причины для использования дженериков в функции match, 
ведь метод match является достаточным ограничением, в то время как ограничение возможных типов
никак не используется. Так что в реальной жизни, эта функция скорее всего была бы традиционной 
полиморфной функцией. Несмотря на это, полезно помнить и о такой возможности.

В качестве примечания, не уверен что эта функциональность необходима или полезна. Но это что-то,
что сообщество языка должно определить со временем.

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1

С использованием дженериков реализуйте функцию copyfy. Функция должна копировать переданный срез и
быть использована только для переменных с типом string или int. 

.play generics/type-constraints/exercise1.go 
.play generics/type-constraints/answer1.go
