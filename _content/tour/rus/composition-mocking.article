Мокирование
Поскольку компилятор может выполнять статический анализ кода, чтобы определить, реализует ли конкретное значение заданный интерфейс, разработчику, объявляющему конкретный тип, не нужно предоставлять данный интерфейсы.

* Мокирование

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Лучший способ использования встраивания - через паттерн композиционного дизайна. Идея заключается в том, чтобы создавать более крупные типы из более мелких и сосредотачиваться на композиции поведения.

** Обзор Кода

- *Пример* *1:* Мокирование

.play composition/mocking/example1.go

** Владение Интерфейсом

Одной из вещей, отличающих Go от других языков, является идея конвенции перед конфигурацией.
Это действительно проявляется в том, как Go обрабатывает соответствие интерфейсов. Поскольку
компилятор может выполнять статический анализ кода, чтобы определить, реализует ли конкретное
значение заданный интерфейс, разработчику, объявляющему конкретный тип, не нужно предоставлять
данный интерфейсы.

    package pubsub

    type PubSub struct {
        host string
    }

    func New(host string) *PubSub {
        return &PubSub{
            host: host,
        }
    }

    func (ps *PubSub) Publish(key string, v interface{}) error {
        // ПРЕДСТАВЬТЕ, ЧТО ЕСТЬ КОНКРЕТНАЯ РЕАЛИЗАЦИЯ.
        return nil
    }

    func (ps *PubSub) Subscribe(key string) error {
        // ПРЕДСТАВЬТЕ, ЧТО ЕСТЬ КОНКРЕТНАЯ РЕАЛИЗАЦИЯ.
        return nil
    }

Вы только что реализовали новый API, предоставляющий конкретную реализацию для публикации и подписки.
Здесь не предоставляются интерфейсы, потому что для этого API в них нет необходимости. Это единственная
конкретная реализация.

Что если разработчик приложения, который хочет использовать этот новый API, нуждается в интерфейсе,
потому что ему нужно мокировать эту реализацию во время тестов? В Go этот разработчик может объявить
интерфейс, и компилятор сможет определить соответствие.

    package main

    type publisher interface {
        Publish(key string, v interface{}) error
        Subscribe(key string) error
    }

    type mock struct{}

    func (m *mock) Publish(key string, v interface{}) error {
        // ДОБАВЬТЕ СВОЙ МОК ДЛЯ ВЫЗОВА ПУБЛИКАЦИИ.
        return nil
    }

    func (m *mock) Subscribe(key string) error {
        // ДОБАВЬТЕ СВОЙ МОК ДЛЯ ВЫЗОВА ПОДПИСКИ.
        return nil
    }

Этот код в основном пакете объявляет интерфейс. Этот интерфейс представляет API,
которым приложение пользуется из пакета pubsub. Разработчик реализовал свою собственную
реализацию pubsub для тестирования. Ключевое здесь заключается в том, что разработчик
приложения не использует непосредственно конкретную реализацию, и таким образом отделяет
свой код с помощью свое го собственного интерфейса.

    func main() {
        pubs := []publisher{
            pubsub.New("localhost"),
            &mock{},
        }

        for _, p := range pubs {
            p.Publish("key", "value")
            p.Subscribe("key")
        }
    }

Для примера функция main создает коллекцию, которая инициализирована как настоящей,
так и моковой реализацией pubsub. Это позволяет использовать интерфейс publisher.
Затем выполняется цикл для демонстрации того, что код приложения абстрагирован от
какой-либо конкретной реализации.
