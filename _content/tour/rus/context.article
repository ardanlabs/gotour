Пакет Context
Пакет context определяет тип `Context`, который включает работу со сроками (дедайнами), сигналами отмены и другими значениями, имеющими смысл в рамках запросов API и между процессами.

* Пакет Context

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Пакет `context` определяет тип `Context`, который переносит сроки, отмены
сигналы и другие значения, связанные с запросами, через границы API и между процессами.

** Обзор кода

Значения Context предназначены для работы с данными из области действия запросов передающихся через программы в распределенных системах.

- *Пример* *1:* Хранение/Извлечение значений
- *Пример* *2:* WithCancel
- *Пример* *3:* WithDeadline
- *Пример* *4:* WithTimeout
- *Пример* *5:* Запрос/Ответ
- *Пример* *6:* Отмена

.play context/example1.go
.play context/example2.go
.play context/example3.go
.play context/example4.go
.play context/example5.go
.play context/example6.go

** Семантика контекста

В языке программирования Go есть встроенное ключевое слово `go` для создания горутин, но
не имеет ключевых слов или прямой поддержки для их завершения. В реальных сервисах,
возможность тайм-аута и завершения горутин критически важна для поддержания работоспособности
и функционирования сервиса. Ни один запрос или задача не могут выполняться вечно, поэтому
определение и управление задержками - обязанность каждого программиста.

Решение этой проблемы, предложенное командой Go, является пакет `Context`.
Он был написан и представлен Самиром Аджмани в 2014 году на конференции Gotham Go. 
Он также написал статью в блоге Go.

Слайды: [[https://talks.golang.org/2014/gotham-context.slide#1][https://talks.golang.org/2014/gotham-context.slide#1]]

Заметка в блоге: [[https://blog.golang.org/context][https://blog.golang.org/context]].

Благодаря этим публикациям и беседам с Самиром на протяжении многих лет,
сформировался набор семантики.

*Входящие* *запросы* *на* *сервер* *должны* *создавать* *Context*.

Время для создания контекста - всегда как можно раньше в процессе обработки
запроса или задачи. Работа с контекстом на ранних этапах разработки заставит вас
планировать API так, чтобы в качестве первого параметра принимался контекст. Даже если вы не уверены на 100%, 
что функции нужен Context, проще удалить его из нескольких
функций, чем пытаться добавить позже.

    75 // Handle is our mechanism for mounting Handlers for a given HTTP verb and path
    76 // pair, this makes for really easy, convenient routing.
    77 func (a *App) Handle(verb, path string, handler Handler, mw ...Middleware) {
    ...
    85     // The function to execute for each request.
    86     h := func(w http.ResponseWriter, r *http.Request, params map[string]string) {
    87         ctx, span := trace.StartSpan(r.Context(), "internal.platform.web")
    88         defer span.End()
    ...
    106    // Add this handler for the specified verb and route.
    107    a.TreeMux.Handle(verb, path, h)
    108 }

Вы видите код, взятый из `service` проекта, который мы разбираем на курсах в Ardan Labs. В строке 86 определена
функцию-обработчик, которая привязывается ко всем маршрутам, как показано в строке 107. Именно эта
функция начинает обрабатывать все входящие запросы. В строке 87 создается `span`
для запроса, который принимает в качестве первого параметра `Context`. Это первый
раз когда в коде сервиса требуется `Context`.

Заметьте, что значение `http.Request` уже содержит `Context`. Это
было добавлено в версии 1.7 Go. Это означает, что коду не нужно вручную создавать
контекст верхнего уровня. Если бы мы использовали версию Go 1.8, то вам пришлось бы
создать пустой `Context` перед вызовом `StartSpan` с помощью функции `context.Background`.

    https://golang.org/pkg/context/#Background

    87         ctx := context.Background()
    88         ctx, span := trace.StartSpan(ctx, "internal.platform.web")
    89         defer span.End()

Вот как должен выглядеть код в версии Go 1.8. Как описано
в документации к пакету,

`Background` возвращает не нулевой, пустой `Context`. Он никогда не отменяется, не имеет значений,
и не имеет срока выполнения. Обычно он используется в главной функции, при инициализации,
и тестах, а также в качестве контекста верхнего уровня для входящих запросов.

Идиома в Go - использовать имя переменной `ctx` для всех значений `Context`. Поскольку
`Context` - это интерфейс, семантика указателей не должна использоваться.

    https://golang.org/pkg/context/#Context

    type Context interface {
        Deadline() (deadline time.Time, ok bool)
        Done() <-chan struct{}
        Err() error
        Value(key interface{}) interface{}
    }

Каждая функция, принимающая контекст, должна получить свою собственную копию значения интерфейса.

*Исходящие* *вызовы* *к* *серверам* *должны* *принимать*  *контекст*.

Идея такой семантики заключается в том, что вызовы более высокого уровня должны сообщать вызовам более низкого уровня
как долго они готовы ждать. Отличным примером этого является пакет `http`
и изменениями версии 1.7, внесенными в метод `Do` для соблюдения тайм-аута запроса.

    01 package main
    02 
    03 import (
    04     "context"
    05     "io"
    06     "log"
    07     "net/http"
    08     "os"
    09     "time"
    10 )
    11 
    12 func main() {
    13
    14     // Create a new request.
    15     req, err := http.NewRequest("GET", "https://www.ardanlabs.com/blog/post/index.xml", nil)
    16     if err != nil {
    17         log.Println("ERROR:", err)
    18         return
    19     }
    20
    21     // Create a context with a timeout of 50 milliseconds.
    22     ctx, cancel := context.WithTimeout(req.Context(), 50*time.Millisecond)
    23     defer cancel()
    24
    25     // Bind the new context into the request.
    26     req = req.WithContext(ctx)
    27
    28     // Make the web call and return any error. Do will handle the
    29     // context level timeout.
    30     resp, err := http.DefaultClient.Do(req)
    31     if err != nil {
    32       log.Println("ERROR:", err)
    33       return
    34     }
    35
    36     // Close the response body on the return.
    37     defer resp.Body.Close()
    38
    39     // Write the response to stdout.
    40     io.Copy(os.Stdout, resp.Body)
    41 }

Эта программа отправляет запрос на rss-ленту блога Ardan с тайм-аутом в 50
миллисекунд. В строках 15-19 запрос создается для выполнения `GET`-вызова по
предоставленному `URL`. В строках 22-23 создается контекст с таймаутом 50 миллисекунд. A
Новый `API`, добавленный к значению`Request` еще в версии 1.7, - это метод `WithContext`.
Этот метод позволяет обновлять поле `Context` значения `Request`. В строке 26,
именно это и делает программа.

В строке 30 выполняется фактический запрос с помощью метода `Do` из значения http пакета
`DefaultClient`. Метод `Do` будет соблюдать значение тайм-аута в 50 миллисекунд
которое теперь установлено внутри контекста в значении `Request`. То, что вы видите, - это
код (функция более высокого уровня), сообщающий методу `Do` (функция более низкого уровня), как долго
мы готовы ждать завершения операции.

*Не* *храните* *`Context`* *внутри* *структур*.

Вместо этого передавайте `Context` явно каждой функции, которой он нужен. По сути, любая
функция, выполняющая ввод-вывод, должна принимать значение `Context` в качестве первого параметра
и соблюдать любой таймаут или крайний срок, установленный вызывающей стороной. В случае с `Request`,
необходимо было учитывать обратную совместимость. Поэтому вместо того, чтобы менять API,
была реализован подход, продемонстрированый в последнем разделе.

Из каждого правила есть исключения. Однако в рамках данного поста и любых
API из стандартной библиотеки, которые принимают `Context`, идиома заключается в том, что первый
параметр принимает значение `Context`.

.image /tour/eng/static/img/context_figure1.png

Фрагмент представляет собой пример из пакета `net`, где первый 
параметр каждого метода это `Context`, и так же соблюдаеться идиома с переменной `ctx`.

*Цепочка* *вызовов* *функций* *должна* *распространять* *контекст*.

Это важное правило, поскольку контекст основан на запросах или действиях. Вы хотите, чтобы контекст и любые изменения, 
сделанные во время обработки запроса или действия, распространялись и соблюдались.

    23 // List returns all the existing users in the system.
    24 func (u *User) List(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    25     ctx, span := trace.StartSpan(ctx, "handlers.User.List")
    26     defer span.End()
    27
    28     users, err := user.List(ctx, u.db)
    29     if err != nil {
    30         return err
    31     }
    32
    33     return web.Respond(ctx, w, users, http.StatusOK)
    34 }

На этом фрагменте кода видно функцию-обработчик с именем `List`,
которая выполняется при запросе пользователя через `HTTP` для данной конечной точки.
Обработчик принимает контекст (Context) в качестве первого параметра,
поскольку он является частью запроса и выполняет ввод-вывод.
Как видно на строках 25, 28 и 33, тот же самый контекст (Context) передается вниз по стеку вызовов.

Новый объект контекста (Context) не создается, поскольку для этой функции не требуются изменения.
Если бы новый объект контекста (Context) верхнего уровня был создан этой функцией, 
любая существующая информация о контексте (Context) из вызова более высокого уровня,
связанного с этим запросом, была бы утеряна. Это не то, что вам нужно.

    33 // List retrieves a list of existing users from the database.
    34 func List(ctx context.Context, db *sqlx.DB) ([]User, error) {
    35     ctx, span := trace.StartSpan(ctx, "internal.user.List")
    36     defer span.End()
    37
    38     users := []User{}
    39     const q = `SELECT * FROM users`
    40
    41     if err := db.SelectContext(ctx, &users, q); err != nil {
    42         return nil, errors.Wrap(err, "selecting users")
    43     }
    44
    45     return users, nil
    46 }

Посмотрите объявление метода `List`, который вызывается в строке 28. И снова этот метод принимает `Context` в качестве первого параметра. 
Затем это значение снова передается вниз по стеку вызовов в строках 35 и 41. Поскольку строка 41 является вызовом базы данных, 
эта функция должна уважать любую информацию о тайм-ауте, установленную в контексте предыдущим пользователем.

*Получает* *контекст* *с* *помощью* *WithCancel*, *WithDeadline*, *WithTimeout* *или* *WithValue*.

Поскольку любая функция может добавлять/изменять Контекст для своих нужд, и эти изменения не должны влиять на ранее 
вызванную функцию, Контекст использует семантику значения. Это означает, что любое изменение значения контекста создает 
новое значение контекста, которое затем передается дальше.

    01 func main() {
    02
    03     // Set a duration.
    04     duration := 150 * time.Millisecond
    05
    06     // Create a context that is both manually cancellable and will signal
    07     // cancel at the specified duration.
    08     ctx, cancel := context.WithTimeout(context.Background(), duration)
    09     defer cancel()
    10
    11     // Create a channel to receive a signal that work is done.
    12     ch := make(chan data, 1)
    13
    14     // Ask the goroutine to do some work for us.
    15     go func() {
    16
    17         // Simulate work.
    18         time.Sleep(50 * time.Millisecond)
    19
    20         // Report the work is done.
    21         ch <- data{"123"}
    22     }()
    23
    24     // Wait for the work to finish. If it takes too long, move on.
    25     select {
    26         case d := <-ch:
    27             fmt.Println("work complete", d)
    28
    29         case <-ctx.Done():
    30             fmt.Println("work cancelled")
    31     }
    32 }

Это небольшая программа, демонстрирующая семантическую природу значения функции `WithTimeout`. 
В строке 08 вызов `WithTimeout` возвращает новое значение `Context` и функцию отмены. Поскольку вызов функции требует 
родительского контекста, код использует функцию `Background` для создания пустого контекста верхнего уровня. 
В этом и заключается назначение функции Background.

В дальнейшем используется значение `Context`, созданное функцией `WithTimeout`. Если каким-либо последующим функциям в 
цепочке вызовов требуется определенный таймаут или крайний срок, они также должны использовать соответствующую функцию `With` 
и это новое значение Context в качестве родительского.

Крайне важно, чтобы любая функция отмены, возвращаемая функцией `With`, была выполнена до возврата функции. 
Поэтому ключевое слово defer следует использовать сразу после вызова `With`, как показано в строке 26. 
Невыполнение этого требования приведет к утечке памяти в вашей программе.

*Когда* *контекст* *удаляется*, *все* *производные* *от* *него* *контексты* *также* *удаляются*.

Использование семантики значений для `Context` API означает, что каждому новому значению `Context` присваивается все, 
что есть у родительского `Context`, плюс все новые модификации. Это означает, что если родительский Контекст удаляется, 
то удаляются и все дочерние Контексты, производные от этого родительского Контекста.

    01 func main() {
    02
    03     // Create a Context that can be cancelled.
    04     ctx, cancel := context.WithCancel(context.Background())
    05     defer cancel()
    06
    07     // Use the Waitgroup for orchestration.
    08     var wg sync.WaitGroup
    09     wg.Add(10)
    10
    11     // Create ten goroutines that will derive a Context from
    12     // the one created above.
    13     for i := 0; i < 10; i++ {
    14         go func(id int) {
    15             defer wg.Done()
    16
    17             // Derive a new Context for this goroutine from the Context
    18             // owned by the main function.
    19             ctx := context.WithValue(ctx, key, id)
    20
    21             // Wait until the Context is cancelled.
    22             <-ctx.Done()
    23             fmt.Println("Cancelled:", id)
    24         }(i)
    25     }
    26
    27     // Cancel the Context and any derived Context's as well.
    28     cancel()
    29     wg.Wait()
    30 }

Эта программа создает значение Context, которое может быть удалено в строке 04. Затем в строках 13-25 создаются десять горутин. 
Каждая горутина помещает свой уникальный ID в свое собственное значение `Context` в строке 19. Вызову `WithValue` передается 
значение `Context` главной функции в качестве родительского. Затем, в строке 22, каждая горутина ждет, пока ее `Context` 
не будет очищен.

В строке 28 главная горутина очищает свое значение `Context`, а затем в строке 29 ждет, пока все десять горутин получат сигнал,
прежде чем закрыть программу. После вызова функции `cancel` все десять горутин в строке 41 будут разблокированы и выведут
сообщение о том, что они были отменены. Один вызов отменяет их все.

Это также показывает, что один и тот же контекст может быть передан функциям, выполняющимся в разных горутинах. 
Один контекст безопасен для одновременного использования несколькими горутинами.

Не передавайте контекст `nil`, даже если функция это позволяет. Передавайте контекст `TODO`, если вы не уверены, 
какой контекст использовать. Одна из моих любимых частей пакета `Context` - функция `TODO`. 
Я твердо верю, что программист всегда пишет код. Это ничем не отличается от писателя, который набрасывает варианты статьи. 
Вы никогда не знаете всего, пока пишете код, но, надеюсь, вы знаете достаточно, чтобы двигаться вперед. 
В конце концов, вы постоянно учитесь, переделываете и тестируете по ходу работы.

Было много случаев, когда я знал, что мне нужен контекст, но не был уверен, откуда он возьмется. 
Я знал, что не отвечаю за создание контекста верхнего уровня, поэтому об использовании функции `Background` не могло быть и речи. 
Мне нужен был временный контекст верхнего уровня, пока я не узнаю, откуда возьмется настоящий контекст. 
Именно в таких случаях следует использовать функцию `TODO`, а не функцию `Background`.

*Используйте* *значения* *с* *Context* *только* *в* *области* *действия* *запроса* *данных*.

Не используйте Context для передачи необязательных параметров в функции. Это, возможно, самая важная семантика из всех. 
Не используйте значение Context для передачи данных в функцию, если эти данные требуются функции для корректного выполнения кода. 
Другими словами, функция должна иметь возможность выполнять свою логику с пустым значением Context. 
В тех случаях, когда функция требует наличия информации в контексте, при ее отсутствии программа должна завершить работу и 
подать сигнал о закрытии приложения.

Классическим примером неправильной передачи данных при вызове функции с использованием Context являются соединения с базами данных. 
Как правило, при передаче данных через программу следует придерживаться следующего порядка.

Передавайте данные как параметр функции Это самый очевидный способ перемещения данных в программу, не скрывая их.

Передача данных через приемник Если функция, которой нужны данные, не может изменить сигнатуру, используйте метод и передавайте данные через приемник.

Быстрый пример использования приемника

Классическим примером второго правила являются обработчики запросов. Поскольку функция-обработчик привязана к определенному 
объявлению, сигнатура обработчика не может быть изменена.

    23 // List returns all the existing users in the system.
    24 func (u *User) List(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    25     ctx, span := trace.StartSpan(ctx, "handlers.User.List")
    26     defer span.End()
    27
    28     users, err := user.List(ctx, u.db)
    29     if err != nil {
    30         return err
    31     }
    32
    33     return web.Respond(ctx, w, users, http.StatusOK)
    34 }

Здесь вы видите метод обработчика `List` из проекта service. Сигнатуры этих методов привязаны к тому, 
что определено веб-фреймворком, и их нельзя изменить. Однако для выполнения бизнес-вызова в строке 28 требуется 
подключение к базе данных. Этот код находит пул соединений не из передаваемого значения `Context`, а из приемника.

    15 // User represents the User API method handler set.
    16 type User struct {
    17     db            *sqlx.DB
    18     authenticator *auth.Authenticator
    19
    20 // ADD OTHER STATE LIKE THE LOGGER AND CONFIG HERE.
    21 }

Вы можете видеть объявление типа приемника. Все, что нужно обработчику запроса, определено в виде полей. 
Это позволяет не скрывать информацию и запускать бизнес-уровень с пустым значением Context.



    14 // API constructs an http.Handler with all application routes defined.
    15 func API(shutdown chan os.Signal, log *log.Logger, db *sqlx.DB, authenticator *auth.Authenticator) http.Handler {
    16
    ...
    26     // Register user management and authentication endpoints.
    27     u := User{
    28         db:            db,
    29         authenticator: authenticator,
    30     }
    31
    32     app.Handle("GET", "/v1/users", u.List)

Этот код создает значение User, а затем связывает метод `List` с маршрутом. Опять же, поскольку сигнатура функции-обработчика 
неизменяема, использование приемника и методов - лучший способ передачи данных без их сокрытия.

*Отладочные* *или* *трассировочные* *данные* *безопасно* *передавать* *с* *Context*.

Данные, которые могут быть сохранены и получены значением Context, являются отладочной и трассировочной информацией.

    23 // Values represent state for each request.
    24 type Values struct {
    25     TraceID    string
    26     Now        time.Time
    27     StatusCode int
    28 }

Здесь представлено объявление типа, которое создается и хранится внутри каждого значения Context, создаваемого для нового запроса. 
Три поля предоставляют информацию для отслеживания и отладки запроса. Эта информация собирается по мере выполнения запроса.

    75 // Handle is our mechanism for mounting Handlers for a given HTTP verb and path
    76 // pair, this makes for really easy, convenient routing.
    77 func (a *App) Handle(verb, path string, handler Handler, mw ...Middleware) {
    78
    ...
    79     // The function to execute for each request.
    80     h := func(w http.ResponseWriter, r *http.Request, params map[string]string) {
    …
    84     // Set the context with the required values to
    85     // process the request.
    86     v := Values{
    87         TraceID: span.SpanContext().TraceID.String(),
    88         Now:     time.Now(),
    89     }
    90     ctx = context.WithValue(ctx, KeyValues, &v)

Посмотрите, как тип Values создается в строке 86, а затем хранится в Context в строке 90. 
Большая часть этой информации нужна именно промежуточному ПО регистрации

    20 // Create the handler that will be attached in the middleware chain.
    21 h := func(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    ...
    25     // If the context is missing this value, request the service
    26     // to be shutdown gracefully.
    27     v, ok := ctx.Value(web.KeyValues).(*web.Values)
    28     if !ok {
    29         return web.NewShutdownError("web value missing from context")
    30     }
    ...
    34     log.Printf("%s : (%d) : %s %s -> %s (%s)",
    35         v.TraceID, v.StatusCode,
    36         r.Method, r.URL.Path,
    37         r.RemoteAddr, time.Since(v.Now),
    38     )

Последствия передачи информации через Context показаны в коде на
строках 27-30. Код пытается получить данные `Values` из контекста
и проверяет, были ли эти данные там. Если данных нет, то возникает серьезная проблема целостности
и сервис должен быть остановлен. Это делается в коде сервиса путем
отправкой специального значения ошибки обратно через приложение.

Если вы передаете соединения с базой данных или информацию о пользователе на бизнес
уровень с помощью `Context`, у вас возникает две проблемы:

- Вам нужно проверять достоверность и вам нужен механизм для быстрого завершения работы сервиса.
- Тестирование и отладка становятся намного сложнее и запутаннее. Вы отказываетесь от ясности и читабельности кода.

** Примечания

- Входящие запросы к серверу должны создавать Context.
- Исходящие вызовы к серверам должны принимать Context. 
- Цепочка вызовов функций между ними должна распространять Context.
- Замените Context с помощью `WithCancel`, `WithDeadline`, `WithTimeout` или `WithValue`.
- Когда Context отменяется, все производные от него `Context` также отменяется.
- Не храните `Context` внутри  `struct`; вместо этого передавайте `Context` явно каждой функции, которой он нужен.
- Не передавайте Context с нулевым значением, даже если функция это допускает. Передавайте `context.TODO`, если вы не уверены в том, какой Context использовать.
- Используйте контекст `Values` только для данных, скопированных в запрос, которые передаются процессам и API, а не для передачи необязательных параметров функциям.
- Один и тот же Context может быть передан функциям, выполняющимся в разных горутинах; Context'ы безопасны для одновременного использования несколькими горутинами.

** Дополнительное чтение

- [[https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html][Семантика Context пакета в Go]] - Уильям Кеннеди  
- [[https://golang.org/pkg/context][пакет Context]] - Go Team    
- [[https://blog.golang.org/context][Паттерны конкурентности Go: Context]] - Sameer Ajmani    
- [[https://rakyll.org/leakingctx/][Использование Context для предотвращения утечки горутин]] - JBD    

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Приведены возможные решения.

** Упражнение 1

Используйте шаблон и следуйте указаниям. Вам предстоит написать веб-обработчик, который выполняет имитацию вызова базы данных, 
но если вызов займет слишком много времени, то будет отключен на основе контекста. 
Вы также будете сохранять состояние в контексте.

.play context/exercise1.go
.play context/answer1.go
