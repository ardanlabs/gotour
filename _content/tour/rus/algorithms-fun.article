Забавные задачи
В этом разделе собраны забавные задачи, демонстрирующие некоторые возможности Go.

* Проблема спящего цирюльника

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если нужна финансовая поддержка, используйте нашу [[https://www.ardanlabs.com/scholarship/][форму заявки на стипендию]].

Данный пример программы реализует проблему спящего цирюльника.

В парикмахерской есть один парикмахер, одно кресло для парикмахера и `n` стульев для
ожидающих клиентов. Если клиентов нет, парикмахер садится в
в кресло и дремлет. Прибывший клиент должен разбудить парикмахера.
Последующие клиенты занимают кресла для ожидающих, если они свободны, 
или уходят, если все кресла заполнены.

*Output:*

    Opening the shop
    Barber ready to work
    Customer "cust-1" entered shop
    Customer "cust-1" takes a seat and waits
    Barber servicing customer "cust-1"
    Barber finished customer "cust-1"
    Barber taking a nap
    Customer "cust-2" entered shop
    Customer "cust-2" takes a seat and waits
    Barber servicing customer "cust-2"
    Customer "cust-3" entered shop
    Customer "cust-3" takes a seat and waits
    Barber finished customer "cust-2"
    Barber servicing customer "cust-3"
    Customer "cust-4" entered shop
    Customer "cust-4" takes a seat and waits
    Closing the shop
    Barber finished customer "cust-3"
    Barber servicing customer "cust-4"
    Barber finished customer "cust-4"
    Shop closed

.play algorithms/fun/barber.go

* Частота

Этот пример программы показывает, как реализовать функцию, которая может найти
частоту использования данной руны в заданном предложении.

- Последовательный: Линейный алгоритм для выполнения подсчета рун.
- Конкурентный: Конкурентный алгоритм для выполнения подсчета рун.

.play algorithms/fun/freq_sequential.go
.play algorithms/fun/freq_concurrent.go

* Кодирование/декодирование величин переменной длины.

Данный пример программы демонстрирует, как можно использовать Go для реализации кодирования/декодирования величин переменной длины.

- См. подробнее на [[https://en.wikipedia.org/wiki/Variable-length_code][https://en.wikipedia.org/wiki/Variable-length_code]].

Вкратце, цель этого кодирования - сохранить кодировку целых значений
таким образом, чтобы сэкономить байты. Значимыми являются только первые 7 бит каждого байта
(выравнивание по правому краю; что-то вроде ASCII-байта). Таким образом, если у вас есть 32-битное значение,
вам придется упаковать его в серию 7-битных байтов. Конечно, количество байтов будет разным в зависимости от вашего целого. Чтобы указать, какой
байт является последним байтом серии, вы оставляете бит #7 чистым. Во всех
предыдущих байтах вы устанавливаете бит #7.

Таким образом, если целое число находится в диапазоне 0-127, оно может быть представлено в виде одного байта. 
Максимальное целое число - 0FFFFFFF, что соответствует 4 байтам переменной длины.
Вот примеры временных интервалов в виде 32-битных значений и величин переменной
длины, в которые они преобразуются:

    NUMBER        VARIABLE QUANTITY
    00000000              00
    00000040              40
    0000007F              7F
    00000080             81 00
    00002000             C0 00
    00003FFF             FF 7F
    00004000           81 80 00
    00100000           C0 80 00
    001FFFFF           FF FF 7F
    00200000          81 80 80 00
    08000000          C0 80 80 00
    0FFFFFFF          FF FF FF 7F

Код переменной длины (`VLQ`) - это универсальный код, использующий произвольное количество
двоичных октетов (восьмибитных байтов) для представления произвольно большого
целого числа. Он был создан для использования в стандартном формате MIDI-файлов[1], чтобы сэкономить
дополнительное пространство для системы с ограниченными ресурсами, а также используется в более позднем формате
`Extensible Music Format (XMF)`. VLQ - это, по сути, 128-ричное
представление целого беззнакового числа с добавлением восьмого бита
для обозначения продолжения. Смотрите пример ниже.

	Int:    16384
	IntHex: 0x00004000
	IntBin: 00000000 00000000 01000000 00000000
	VLQHex: 0x81 0x80 0x00
	VLQBin: 00000000 10000001 10000000 00000000

Допустим, мы хотим представить число 3435 в `VLQ`. `3435` в
двоичном виде - это `110101101011`. Мы не можем уместить это число в байте. Поэтому мы
будем разбивать его с конца на 7-битные блоки.

    Septet	7	6	5	4	3	2	1
    #1		1	1	0	1	0	1	1
    #2		0	0	1	1	0	1	0

Теперь перед всеми октетами, кроме последнего, мы ставим 1 бит, чтобы указать, что за ним следует октет
и добавляем 0-бит к последнему, сигнализируя о последнем октете.

    Octet   8	7	6	5	4	3	2	1
    #1      0	1	1	0	1	0	1	1
    #2      1	0	0	1	1	0	1	0

Наконец, мы объединяем их, начиная со старшего октета, в

Encoded: 10011010 01101011  ToHex: 0x9A 0x6B

*Дополнительные* *Ресурсы:*

- [[https://en.wikipedia.org/wiki/Variable-length_quantity][https://en.wikipedia.org/wiki/Variable-length_quantity]]
- [[https://blogs.infosupport.com/a-primer-on-vlq/][https://blogs.infosupport.com/a-primer-on-vlq/]]

*Превосходную* *реализацию* *этого* *алгоритма* *можно* *найти *здесь:*

- [[https://github.com/go-audio/midi/blob/master/varint.go][https://github.com/go-audio/midi/blob/master/varint.go]]

.play algorithms/fun/vlq.go
