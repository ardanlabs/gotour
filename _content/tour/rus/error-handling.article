Обработка Ошибок
Обработка ошибок критически важна для обеспечения надежности, доверия и уважения к программам со стороны пользователей.

* Дизайн Обработки Ошибок

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Целостность имеет значение, и это важная часть процесса разработки ПО. Краеугольным камнем целостности
является обработка ошибок. В Go обработка ошибок не считается исключительной ситуацией, которую нужно
обработать позже в какой-то другой части кода. Обработка ошибок считается частью основного пути
и требует полного внимания разработчика.

У разработчиков есть обязанность предоставить достаточно контекста об ошибке, чтобы пользователь
мог принять информированное решение о том, как поступить дальше. Обработка ошибок сводится к трем вещам:
логирование информации об ошибке, предотвращение дальнейшего распространения ошибки и принятие
решения нужно ли завершить работу горутины/программы.

В Go ошибки - это просто значения, поэтому они могут быть чем разработчику угодно. Они могут хранить
любое состояние или поведение.

** Обзор Кода

- *Пример* *1:* Значения Error по Умолчанию
- *Пример* *2:* Переменные типа Error
- *Пример* *3:* Тип как Контекст
- *Пример* *4:* Поведение как Контекст
- *Пример* *5:* Найти Ошибку
- *Пример* *6:* Обертывание Ошибок в stdlib

.play error-handling/example1.go
.play error-handling/example2.go
.play error-handling/example3.go
.play error-handling/example4.go
.play error-handling/example5.go
.play error-handling/example6.go

** Основы Обработки Ошибок

error интерфейс  встроен в язык.

    // https://golang.org/pkg/builtin/#error
    type error interface {
        Error() string
    }

Поэтому он выглядит как неэкспортированный идентификатор. Любое конкретное значение,
реализующее этот интерфейс, может быть использовано как значение error.

Важным аспектом Go является то, что обработка ошибок выполняется без привязки к реализации
этого интерфейса. Основной причиной этого является то, что обработка ошибок - это аспект
моего приложения, позволяющий приложению проще изменяться и улучшаться. Приложения Go
должны возвращать error интерфейс для обработки ошибок.

    // https://golang.org/src/pkg/errors/errors.go
    type errorString struct {
        s string
    }

    // https://golang.org/src/pkg/errors/errors.go
    func (e *errorString) Error() string {
        return e.s
    }

В программах Go это наиболее часто используемое значение error.  Оно объявлено
в пакете стандартной библиотеки errors. Обратите внимание, что тип является
неэкспортированным, и у него есть одно неэкспортированное поле - строка.
Также видно, что для реализации интерфейса error используются семантика указателя.
Это означает, что только адреса значений этого типа могут храниться внутри интерфейса.
Метод просто возвращает строку ошибки.

Важно помнить, что метод Error необходим для реализации интерфейса и для логирования.
Если пользователю приходится разбирать строку, возвращаемую из этого метода,
это говорит о том, что вы не предоставили пользователю достаточно контекста
для принятия информированного решения.

    // https://golang.org/src/pkg/errors/errors.go
    func New(text string) error {
        return &errorString{text}
    }

Функция New - позволяет сконструировать error с использованием конкретного
типа errorString. Обратите внимание, как функция возвращает ошибку, используя интерфейс error.
Также обратите внимание, что при этом используются семантика указателя.

    func main() {
        if err := webCall(); err != nil {
            fmt.Println(err)
            return
        }
        fmt.Println("Life is good")
    }

    func webCall() error {
        return New("bad request")
    }

При работе с ошибками, контекста чрезвычайно важен. Каждая ошибка должна предоставлять
достаточно контекста, чтобы позволить вызывающему принять информированное решение
о состоянии горутины/приложения. В этом примере функция webCall возвращает ошибку с сообщением
Bad Request. В функции main делается вызов webCall, а затем выполняется проверка, произошла
ли ошибка при вызове.

    if err := webCall(); err != nil {
        fmt.Println(err)
        return
    }

Ключ к проверке заключается в err != nil. Это условие задает вопрос: хранится ли
внутри переменной интерфейса err конкретное значение. Если переменная интерфейса хранит
конкретное значение, мы знаем что произошла ошибка. В этом случае важно то,
что существует конкретное значение и при этом не важно, какое именно значение.

Но как быть если важно знать, какое значение ошибки содержится внутри
переменной интерфейса err? Для этого можно использовать переменные error.

    var (
        ErrBadRequest = errors.New("Bad Request")
        ErrPageMoved = errors.New("Page Moved")
    )

Переменные error предоставляют механизм для определения того, какая именно ошибка возвращается.
Идиоматически имена таких переменных начинаться с префикса Err и основаны на конкретном типе
errorString из пакета errors.

    func webCall(b bool) error {
        if b {
            return ErrBadRequest
        }
        return ErrPageMoved
    }

В этой новой версии webCall, функция возвращает одну из переменных ошибок.
Следующий пример позволяет пользователю определить, какая ошибка произошла.

    func main() {
        if err := webCall(true); err != nil {
            switch err {
            case ErrBadRequest:
                fmt.Println("Bad Request Occurred")
                return

            case ErrPageMoved:
                fmt.Println("The Page moved")
                return

            default:
                fmt.Println(err)
                return
            }
        }

        fmt.Println("Life is good")
    }

В приложении после вызова webCall делается проверка на наличие конкретного значения
внутри переменной интерфейса err. Если оно есть, то используется оператор switch
для определения, какая именно это ошибка, сравнивая err с различными переменными error.

В этом случае контекст ошибки основан на том, какая error переменная была возвращена.
Но что если переменная error не дает достаточного контекста? Что если нужно проверить
какое-то специальное состояние, например, как в случае с сетевыми ошибками?
В этих ситуациях ответ - это создание своего собственного нового типа ошибки.

    type UnmarshalTypeError struct {
        Value string
        Type  reflect.Type
    }

    func (e *UnmarshalTypeError) Error() string {
        return "json: cannot unmarshal " + e.Value +
            " into Go value of type " + e.Type.String()
    }

Это собственный конкретный тип ошибки, реализованный в пакете json. Обратите внимание,
что имя имеет суффикс Error в названии типа. Также обратите внимание на использование
семантики указателя для реализации интерфейса ошибки. Опять же реализация служит
для логирования и должна включать информацию о всех используемых полях.

    type InvalidUnmarshalError struct {
        Type reflect.Type
    }

    func (e *InvalidUnmarshalError) Error() string {
        if e.Type == nil {
            return "json: Unmarshal(nil)"
        }
        if e.Type.Kind() != reflect.Ptr {
            return "json: Unmarshal(non-pointer " + e.Type.String() + ")"
        }
        return "json: Unmarshal(nil " + e.Type.String() + ")"
    }

Вот еще один конкретный тип ошибки, из пакета json. Реализация метода Error
немного сложнее, но и в данном случае тот метод необходим для логирования
и использует семантику указателя.

    func Unmarshal(data []byte, v interface{}) error {
        rv := reflect.ValueOf(v)
        if rv.Kind() != reflect.Ptr || rv.IsNil() {
            return &InvalidUnmarshalError{reflect.TypeOf(v)}
        }
        return &UnmarshalTypeError{"string", reflect.TypeOf(v)}
    }

Выше приведена часть функции Unmarshal. Обратите внимание, что с помощью интерфейса error
она возвращает конкретные значения ошибок. Значение создается с помощью семантики указателя,
потому что эта семантика использовалась при объявлении метода Error.

Контекст ошибки здесь скорее связан с типом ошибки, хранящимся внутри интерфейса error.
Нам необходимо иметь возможность определить этот тип.

    func main() {
        var u user
        err := Unmarshal([]byte(`{"name":"bill"}`), u)
        if err != nil {
            switch e := err.(type) {
            case *UnmarshalTypeError:
                fmt.Printf("UnmarshalTypeError: Value[%s] Type[%v]\n",
                    e.Value, e.Type)
            case *InvalidUnmarshalError:
                fmt.Printf("InvalidUnmarshalError: Type[%v]\n", e.Type)
            default:
                fmt.Println(err)
            }
            return
        }
        fmt.Println("Name:", u.Name)
    }

Утверждение типа в рамках оператора switch используется для проверки типа значения,
хранящегося внутри интерфейсного значения err. Здесь контекстом является тип, и теперь
вы можете тестировать и выполнять все необходимые действия так как у вас есть доступ
ко всем состояниям error.

Однако здесь возникает одна проблема. Теперь я привязан к конкретному значению error.
Это означает, что если конкретное значение ошибки изменится, мой код может сломаться.
Прелесть использования интерфейса для обработки ошибок заключается в том, что он не
привязывает ваш код к изменениям, которые могут привести к поломке.

Если конкретное значение ошибки имеет набор методов, вы можете использовать интерфейс
для проверки типа. В качестве примера, пакет net содержит множество конкретных типов ошибок,
реализующих разные методы. Один общий метод - Temporary. Этот метод позволяет пользователю
проверить, является ли сетевая ошибка критической или просто чем-то, что может
восстановиться самостоятельно.

    type temporary interface {
        Temporary() bool
    }

    func (c *client) BehaviorAsContext() {
        for {
            line, err := c.reader.ReadString('\n')
            if err != nil {
                switch e := err.(type) {
                case temporary:
                    if !e.Temporary() {
                        log.Println("Temporary: Client leaving chat")
                        return
                    }
                default:
                    if err == io.EOF {
                        log.Println("EOF: Client leaving chat")
                        return
                    }
                    log.Println("read-routine", err)
                }
            }
            fmt.Println(line)
        }
    }

В этом коде вызов ReadString может завершиться ошибкой из пакета net.
В этом случае объявляется интерфейс, представляющий общее поведение конкретного
значения error. Затем с помощью утверждения типа вы проверяете, существует ли
такое поведение, и можете вызывать его. Что еще лучше - такой способ обработки ошибок
не привязывает вас к деталям реализации.

** Всегда используйте интерфейс error

Одной из ошибок, которую иногда совершают разработчики Go, является использование
конкретного типа ошибки, а не интерфейса error для возвращаемого типа обработки ошибок.
Если вы пошли этим путем, впереди вас ждут неприятности.

    type customError struct{}

    func (c *customError) Error() string {
        return "Find the bug."
    }

    func fail() ([]byte, *customError) {
        return nil, nil
    }

    func main() {
        var err error
        if _, err = fail(); err != nil {
            log.Fatal("Why did this fail?")
        }
        log.Println("No Error")
    }

Вывод:

    Why did this fail?

Почему этот код считает, что произошла ошибка, когда функция fail возвращает nil для ошибки?
Это потому, что функция fail использует конкретный тип ошибки, а не интерфейс error.
В этом случае в переменной err хранится нулевой указатель типа customError.
Это не то же самое, что нулевое значение интерфейса типа error.

** Обработка ошибок

Обработка ошибок - это скорее инженерный диалог на макро уровне.
В моем мире обработка ошибок означает, что:
1) ошибка останавливается на функции, обрабатывающей ошибку
2) ошибка регистрируется с полным контекстом, и проверяется серьезность ошибки
3) в зависимости от серьезности и возможности восстановления принимается решение о восстановлении, продолжении или завершении работы.

Одной из проблем является то, что не все функции могут обработать ошибку. Причиной этому
может быть то, что не все функции имеют право на логирование. Что происходит, когда ошибка
передается вверх по стеку вызовов и не может быть обработана вызывающей функцией?  Ошибку нужно
обернуть в контекст, чтобы функция, обрабатывающая ее в конечном счете, могла сделать это правильно.

    package main

    import (
        "errors"
        "fmt"
    )

    type AppError struct {
        State int
    }

    func (ae *AppError) Error() string {
        return fmt.Sprintf("App Error, State: %d", ae.State)
    }

    func IsAppError(err error) bool {
        var ae *AppError
        return errors.As(err, &ae)
    }

    func GetAppError(err error) *AppError {
        var ae *AppError
        if !errors.As(err, &ae) {
            return nil
        }
        return ae
    }

    func main() {
        if err := firstCall(10); err != nil {

            // Check if the error is an AppError.
            if IsAppError(err) {
                ae := GetAppError(err)
                fmt.Printf("Is AppError, State: %d\n", ae.State)
            }

            fmt.Print("\n********************************\n\n")

            // Display the error using the implementation of
            // the error interface.
            fmt.Printf("%v\n", err)
        }
    }

    func firstCall(i int) error {
        if err := secondCall(i); err != nil {
            return fmt.Errorf("secondCall(%d) : %w", i, err)
        }
        return nil
    }

    func secondCall(i int) error {
        return &AppError{99}
    }

Вывод:

    Is AppError, State: 99

    ********************************

    secondCall(10) : App Error, State: 99

** Заметки

- Используйте значение error по умолчанию для статических и просто форматированных сообщений.
- Создавайте и возвращайте error переменные, чтобы помочь вызывающему определить специфические ошибки.
- Создавайте пользовательские типы ошибок, в ситуациях когда контекст ошибки более сложный.
- Значения ошибок в Go не являются чем-то особенным, это просто значения, и поэтому в вашем распоряжении есть весь арсенал языка Go.

** Цитаты

"Системы не могут быть разработаны основываясь на предположении, что люди смогут написать
миллионы строк кода, не допуская ошибок, и одной только работы в отладчике
не достаточно для разработки надежных систем." - Эл Ахо (изобретатель AWK)

** Дополнительное чтение

- [[https://go.dev/blog/error-handling-and-go][Обработка ошибок и Go]]
- [[https://go.dev/blog/go1.13-errors][Работа с ошибками в Go 1.13]]
- [[https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html][Обработка ошибок на Go, часть I]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html][Обработка ошибок на Go, часть II]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html][Философия дизайна логирования]] - Уильям Кеннеди
- [[https://clipperhouse.com/bugs-are-a-failure-of-prediction/][Баги - это ошибочные предсказания]] - Мэтт Шерман
- [[https://dave.cheney.net/2014/12/24/inspecting-errors][Инспекция ошибок]] - Дейв Чейни
- [[https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully][Не просто проверяйте ошибки, обрабатывайте их грамотно]] - Дейв Чейни
- [[https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package][Стек-трейсы и пакет errors]] - Дейв Чейни
- [[https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html][Обработка ошибок в Upspin]] - Роб Пайк
- [[https://rauljordan.com/why-go-error-handling-is-awesome/][Почему обработка ошибок в Go - это здорово]] - Рауль Джордан

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1

Создайте две переменные error: ErrInvalidValue и ErrAmountTooLarge.
Задайте каждой переменной статическое сообщение. Затем напишите функцию checkAmount,
которая принимает значение типа float64 и возвращает значение error.
Проверьте входящее значение на равенство нулю и, если оно таково, верните ErrInvalidValue.
Проверьте превышает ли входящее значение $1,000, и если это так - верните ErrAmountTooLarge.
Напишите функцию main для вызова функции checkAmount и проверки значения ошибки.
Выведите соответствующее сообщение на экран.

.play error-handling/exercise1.go
.play error-handling/answer1.go

** Упражнение 2

Создайте пользовательский тип ошибки с именем appError, содержащий три поля:
err типа error, message типа string и code типа int. Реализуйте интерфейс error,
предоставив свое сообщение с помощью этих трех полей. Реализуйте второй метод
с именем temporary, который возвращает false, когда значение поля code равно 9.
Напишите функцию checkFlag, которая принимает значение типа bool. Если значение равно false,
верните указатель на ваш пользовательский тип ошибки, инициализированный по вашему усмотрению.
Если значение равно true, верните ошибку по умолчанию. Напишите функцию main для вызова
функции checkFlag и проверки ошибки с использованием интерфейса temporary.

.play error-handling/exercise2.go
.play error-handling/answer2.go
