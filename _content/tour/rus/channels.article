Каналы
Каналы позволяют горутинам взаимодействовать друг с другом с помощью сигнальной семантики.

* Каналы

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Смотреть видео]]
Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Важно думать о канале не как о структуре данных, а как о механизме для
передачи сигналов. Это согласуется с идеей, что вы отправляете и получаете из канала,
а не читаете и записываете. Если проблема, стоящая перед вами, не может быть решена с помощью сигнализации,
если слово "сигнализация" не сходит с ваших уст, вам нужно поставить под сомнение использование
каналов.

** Обзор кода

- *Пример* *1:* Дождитесь результата
- *Пример* *2:* Веерный выход
- *Пример* *3:* Ожидание задачи
- *Пример* *4:* Пул
- *Пример* *5:* Веерный выход с семафором
- *Пример* *6:* Ограниченный пул работ
- *Пример* *7:* Отбрасывание
- *Пример* *8:* Отмена
- *Пример* *9:* Время ожидания перед повторной попыткой
- *Пример* *10:* Отмена с помощью канала

.play channels/example1.go
.play channels/example2.go
.play channels/example3.go
.play channels/example4.go
.play channels/example5.go
.play channels/example6.go
.play channels/example7.go
.play channels/example8.go
.play channels/example9.go
.play channels/example10.go

** Механика канала

Ценой гарантии на сигнальном уровне является неизвестная задержка. Отправитель 
не знает, как долго ему придется ждать, пока получатель примет сигнал.
Необходимость ждать получателя создает задержку из-за блокировки. 
В этом случае количество задержек из-за блокировки неизвестно. Отправителю приходится ждать неизвестно сколько времени,
пока приемник не станет доступен для приема сигнала.

Ожидание получателя означает, что механически операция получения происходит раньше
отправки. В каналах прием происходит на наносекунды раньше, но это раньше.
Это означает, что получатель принимает сигнал и уходит, позволяя отправителю
продолжить работу с гарантией.

А что, если процесс не может ждать неизвестное количество времени? Что, если такая
задержка не сработает? Тогда гарантия не может быть на уровне сигнала, она должна быть
быть вне его. Механика этой работы заключается в том, что отправка теперь происходит
до получения. Отправитель может выполнить сигнал, не нуждаясь в том, чтобы получатель 
был доступен. Таким образом, отправитель может уйти и не ждать. В конце концов, вы надеетесь,
что получатель появится и примет сигнал.

Это снижает затраты на задержку при отправке, но создает неопределенность в отношении сигналов
и, следовательно, не известно, есть ли проблемы с получателем.
Это может привести к принятию работы, которая так и не будет начата или закончена. Это
В конечном итоге это может привести к огромному обратному давлению и отказу систем.

Второе, на чем следует сосредоточиться, - нужно ли вам передавать данные вместе с сигналом? Если сигнал
требует передачи данных, то сигнал передается между горутинами по схеме 1 к 1.
Если новая горутина должна получить сигнал, необходимо отправить второй сигнал.

Если при передаче сигнала не требуется передача данных, то сигнал может быть 1 к
1 или 1 ко многим между горутинами. Сигнал без данных используется в основном для
отмены или отключения. Это делается путем закрытия канала.

Третье, на чем следует сосредоточиться, - это состояние канала. Канал может находиться в одном из трех состояний.

Канал может находиться в состоянии nil, если установить его в состояние нулевого значения.
Отправка и получение по каналам в этом состоянии будут блокироваться. Это хорошо подходит для ситуаций.
когда необходимо реализовать кратковременные остановки работы.

Канал можно перевести в открытое состояние с помощью встроенной функции make. Отправка и
получение по каналам в этом состоянии будут работать при следующих условиях:

*Небуферизованные* *Каналы:*

- Гарантии на уровне сигналов с получением перед отправкой. Отправляющая
и получающая горутины должны сойтись в одном месте и времени, чтобы
чтобы сигнал был обработан.

*Буферизованные* *Каналы:*

- Гарантии вне сигнального уровня с отправкой перед получением. Если буфер не заполнен, отправка может завершиться, иначе она блокируется. Если
буфер не пуст, получатели могут завершить передачу, иначе они блокируются.

Канал может быть переведен в закрытое состояние с помощью встроенной функции close. Вам не
нужно закрывать канал для освобождения памяти, этот механизм служит для изменения состояния. Отправка
в закрытый каналу вызовет панику, однако прием из закрытого канала
произойдет немедленно.

Получив всю эту информацию, вы можете сосредоточиться на шаблонах каналов. Фокус на сигнализации
очень важен. Идея заключается в том, нужна ли вам гарантия на уровне сигналов или нет,
исходя из соображений задержки. Нужно ли передавать данные вместе с сигналом или нет, основываясь
обрабатывать отмены или нет. Вы хотите преобразовать синтаксис в эту семантику.

** Руководство по проектированию

- Ознакомьтесь с [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#channel-design]] [рекомендациями по проектированию]] для каналов.

** Диаграммы

*Гарантия* *Доставки*

В основе ``Гарантии доставки`` лежит один вопрос: "Нужна ли мне гарантия того, что
сигнал, посланный конкретной горутиной, был получен?"

.image /tour/eng/static/img/guarantee_of_delivery.png

*Сигнализация* *С* *Или* *Без* *Данных*

Если вы собираетесь подавать сигнал `с данными`, есть три варианта конфигурации канала
в зависимости от типа `гарантии`, которая вам нужна.

.image /tour/eng/static/img/signaling_with_data.png

Сигнализация без данных служит основной механизма отмены. Он позволяет одной
горутине сигнализировать другой горутине, чтобы та отменила свои действия и двигалась дальше.
Отмена может быть реализована с использованием как `небуферизованных`, так и `буферизованных` каналов.

.image /tour/eng/static/img/signaling_without_data.png

*Состояние*

Поведение канала напрямую зависит от его текущего `состояния`. 
Состояние канала может быть `nil`, `open` (открыт) или `closed` (закрыт).

.image /tour/eng/static/img/state.png

** Дополнительное чтение

- [[https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html][The Behavior Of Channels]] - Уильям Кеннеди  
- [[https://golang.org/ref/mem#tmp_7][Коммуникация каналов]]    
- [[http://blog.golang.org/share-memory-by-communicating][Делимся памятью, общаясь]] - Эндрю Джерранд    
- [[https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html][Природа каналов в Go]] - Уильям Кеннеди    
- [[http://matt-welsh.blogspot.com/2010/07/retrospective-on-seda.html][Ретроспектива SEDA]] - Мэтт Уэлш    
- [[https://www.youtube.com/watch?v=KBZlN0izeiY][Понимание каналов]] - Kavya Joshi    

** Buffer Bloat - 2011

Будьте осторожны с использованием больших буферов с целью снижения задержки.

- Большие буферы препятствуют своевременному оповещению об обратной нагрузке.
- Они лишают вас возможности своевременно снижать обратную нагрузку.
- Они могут увеличить задержку, а не уменьшить ее.
- Используйте буферизованные каналы для обеспечения непрерывности.
- Не используйте их только для повышения производительности.
- Используйте их для обработки четко определенных всплесков данных.
- Используйте их для решения проблем скорости света между передачами.

*Видео*

- [[https://www.youtube.com/watch?v=qbIozKVz73g][Bufferbloat: темные буферы в Интернете]]  
- [[http://www.bufferbloat.net/projects/cerowrt/wiki/Bloat-videos][Buffer Bloat Videos]]  

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Приведены возможные решения.

** Упражнение 1

Напишите программу, в которой две горутины передают целое число туда и обратно десять раз.
Выведите на экран момент получения целого числа каждой горутиной. Увеличивайте целое число при каждом
передаче. Как только целое число станет равным десяти, завершите программу.

.play channels/exercise1.go 
.play channels/answer1.go

** Упражнение 2

Напишите программу, которая использует шаблон веерной генерации для одновременной генерации 100 случайных чисел.
Пусть каждая горутина генерирует одно случайное число и возвращает его главному,
буферизованному каналу. Установите размер буфера канала так, чтобы ни одна отправка никогда не
блокировалась. Не выделяйте буфер больше, чем вам нужно. Пусть главная горутина отображает каждое
случайное число, которое она получает, а затем завершает программу.

.play channels/exercise2.go 
.play channels/answer2.go

** Упражнение 3

Напишите программу, которая одновременно генерирует до 100 случайных чисел. Не отправляйте
все 100 значений, поэтому количество отправленных/полученных чисел неизвестно.

.play channels/exercise3.go 
.play channels/answer3.go
 
** Упражнение 4

Напишите программу, которая одновременно генерирует до 100 случайных чисел, используя пул
работ. Отклоняйте четные значения. Прикажите рабочим прекратить работу, когда 100 нечетных чисел 
собраны.

.play channels/exercise4.go 
.play channels/answer4.go
