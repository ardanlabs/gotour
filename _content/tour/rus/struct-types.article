Типы данных структур (struct)
Типы данных struct используются для создания сложных типов, группирующих несколько полей.

* Типы Struct
- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Типы данных struct используются для создания сложных типов, группирующих несколько полей.
Они отлично подходят для организации и обмена данных различной формы с которыми работает
ваша программа.

Потенциальная производительность архитектуры компьютера в значительной степени определяется её
длиной слова (количеством битов, которые могут быть обработаны за одну операцию), и, что более важно,
размером памяти, или количеством слов, к которым она может получить доступ.

** Обзор кода

- *Пример* *1:* Объявление, создание и инициализация типов struct.
- *Пример* *2:* Анонимные типы struct.
- *Пример* *3:* Именованные и безымянные типы.
- *Пример* *4:* Выравнивание типов struct

.play struct-types/example1.go
.play struct-types/example2.go
.play struct-types/example3.go
.play struct-types/example4.go

** Типы Struct и Механика их Создания

Это объявление представляет собой конкретный тип определенный пользователем, состоящий из
различных полей и типов.

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

Объявление переменной типа example и её инициализация нулевым значением.

    var e1 example

    fmt.Printf("%+v\n", e1)

Результат:

    {flag:false counter:0 pi:0}

Объявление переменной типа example, не устанавливая её в нулевое значение с помощью литерального
синтаксиса инициализации.

    e2 := example{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e2.flag)
    fmt.Println("Counter", e2.counter)
    fmt.Println("Pi", e2.pi)

Результат:

    Flag true
    Counter 10
    Pi 3.141592

Объявление переменной безымянного литерального типа в состоянии ненулевого значения
с использованием литерального синтаксиса инициализации.

    e3 := struct {
        flag    bool
        counter int16
        pi      float32
    }{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e3.flag)
    fmt.Println("Counter", e3.counter)
    fmt.Println("Pi", e3.pi)

Результат:

    Flag true
    Counter 10
    Pi 3.141592

Идея создания значения посредством литерала заключается в том, чтобы  буквально создавать что-то
без имени.

Используйте var для нулевого значения и оператор короткого объявления переменной с
синтаксисом { } для инициализации ненулевого состояния.

** Выравнивание и Заполнение

Сколько памяти выделяется для значения типа example?

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

Булевое поле - 1 байт, int16 - 2 байта, float32 - 4 байта. Сложите всё это вместе,
и вы получите 7 байт. Однако фактический ответ - 8 байт. Почему? Потому что
между полями flag и counter находится дополнительный байт для выравнивания.

.image /tour/eng/static/img/f1.png

Идея выравнивания заключается в том, чтобы позволить компьютеру более эффективно считывать
память, размещая значения на определенных границах выравнивания памяти. Компилятор заботится
о механике границы выравнивания, чтобы вам не нужно было об этом беспокоиться.

В зависимости от размера конкретного поля и его местоположения в структуре
Go определяет необходимые заполнения.

    type example2 struct {
        flag    bool
        counter int16
        flag2   bool
        pi      float32
    }

В этом примере я добавил новое поле с именем `flag2` между полями counter и pi.
Это приводит к большему заполнению внутри структуры.

    type example2 struct {
        flag    bool     // 0xc000100020 <- Начальный адрес
                byte     // 0xc000100021 <- 1 байт заполнения
        counter int16    // 0xc000100022 <- Выравнивание 2 байта
        flag2   bool     // 0xc000100024 <- Выравнивание 1 байта
                byte     // 0xc000100025 <- 1 байт заполнения
                byte     // 0xc000100026 <- 1 байт заполнения
                byte     // 0xc000100027 <- 1 байт заполнения
        pi      float32  // 0xc000100028 <- Выравнивание 4 байта
    }

Вот как происходит выравнивание и размещение дополнительных байтов (padding), если значение
типа example2 расположено начиная с адреса 0xc000100020. Поле flag представляет собой
начальный адрес и имеет размер всего 1 байт. Поскольку поле counter требует 2 байта памяти,
оно должно размещаться в памяти с выравниванием в 2 байта, что означает, что оно должно
начинаться с адреса, кратного 2. Это создает разрыв в 1 байт между полями flag и counter.

.image (/tour/eng/static/img/f2.png)

Поле `flag2` имеет тип bool и может начинаться c адреса 0xc000100024. Последнее поле
pi требует выделения 4х байтов памяти, поэтому оно должно размещаться в памяти с выравниванием
в 4 байта. Следующий адрес для значения из 4 байтов находится по адресу 0xc000100028.
Это означает, что для обеспечения правильного выравнивания потребуется еще 3 дополнительных байта.
В результате значение типа example2 займет 12 байтов памяти.

Самое большое поле в структуре определяет границу выравнивания для всей структуры. В данном случае
самое большое поле имеет размер 4 байта, поэтому начальный адрес для этой структуры должен быть
кратным 4м. Как видите, адрес 0xc000100020 кратен 4м.

Если вам нужно минимизировать количество дополнительных байтов, расположите поля в порядке
убывания необходимой памяти. Это сдвигает дополнительные байты в нижнюю часть структуры
и уменьшает общее количество необходимых дополнительных байтов.

type example struct {
    pi      float32  // 0xc000100020 <- Начальный адрес
    counter int16    // 0xc000100024 <- Выравнивание 2 байта
    flag    bool     // 0xc000100026 <- Выравнивание 1 байт
    flag2   bool     // 0xc000100027 <- Выравнивание 1 байт
}

После реорганизации полей, структура займет всего 8 байтов памяти, а не 12. Поскольку все поля
позволяют значению структуры разместиться на границе 4х байт, дополнительные байты не требуются.

.image /tour/eng/static/img/f3.png

**Присвоение значений

Если у вас есть два разных именованных типа, идентичных по своей структуре, вы не можете
присвоить значение одного другому.

Например, если типы example1 и example2 имеют идентичную структуру и мы инициализируем две переменные.

var ex1 example1
var ex2 example2

Вы не можете присвоить эти две переменные друг другу, так как они имеют разные именованные типы.
Тот факт, что они идентичны по своей структуре, не имеет значения.

ex1 = ex2  // Запрещено, ошибка компиляции

Для выполнения этого присвоения вам придется использовать преобразование, и поскольку они имеют
одинаковую структуру, компилятор это позволит.

ex1 = example1(ex2)  // Разрешено, нет ошибки компиляции

Однако если ex2 был объявлен как анонимный тип, объявленный идентично с ex1,
преобразования не потребуется.

var ex2 struct {
    flag    bool
    counter int16
    pi      float32
}

ex1 = ex2  // Разрешено, преобразования не требуется

Компилятор позволит это присвоение без преобразования.

**Заметки

- Мы можем использовать структурный литерал для инициализации значения типа структуры.
- Оператор точки (.) позволяет нам получать доступ к значениям полей.
- Мы можем создавать анонимные структуры.

**Цитаты

"Неявное преобразование типов - это Хэллоуинское кодирование.
Тот, кто их придумал, заслуживает особое место в аду." - Мартин Томпсон

**Дополнительная литература

- [[https://www.ardanlabs.com/blog/2013/07/understanding-type-in-go.html][Понимание типов в Go]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2013/07/object-oriented-programming-in-go.html][Объектно-ориентированное программирование в Go]] - Уильям Кеннеди
- [Дополнительные байты - это сложно](https://dave.cheney.net/2015/10/09/padding-is-hard) - Дейв Чейни
- [Выравнивание, дополнительные байты и упаковка данных в структурах](https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/)
- [Утраченное искусство выравнивания структур](http://www.catb.org/esr/structure-packing) - Эрик С. Рэймонд

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений.  Здесь представлен возможный вариант решения.

** Упражнение 1

*Часть* *А:* Объявите структурy для хранения информации о пользователе (имя, электронная почта и возраст).
Создайте переменную этого типа, инициализируйте ее значениями и отобразите каждое поле.

*Часть* *Б:* Объявите и проинициализируйте анонимную структуру с тремя полями. Отобразите это значение.

.play struct-types/exercise1.go
.play struct-types/answer1.go
