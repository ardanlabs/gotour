Каналы
Узнайте, как команда Go смогла добавить пакет паттернов конкурентности в стандартную библиотеку благодаря дженерикам.

* Дженерики - Каналы

Узнайте, как команда Go смогла добавить пакет паттернов конкурентности в стандартную библиотеку благодаря дженерикам.

** Видео

Посмотрите доклад о дженериках, в котором я рассказываю обо всех
примерах, приведенных в этом разделе.

.html generics-video.html

** Обзор кода

- *Пример* *1*: Рабочая функция
- *Пример* *2*: Пулинг

.play generics/channels/example1.go
.play generics/channels/example2.go

** Объяснение

Это требует объявления каналов и функций с использованием дженерик типов.

    type workFn[Result any] func(context.Context) Result

В этом примере объявлен тип, представляющий функцию, которая принимает контекст
и возвращает значение дженерик типа `Result`. Это объявление функции,
выполняющей конкурентную работу и возвращающей результат этой работы.

    func doWork[Result any](ctx context.Context, work workFn[Result]) chan Result {
        ch := make(chan Result, 1)
        
        go func() {
            ch <- work(ctx)
            fmt.Println("doWork : work complete")
        }()
        
        return ch
    }

Теперь напишите функцию `doWork`, которая выполняет указанную функцию `work`
и возвращает канал, чтобы вызывающая сторона могла получить результат
выполненной функцией `work`. Дженерик тип `Result` объявляется для того, чтобы
представить тип возврата `workFn` и тип канала.

В реализации функции `doWork` создается канал значений с типом `Result` и размером буфера 1.
Это канал, возвращаемый вызывающей стороне для получения результата конкурентной работы. 
В середине функции вызывается горутина для конкурентного выполнения функции `work`. 
Как только функция `work` возвращает значение, это значение отправляется обратно вызывающей стороне по каналу.

Чтобы проверить использование функции `doWork`, напишите небольшую программу.

    func main() {
        duration := 100 * time.Millisecond
        
        ctx, cancel := context.WithTimeout(context.Background(), duration)
        defer cancel()
        
        dwf := func(ctx context.Context) string {
            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
            return "work complete"
        }

        result := doWork(ctx, dwf)
        
        select {
            case v := <-result:
                fmt.Println("main:", v)
            case <-ctx.Done():
                fmt.Println("main: timeout")
        }
    }

Output:

    doWork : work complete
    main: work complete

Программа начинается с объявления контекста с таймаутом 100 миллисекунд.
Затем объявляется функция `work`, которая ожидает до 200 миллисекунд, прежде чем
вернуть строку "work complete". После создания контекста и функции `dwf` 
выполняется вызов `doWork`, возвращается канал типа string и
присваивается переменной `result`.

Компилятор способен определить конкретный тип, который следует использовать для дженерик типа
`Result`, проверив тип возврата конкретной функции `work`, переданной в `doWork.`
Это замечательно, потому что не нужно передавать конкретный тип при вызове `doWork`.

С каналом типа `string`, назначенным переменной `result`, используется `select case`
для ожидания своевременного возврата результата или таймаута. Функция
`doWork` может быть использована для выполнения этой конкурентной работы для любого конкретного типа.

Эту же идею можно применить к пулу горутин, которые могут обработать
дженерик ввод и возвращать дженерик результат.

type workFn[Input any, Result any] func(input Input) Result

В этом примере измените тип функции, чтобы она принимала дженерик ввод и возвращала
общий результат.

    func poolWork[Input any, Result any](size int, work workFn[Input, Result]) (chan Input, func()) {
        var wg sync.WaitGroup
        wg.Add(size)
        
        ch := make(chan Input)
        
        for i := 0; i < size; i++ {
            go func() {
                defer wg.Done()
                for input := range ch {
                    result := work(input)
                    fmt.Println("pollWork :", result)
                }
            }()
        }
        
        cancel := func() {
            close(ch)
            wg.Wait()
        }

        return ch, cancel
    }

В функции `poolWork` объявлены те же два дженерик типа для представления
вводимый и возвращаемый тип для функции `work`. Создается группа ожидания для управления
жизненным циклом горутин в пуле. Затем создается канал
дженерик типа `Input`. Этот канал используется гортинами в пуле для получения
вводных данных для рабочей функции.

Затем создается пул горутин, причем каждая горутина ожидает выполнения операции приема
с помощью цикла `for-range` по отношению к каналу. Наконец, строится функция `cancel`
чтобы позволить вызывающей стороне выключить пул и дождаться, пока все горутины
сигнализируют о своем завершении.

Чтобы проверить использование функции `poolWork`, напишите вторую небольшую программу.

    func main() {
        size := runtime.GOMAXPROCS(0)
        
        pwf := func(input int) string {
            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
            return fmt.Sprintf("%d : received", input)
        }

        ch, cancel := poolWork(size, pwf)
        defer cancel()
        
        for i := 0; i < 4; i++ {
            ch <- i
        }
    }

Output:

    pollWork : 3 : received
    pollWork : 2 : received
    pollWork : 1 : received
    pollWork : 0 : received
    
Размер пула рассчитывается на основе количества горутин, которые могут работать
конкурентно. Затем строится функция `pwf`, которая будет спать в течение случайного количества времени
и возвращать строку, представляющую вводимые данные.

После этого выполняется функция `poolWork`, возвращая канал и функцию `cancel`. Функция `cancel` откладывается, и строится цикл для отправки
4 значений в пул. При каждом запуске программы вывод будет отличаться,
поскольку выполнение происходит конкурентно.

Эти небольшие примеры дают некоторое представление о том, как может быть реализован конкурентный пакет.
