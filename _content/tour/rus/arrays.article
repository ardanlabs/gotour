Массивы
Массив - это специальная структура данных в Go, позволяющая выделить непрерывный блок памяти фиксированного размера.

* Массивы

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Массив - это специальная структура данных в Go, позволяющая выделить непрерывный блок памяти фиксированного размера.
У Go массивов есть особенности в том как они объявляются и как рассматривается их тип.

** Обзор Кода

- *Пример* *1:* Объявление, инициализация и итерация
- *Пример* *2:* Массивы разных типов
- *Пример* *3:* Выделение непрерывной памяти
- *Пример* *4:* Механика инструкции `range`

.play arrays/example1.go
.play arrays/example2.go
.play arrays/example3.go
.play arrays/example4.go

** Объявление и инициализация значений

Объявите массив из пяти строк, инициализированный в состоянии нулевого значения.

    var strings [5]string

Строка - это неизменяемая структура данных состоящая из двух частей (слов) - указатель на
буфер байтов и количество байтов в этом буфере. Поскольку этот массив установлен
в состояние нулевого значения, каждый его элемент устанавливается в состояние нулевого
значения. Это означает, что каждая строка имеет первое слово, установленное
в nil, и второе слово, установленное в 0.

.image /tour/eng/static/img/a1.png

** Присваивание строк

Что происходит, когда одной строке присваивается другая строка?

    strings[0] = "Apple"

Когда одной строке присваивается другая строка, копируются два слова, что приводит
к двум разным строковым значениям, использующим один и тот же буфер байтов.

.image /tour/eng/static/img/a2.png

Стоимость копирования строки одинакова вне независимости от размера строки -
это копирование двух слов.

** Итерация по коллекциям

Go предоставляет две разные семантики для итерации по коллекции. Можно итерировать,
используя семантику значений или семантику указателей.

    // Итерация с семантикой значений
    for i, fruit := range strings {
        println(i, fruit)
    }


    // Итерация с семантикой указателей
    for i := range strings {
        println(i, strings[i])
    }

При использовании итерации с семантикой значений происходят две вещи. Во-первых, коллекция,
по которой производится итерация, копируется, и вы итерируете по этой копии. В случае
массива - копирование может быть дорогостоящим, так как копируется весь массив. В случае среза,
реальной стоимости нет, так как копируется только внутреннее значение среза, а не
базовый массив. Во-вторых, вы получаете копию каждого элемента, по которому выполняется итерация.

При использовании итерации с семантикой указателей вы итерируете по исходной коллекции,
и вы можете получить доступ к каждому элементу этой коллекции напрямую.

** Итерация с семантикой значений

Рассмотрите следующий код и вывод.

    strings := [5]string{"Apple", "Orange", "Banana", "Grape", "Plum"}
    for i, fruit := range strings {
        println(i, fruit)
    }

Вывод:

    0 Apple
    1 Orange
    2 Banana
    3 Grape
    4 Plum

Переменная strings - это массив из 5 строк. Цикл выполняет итерацию по каждой строке
в коллекции и отображает позицию индекса и значение строки. Поскольку это итерация
с семантикой значений, цикл for range выполняет итерацию по своей собственной
поверхностной копии массива, и на каждой итерации переменная fruit - это копия каждой строки
(структуры данных из двух слов).

Обратите внимание, что переменная fruit передается в функцию печати, используя семантику
значений. Функция print также получает свою собственную копию строки. К моменту передачи
строки в функцию печати существуют 4 копии значения строки (массив, поверхностная копия,
переменная fruit и собственная копия функции печати). Все 4 копии ссылаются на один и тот же
базовый массив байтов.

.image /tour/eng/static/img/a3.png

Создание копий значений строки важно, потому что это предотвращает утечку значения строки
в кучу. Это устраняет не продуктивное выделение памяти в куче.

** Итерация с семантикой указателей

Рассмотрите следующий код и вывод.

    strings := [5]string{"Apple", "Orange", "Banana", "Grape", "Plum"}
    for i := range strings {
        println(i, strings[i])
    }

Вывод:

    0 Apple
    1 Orange
    2 Banana
    3 Grape
    4 Plum

Опять же, переменная strings - это массив из 5 строк. Цикл выполняет итерацию по каждой
строке в коллекции, по ходу отображая позицию индекса и значение строки. Поскольку это
итерация с семантикой указателей, цикл for range выполняет итерацию по массиву напрямую,
и на каждой итерации значение строки для индекса извлекается непосредственно при вызове
функции печати.

** Массивы разных типов

Обратите внимание какую ошибку выдаёт компилятор при попытке присвоения массивов
одного и того же типа элементов, но разной длины.

    var five [5]int
    four := [4]int{10, 20, 30, 40}

    five = four

Ошибка компиляции:

    cannot use four (type [4]int) as type [5]int in assignment

Здесь вы объявляете массивы из 4 и 5 целых чисел, инициализированные своими нулевыми значениями.
Затем пытаетесь присвоить их друг другу, и компилятор говорит: "нельзя использовать четыре
(type [4]int) в качестве [5]int при присваивании".

Важно понимать, что говорит компилятор. Он говорит, что массив из 4 целых чисел и массив
из 5 целых чисел представляют данные разных типов. Размер массива - это часть информации
о его типе. В Go размер массива должен быть известен на этапе компиляции.

** Выделение непрерывной памяти

Давайте убедимся, что под массив выделяется непрерывный фрагмент памяти.

    five := [5]string{"Annie", "Betty", "Charley", "Doug", "Bill"}

    for i, v := range five {
        fmt.Printf("Value[%s]\tAddress[%p]  IndexAddr[%p]\n",
            v, &v, &five[i])
    }

Вывод:

    Value[Annie]     Address[0xc000010250]    IndexAddr[0xc000052180]
    Value[Betty]     Address[0xc000010250]    IndexAddr[0xc000052190]
    Value[Charley]   Address[0xc000010250]    IndexAddr[0xc0000521a0]
    Value[Doug]      Address[0xc000010250]    IndexAddr[0xc0000521b0]
    Value[Bill]      Address[0xc000010250]    IndexAddr[0xc0000521c0]

Здесь вы объявляете массив из 5 строк, инициализированный значениями. Затем, используя
итерацию с семантикой значений, отображаете информации о каждой строке. Вывод
показывает каждое индивидуальное строковое значение, адрес переменной v и адрес каждого
элемента массива.

Вы можете убедиться, что массив представляет собой непрерывный блок памяти, и строка -
это структура данных из двух слов или 16 байтов на 64-битной архитектуре. Адрес каждого
элемента находится на расстоянии 16 байт от предыдущего.

Тот факт, что переменная v имеет одинаковый адрес на каждой итерации, доказывает,
что v - это локальная переменная типа string, которая содержит копию значения каждой
строки во время итерации.

** Кэши ЦП

В конструкции различных процессоров существует множество отличий. В этом разделе мы,
с высоты птичьего полёта, поговорим о процессорах и семантике, которая относительно одинакова
между ними. Это понимание семантики даст вам хорошую картину того, как работает процессор,
и какую механическую симпатию вы можете использовать.

Каждое ядро внутри процессора имеет свой собственный локальный кэш памяти (L1 и L2) и общий кэш
памяти (L3), используемый для хранения и доступа к данным и инструкциям. Аппаратные потоки в
каждом ядре могут получать доступ к своим локальным кэшам L1 и L2. Данные из L3 или основной
памяти должны быть предварительно скопированы в кэш L1 или L2.

.image /tour/eng/static/img/a4.png

Задержки доступа к данным, которые находятся в разных кэшах, меняются от наименьших к
наибольшим: L1 -> L2 -> L3 -> основная память. Как сказал Скотт Мейерс: "Если производительность
имеет значение, то общее количество памяти в вашем распоряжении - это общее количество кэша.
Доступ к основной памяти так медленен, что её, фактически, можно не рассматривать."

Производительность сегодня зависит от того, насколько эффективно данные перемещаются через
аппаратуру. Если каждый фрагмент данных, нужный для работы (в любой момент времени),
существует только в основной памяти, мои программы будут выполняться медленнее по сравнению с тем,
когда данные уже присутствуют в кэшах L1 или L2.

    3 ГГц (3 такта/нс) * 4 инструкции за такт = 12 инструкций/нс!

    1 нс .............. 1 нс .............. 12 инструкций (одна)
    1 мкс ......... 1,000 нс .......... 12,000 инструкций (тысяча)
    1 мс ...... 1,000,000 нс ...... 12,000,000 инструкций (миллион)
    1 с ... 1,000,000,000 нс .. 12,000,000,000 инструкций (миллиард)

    Уровни задержек принятые в индустрии
    Ссылка L1-кэша ......................... 0,5 нс ...................  6 инс
    Ссылка L2-кэша ........................... 7 нс ................... 84 инс
    Ссылка на основную память .............. 100 нс ................. 1200 инс

Как написать код, который гарантирует, что данные, необходимые для выполнения инструкции,
всегда присутствуют в кэшах L1 или L2? Вам нужно написать код, который механически симпатичен
предварительной подгрузке данных процессора. Предварительная подгрузка данных пытается предсказать,
какие данные потребуются для инструкций, до того как они запросят данные, так чтобы они уже
присутствовали в кэшах L1 или L2.

Существуют разные гранулярности доступа к памяти в зависимости от того, где происходит доступ.
Мой код может читать/записывать байт памяти как минимальную единицу доступа к памяти. Однако с
точки зрения систем кэширования, гранулярность составляет 64 байта. Этот блок памяти в 64 байта
называется кэш-линией.

Предварительная подгрузка данных работает лучше, когда выполняемые инструкции создают предсказуемые
шаблоны доступа к памяти. Один из способов создания предсказуемого доступа к памяти - это создание
непрерывного блока памяти и последующая итерация по этой памяти, выполняя линейное обращение с
предсказуемым шагом.

Массив - это наиболее важная структура данных для аппаратуры, потому что он поддерживает
предсказуемые шаблоны доступа к памяти. Однако срез - наиболее важная структура данных в Go.
Срезы в Go построены на основании массивов.

После создания массива, каждый элемент равноудален от следующего или предыдущего элемента.
При итерации по массиву начинается обход кэш-линия за кэш-линией с предсказуемым шагом.
Предварительная подгрузка данных будет вылавливать этот предсказуемый шаблон доступа
к данным и начнет эффективно копировать данные в процессор, тем самым снижая задержку
доступа к данным.

Представьте себе большую квадратную матрицу памяти и связный список элементов, которые
соответствуют количеству элементов в матрице. Если вы выполняете обход связного списка,
а затем обход матрицы в обоих направлениях (по колонкам и строкам), какова будет
производительность разных способов обхода?

    func RowTraverse() int {
        var ctr int
        for row := 0; row < rows; row++ {
            for col := 0; col < cols; col++ {
                if matrix[row][col] == 0xFF {
                    ctr++
                }
            }
        }
        return ctr
    }

Обход строк будет иметь наилучшую производительность, потому что он проходит через память,
кэш-линия за кэш-линией, что создает предсказуемый шаблон доступа к памяти. Кэш-линии
могут быть предварительно загружены и скопированы в кэш L1 или L2, прежде чем данные потребуются.

    func ColumnTraverse() int {
        var ctr int
        for col := 0; col < cols; col++ {
            for row := 0; row < rows; row++ {
                if matrix[row][col] == 0xFF {
                    ctr++
                }
            }
        }
        return ctr
    }

Производительность при обходе по столбцам будет на порядок хуже, потому что этот шаблон доступа
пересекает границы страниц ОС при каждом доступе к памяти. Это предотвращает предварительную загрузку
кэш-линий и фактически приравнивается к случайному доступу к памяти.

    func LinkedListTraverse() int {
        var ctr int
        d := list
        for d != nil {
            if d.v == 0xFF {
                ctr++
            }
            d = d.p
        }
        return ctr
    }

Связный список вдвое медленнее по сравнению с обходом по строкам в основном из-за промахов
кэш-линий, но с меньшим числом промахов БДТ (буфер динамической трансляции). Большая часть узлов
в связном списке, находится в одних и тех же страницах операционной системы.

    BenchmarkLinkListTraverse-16    128      28738407 нс/оп
    BenchmarkColumnTraverse-16       30     126878630 нс/оп
    BenchmarkRowTraverse-16         310      11060883 нс/оп

** Буфер Динамической Трансляции (БДТ)

Каждой работающей программе предоставляется полная карта виртуальной памяти операционной системы, 
и эта работающая программа думает, что в её распоряжении находится вся физическая память компьютера.
Однако физическая память должна быть разделена между всеми работающими программами. Операционная система распределяет 
физическую память, посредством разделения физической памяти на страницы и сопоставления этих страниц с 
виртуальной памятью выделенной для каждой работающей программы. Каждая операционная система может 
выбирать размер страницы, но разумными и распространенными размерами являются 4K, 8K, 16K.

Буфер Динамической Трансляции (БДТ) - это небольшой кэш внутри процессора, который помогает уменьшить 
задержки при трансляции виртуального адреса в физический (в пределах страницы операционной системы
и смещения внутри страницы). Промах по кэшу БДТ может привести к существенным задержкам, потому что
теперь железо вынуждено ждать, пока операционная система просмотрит свою таблицу страниц, чтобы найти
нужную страницу для соответствующего виртуального адреса. Если программа работает на виртуальной 
машине (например в облаке), то сначала нужно просмотреть таблицу страниц виртуальной машины.

Помните, что было сказано:

Связный список вдвое медленнее, чем обход по строкам, в основном из-за промахов кэш-строк, 
но с меньшим числом промахов БДТ (смотри ниже). Большая часть узлов в связаном списке, находится
в одних и тех же страницах операционной системы.

Связный список обрабатывается на порядок быстрее столбцового обхода благодаря доступу к БДТ.
Поскольку большая часть памяти узлов попадает в одну и ту же страницу, даже несмотря на промахи
по кэш-линиям при обходе связного списка, задержки БДТ не сильно влияют на производительность.
По этой причине для программ, которые используют большое количество памяти, например, приложений
обрабатывающих ДНК, можно рассмотреть использование дистрибутива Linux, сконфигурированного под
размеры страниц порядка мегабайта или двух памяти.

Все сказанное подчеркивает важность дизайна ориентированного-на-данные. Написание эффективного
алгоритма должно учитывать, как происходит доступ к данным. Помните, что сегодня производительность
зависит от того, насколько эффективно вы можете передать данные в процессор.

- [[https://youtu.be/WDIkqP4JbkE?t=1129][Кэши процессора и почему они важны (18:50-20:30)]] - Скотт Майерс
- [[https://youtu.be/WDIkqP4JbkE?t=2676][Кэши процессора и почему они важны (44:36-45:40)]] - Скотт Майерс
- [[https://youtu.be/jEG4Qyo_4Bc?t=266][Производительность через дружелюбность к кэшу (4:25-5:48)]] - Дэмиан Гриски

** Заметки о кэше процессора

.html arrays/array_list.html

** Дополнительные диаграммы

*Задержки* *Принятые* *Индустрией*

    Ссылка на L1-кэш ........................................... 0,5 нс ................. 6 тактов
    Неправильное предсказание ветвления .......................... 5 нс ................ 60 тактов
    Ссылка на L2-кэш ............................................. 7 нс ................ 84 тактов
    Захват/освобождение мьютекса ................................ 25 нс ............... 300 тактов
    Ссылка на главную память ................................... 100 нс .............. 1200 тактов
    Сжатие 1К байт с помощью Zippy ........................... 3 000 нс (3 мкс) ....... 36K тактов
    Отправка 2К байт по сети 1 Гбит/с ....................... 20 000 нс (20 мкс) ..... 240K тактов
    Произвольное чтение с SSD .............................. 150 000 нс (150 мкс) .... 1,8M тактов
    Последовательное чтение 1 МБ из памяти ................. 250 000 нс (250 мкс) ...... 3M тактов
    Перемещение в одном и том же дата центре ............... 500 000 нс (0,5 мс) ....... 6M тактов
    Последовательное чтение 1 МБ с SSD- .................. 1 000 000 нс (1 мс) ........ 12M тактов
    Поиск на диске ...................................... 10 000 000 нс (10 мс) ...... 120M тактов
    Последовательное чтение 1 МБ с диска ................ 20 000 000 нс (20 мс) ...... 240M тактов
    Отправка пакета США->Нидерланды->США ............... 150 000 000 нс (150 мс) ..... 1,8B тактов

*Иллюстрация* *Латентности* *Кэша*

.image /tour/eng/static/img/cache_latencies_graph.png

** Дополнительные материалы

*Кэши* *ЦП* */* *Памяти*

- [[https://www.youtube.com/watch?v=WDIkqP4JbkE][Кэши процессора и почему они важны - Видео]] - Скотт Майерс
- [[https://www.youtube.com/watch?v=OFgxAFdxYAQ][Краткий курс современного оборудования - Видео]] - Клифф Клик
- [[http://frankdenneman.nl/2016/07/06/introduction-2016-numa-deep-dive-series/][Глубокий обзор NUMA]] - Фрэнк Деннеман
- [[http://www.aristeia.com/TalkNotes/codedive-CPUCachesHandouts.pdf][Кэши процессора и почему они важны - Презентация]] - Скотт Майерс
- [[https://www.youtube.com/watch?v=MC1EKLQ2Wmg][Раскроем мифы современного оборудования, чтобы достичь "механической симпатии"]] - Мартин Томпсон
- [[http://www.akkadia.org/drepper/cpumemory.pdf][Что каждый программист должен знать о памяти]] - Ульрих Дреппер
- [[http://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips][Как работают кэши процессора  и почему именно так]] - Джоэл Хруска
- [[http://www.lighterra.com/papers/modernmicroprocessors][90-минутный гид о современных микропроцессорах]] - Джейсон Роберт Карей Паттерсон
- [[http://lwn.net/Articles/252125][Часть 2: Кэши процессора]] - Ульрих Дреппер
- [[http://www.gotw.ca/publications/concurrency-ddj.htm][Бесплатные обеды закончились]] - Херб Саттер
- [[https://m.youtube.com/watch?feature=youtu.be&v=QBu2Ae8-8LM][Компьютеры в дата-центрах: современные сложности в проектировании ЦПУ]] - Дик Сайтс
- [[https://en.wikipedia.org/wiki/Wirth%27s_law][Закон Вирта]] - Википедия
- [[http://www.drdobbs.com/parallel/eliminate-false-sharing/217500206][Устранение ложного обмена]] - Херб Саттер
- [[http://www.ilikebigbits.com/2014_04_21_myth_of_ram_1.html][Миф о RAM]] - Эмиль Эрнерфельдт
- [[https://www.infoq.com/presentations/hardware-transactional-memory][Понимание аппаратной памяти с транзакциями]] - Гил Гин
- [[https://youtu.be/jEG4Qyo_4Bc?t=266][Производительность через дружелюбность кэшу (4:25-5:48)]] - Дэмиан Гриски
- [[https://www.youtube.com/watch?v=2EWejmkKlxs][Двигаясь быстрее в никуда]] - Чандлер Каррут

*Ориентированный-на-данные* *Дизайн*

- [[https://www.youtube.com/watch?v=rX0ItVEVjHc][Ориентированный-на-данные дизайн и C++]] - Майк Актон
- [[https://www.youtube.com/watch?v=fHNmRkzxHWs][Эффективность с алгоритмами, производительность со структурами данных]] - Чандлер Каррут
- [[https://www.youtube.com/watch?v=LrVi9LHP8Bk][Обуздать производительность]] - Клаус Игльбергер
- [[http://harmful.cat-v.org/software/OO_programming/_pdf/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf][Подводные камни ООП]] - Тони Альбрехт
- [[https://www.youtube.com/watch?v=YQs6IC-vgmo][Почему стоит избегать связных списков]] - Бьярне Страуструп
- [[http://gamesfromwithin.com/data-oriented-design][Ориентированный-на-данные дизайн (или почему ООП может навредить)]] - Ноэль
- [[https://www.quora.com/Was-object-oriented-programming-a-failure][Было ли объектно-ориентированное программирование ошибкой?]] - Quora

** Заметки

- Если вы не понимаете данные, вы не понимаете проблему.
- Если вы не понимаете стоимость решения проблемы, вы не можете рассуждать о проблеме.
- Если вы не понимаете аппаратное обеспечение, вы не можете рассуждать о стоимости решения проблемы.
- Массивы - это структуры данных фиксированной длины, которые не могут изменяться.
- Массивы разных размеров считаются разными типами.
- Память выделяется как непрерывный блок.
- Go даёт вам контроль над пространственной локальностью.

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1

Объявите массив из 5 строк, в котором каждый элемент инициализирован его нулевым значением.
Объявите второй массив из 5 строк и инициализируйте этот массив литеральными строковыми значениями.
Присвойте второй массив первому и выведите результаты первого массива. Выведите строковое значение
и адрес каждого элемента.

.play arrays/exercise1.go
.play arrays/answer1.go
