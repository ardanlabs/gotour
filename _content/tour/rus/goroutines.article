Горутины
Горутины - это функции, которые создаются и планируются для независимого выполнения планировщиком Go.

* Горутины

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Горутины - это функции, которые создаются и планируются для независимого выполнения
планировщиком Go. Планировщик Go отвечает за управление и
выполнение горутин.

** Обзор кода

- *Пример* *1:* Горутины и конкурентность
- *Пример* *2:* Переключение контекста горутины
- *Пример* *3:* Горутины и параллелизм

.play goroutines/example1.go
.play goroutines/example2.go
.play goroutines/example3.go

** Семантика планировщика

При запуске Go-программы среда выполнения Go спрашивает машину (виртуальную или физическую)
сколько потоков операционной системы может работать параллельно. Этот вопрос основывается на количестве
ядер, доступных программе. Для каждого потока, который может работать параллельно,
среда выполнения создает поток операционной системы (M) и прикрепляет его к структуре данных
которая представляет собой логический процессор (P) внутри программы. Эти P и M представляют собой
вычислительные мощности или контекст исполнения для выполнения программы Go.

Также создается начальная горутина (G) для управления выполнением инструкций
на выбранном M/P. Точно так же, как M управляет выполнением инструкций на аппаратном обеспечении,
G управляет выполнением инструкций на М. Это создает новый уровень
абстракции над операционной системой, но переносит управление выполнением на
уровень приложений.

.image /tour/eng/static/img/gor1.png

Поскольку планировщик Go располагается поверх планировщика операционной системы, важно
иметь некоторое семантическое представление о планировщике операционной системы и ограничениях,
которые он накладывает на планировщик Go и приложения.

Задача планировщика операционной системы - создавать иллюзию того, что несколько
частей работы выполняются одновременно. Даже если это физически
невозможно. Это требует некоторых компромиссов при проектировании планировщика. Прежде чем 
продолжить, важно дать определение некоторым словам.

*Работа:* Набор инструкций для выполнения в запущенном приложении. Это
выполняется потоками, и приложение может иметь от 1 до многих потоков.

*Поток:* Путь выполнения, который планируется и выполняется. Потоки отвечают
за выполнение инструкций на аппаратном оборудовании.

*Состояния* *Потока:* Поток может находиться в одном из трех состояний: Выполнение, Готовность к выполнению или
ожидание. Выполнение означает, что поток выполняет назначенные ему инструкции на
аппаратном уровне, для этого на M ставится G. Готовность к выполнению означает, что поток хочет получить время на
аппаратном обеспечении для выполнения назначенных ему инструкций и находится в очереди на выполнение.
Ожидание означает, что поток ждет чего-то, прежде чем сможет продолжить свою работу.
Ожидающие потоки не являются заботой планировщика.

*Конкурентность:* Это означает неопределенное выполнение вне очереди. Другими словами,
набор инструкций, который должен быть выполнен в указанном порядке, выполняется
в другом, неопределенном порядке, но полностью. Ключевым моментом является то, что результат выполнения
полного набора инструкций в любом неопределенном порядке дает один и тот же результат. Вы
скажете, что работа может выполняться параллельно, когда порядок ее выполнения не имеет значения,
пока вся работа завершена.

*Параллельность:* Это означает одновременное выполнение множества действий. Чтобы это стало возможным,
необходима возможность физического выполнения двух или более потоков операционной системы 
одновременно на аппаратном обеспечении.

*Работа,* *с* *Загрузкой* *CPU:* Это работа, которая не приводит к естественному переходу потока
в состояние ожидания. Вычисление чисел Фибоначчи будет считаться работой, которая загружает CPU. 

*Работа* *с* *Загрузкой *I/O:* Это работа, которая заставляет поток естественным образом переходить в состояние ожидания.
состояние ожидания. Получение данных с различных URL будет считаться работой, которая загружает I/O.

*Синхронизация:* Когда двум или более горутинам необходимо получить доступ к одному и тому же месту памяти
они должны быть синхронизированы и выполняться по очереди.
Если синхронизация не выполняется, и хотя бы одна горутина выполняет
запись, то может возникнуть гонка данных. Гонки данных являются причиной повреждения данных,
баги, которые трудно обнаружить.

*Оркестрация:* Когда двум или более горутинам нужно подать друг другу сигнал, с данными или
без данных, требуется механика оркестрации. Если оркестрация не происходит, 
гарантии одновременного выполнения и завершения работы будут упущены.
Это может привести к всевозможным ошибкам, связанным с повреждением данных.

Существует множество мелких деталей, связанных с семантикой планирования, чтобы познакомиться с ними подробнее
прочитайте три поста в главе 14, озаглавленной "Планирование в Go".

** Основы конкурентности

Начнем с базовой проблемы конкурентности, требующей оркестрации.

    func init() {
        runtime.GOMAXPROCS(1)
    }

Вызов `GOMAXPROCS` используется для выполнения Go-программы как однопоточной
Go-программы. Программа будет однопоточной имея один `P/M` для выполнения
всех горутин. Функция написана заглавными, потому что существует одноименная переменна окружения.
Вызов этой функции перезапишет переменную.

    g := runtime.GOMAXPROCS(0)

Эта функция важна, когда вы устанавливаете квоты на CPU для конфигурации контейнера.
При передаче 0 сообщается количество потоков, которые будет использовать программа Go. 
Вы должны убедиться, что это число соответствует числу потоков операционной системы, доступных в контейнерной среде. Если эти числа не совпадают, то выполнение программы на Go будет не таким эффективным. Возможно, вы захотите
использовать переменную среды или этот вызов для согласования.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        fmt.Println("Waiting To Finish")
        wg.Wait()

        fmt.Println("\nTerminating Program")
    }

Эта программа должна решить проблему оркестрации. Главная горутина не может позволить
главной функции вернуться, пока не будет гарантии, что две создаваемые горутины
завершат свою работу. `WaitGroup` - это идеальный инструмент для решения задач оркестрации
которые не требуют передачи данных между горутинами. Передача сигналов
здесь осуществляется через `API`, который позволяет горутине ждать, пока другие горутины
не пошлют сигнал о завершении работы.

В этом коде `WaitGroup` создается с нулевым значением, а затем сразу же
вызывается метод `Add`, чтобы установить `WaitGroup` как 2, что соответствует количеству
горутин, которые будут созданы. Когда вы заранее знаете, сколько горутин будет
, вам следует вызвать `Add` один раз. Если вы не знаете (например, в
потоковом сервисе), то вызов `Add(1)` вполне допустим.

В конце `main` находится вызов `Wait`. `Wait` удерживает главную горутину от преждевременного
возврата функции. По возврату `main`, программа Go завершается
с особой осторожностью. Вот почему управление оркестрацией с надлежащими
гарантиями очень важно. Вызов `Wait` будет блокироваться до тех пор, пока `WaitGroup` не обнулиться.

В середине программы создаются две горутины.

    func main() {
        . . .

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        . . .
    }

Функции-литералы объявляются и выполняются с помощью ключевого слова `go`. На
этом этапе вы указываете планировщику Go на необходимость одновременного выполнения этих функций.
Выполнять их в неопределенном порядке. Внутри реализации каждой горутины
находится вызов `Done`. Именно этот вызов уменьшает `WaitGroup` на 1. Как только оба
вызова `Done` будут выполнены, `WaitGroup` обнулится, и главная
горутина будет разблокирована после вызова `Wait`, что и завершит работу программы.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            wg.Done()
        }()

        . . .
    }

Важная часть данного шаблона оркестровки - держать вызовы `Add` и `Done`
на одной линии видимости. Старайтесь не передавать `WaitGroup` в качестве параметра функции
где вызов теряется. Это поможет уменьшить количество багов.

    Output:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    Terminating Program

Когда вы собираете и запускаете эту программу, вы видите, как происходит ее выполнение с конкурентностью.
Вторая созданная горутина была запланирована первой. Она успела завершить свою работу, а
затем была запущена вторая горутина. Обе они выполнили свою работу до завершения программы.
При выполнении этой программы в следующий раз нет никакой гарантии, что вы увидите тот же результат.
Единственная гарантия в этой программе - это то, что программа не завершится, пока
не завершатся обе горутины.

Даже если вы выполните эту программу 100 раз и увидите один и тот же результат, нет никаких гарантий.
что это произойдет снова. Эта вероятность существует, но она не гарантирована,
особенно на разных версиях операционной системы как и на разных архитектурах.

    func main() {
        . . .

        fmt.Println("Waiting To Finish")
        // wg.Wait()                           <-- CHANGED

        fmt.Println("\nTerminating Program")
    }

Если вы закомментируете вызов `Wait`, что произойдет при выполнении этой программы? Как только
Опять же, нет никакой гарантии, что произойдет, но есть
разные вероятности.

Программа может вести себя как прежде, поскольку вызов `Println` - это системный вызов,
который позволяет планировщику выполнить переключение контекста. Программа может выполнить только
одну из двух горутин или, завершиться немедленно.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            // wg.Done()               <-- CHANGED
        }()

        . . .
    }

Что произойдет, если вы забудете вызвать `Done` в одной из горутин? В этом случае
программа зайдет в тупик, поскольку группа `WaitGroup` не сможет обнулиться и
заблокируется навсегда.

    Output:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    fatal error: all goroutines are asleep - deadlock!

    goroutine 1 [semacquire]:
    sync.runtime_Semacquire(0xc00001a0a8)
        /usr/local/go/src/runtime/sema.go:56 +0x45
    sync.(*WaitGroup).Wait(0xc00001a0a0)
        /usr/local/go/src/sync/waitgroup.go:130 +0x65
    main.main()
        concurrency/goroutines/example1/example1.go:42 +0x145
    exit status 2

Вы можете видеть, как среда выполнения Go определяет, что программа зашла в тупик, в строке 42, где
 происходит вызов `Wait`. Не стоит слишком увлекаться обнаружением тупиков
поскольку каждая горутина должна быть заблокирована без возможности выхода. Это показывает, почему
вызывать `Add` и `Done` вместе очень важно.

    func main() {
        var wg sync.WaitGroup
        wg.Add(1)              <-- CHANGED, Number Too Small

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        . . .
    }

Что произойдет, если не задать `WaitGroup` правильное количество горутин для ожидания? Если число будет слишком большим, вы снова окажетесь в тупике. Если число
слишком мало, то нет никаких гарантий, что работа будет выполнена до того, как программа перейдет
дальше. Выход программы не определен.

** Вытесняющий планировщик

Несмотря на выполнение планировщика в рамках приложения, важно понять что он вытесняющий.
Это означает, что вы не можете предсказать, когда произойдет переключение контекста
и оно будет меняться при каждом выполнении программы.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            printHashes("A")
            wg.Done()
        }()

        go func() {
            printHashes("B")
            wg.Done()
        }()

        fmt.Println("Waiting To Finish")
        wg.Wait()

        fmt.Println("\nTerminating Program")
    }

Используя ту же схему оркестрации, что и раньше, эта программа заставляет каждую горутину выполнять
гораздо больше работы. Работы, которую планировщик не даст горутине достаточно времени, чтобы завершить
полностью за один временной цикл.

    func printHashes(prefix string) {
        for i := 1; i <= 50000; i++ {
            num := strconv.Itoa(i)
            sum := sha1.Sum([]byte(num))
            fmt.Printf("%s: %05d: %x\n", prefix, i, sum)
        }
        fmt.Println("Completed", prefix)
    }

Эта функция в значительной мере загружает `I/O`, который может увеличить 
переключения контекста.

    $ ./example2 | cut -c1 | grep '[AB]' | uniq
    B
    A
    B
    A
    B
    A
    B
    A
    B
    A  9 Context Switches

    $ ./example2 | cut -c1 | grep '[AB]' | uniq
    B
    A
    B
    A  3 Context Switches

Как видите, при каждом выполнении программы происходит разное количество
переключений контекста. Это очень хорошо, потому что планировщик не должен быть предсказуемым.
Конкурентность должна оставаться неопределенной, и вы должны помнить об этом, когда используете ее
для решения проблем производительности.

    func init() {
        runtime.GOMAXPROCS(2)
    }

Что произойдет, если вернуться к исходной программе, но изменить GOMAXPROCS так, чтобы программа выполнялась как двухпоточная Go-программа?

    Output:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N a b c d e f g h i j k l m n o O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    Terminating Program

Вы видите, что теперь конкурентность программы стала более мелкой, результат
же, так и остался неопределенным и неупорядоченным.

** Примечания

- Горутины - это функции, которые планируются для выполнения независимо друг от друга.
- Мы должны всегда вести учет выполнения горутин и аккуратно завершать работу.
- Конкурентность - это не параллелизм.

- Конкурентность - это работа с большим количеством вещей одновременно.
- Параллелизм - это выполнение множества действий одновременно.

"Параллелизм - это физическое выполнение двух или более действий одновременно. Конкурентность - это неопределенное, неупорядоченное выполнение". - Уильям Кеннеди

"По умолчанию горутины не должны жить дольше, чем функция, на основе которой они были созданы. Это заставляет вас принимать чрезвычайно правильную позицию при проектировании". - Питер Бургон

** Руководство по проектированию

- Ознакомьтесь с [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#concurrent-software-design][руководством по проектированию]] для конкурентности.

** Дополнительное чтение

- [[https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html][Scheduling In Go - Part I]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html][Scheduling In Go - Part II]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html][Scheduler Tracing In Go]] - William Kennedy   
- [[https://blog.golang.org/advanced-go-concurrency-patterns][Advanced Go Concurrency Patterns]] - Sameer Ajmani    
- [[https://blog.golang.org/context][Go Concurrency Patterns: Context]] - Sameer Ajmani    
- [[https://blog.golang.org/concurrency-is-not-parallelism][Concurrency is not parallelism]] - Rob Pike    
- [[https://talks.golang.org/2013/distsys.slide][Go, for Distributed Systems]] - Russ Cox    
- [[https://docs.google.com/document/d/1At2Ls5_fhJQ59kDK2DFVhFu3g5mATSXqqV5QrxinasI/edit][Go 1.5 GOMAXPROCS Default]]    
- [[https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html][Concurrency, Goroutines and GOMAXPROCS]] - William Kennedy    
- [[http://www.ece.ubc.ca/~sasha/papers/eurosys16-final29.pdf][The Linux Scheduler: a Decade of Wasted Cores]]    
- [[https://news.ycombinator.com/item?id=12460807][Explanation of the Scheduler]]    
- [[http://joeduffyblog.com/2016/11/30/15-years-of-concurrency/][15 Years of Concurrency]] - Joe Duffy    
- [[https://www.quora.com/How-does-the-golang-scheduler-work/answer/Ian-Lance-Taylor][How does the golang scheduler work?]] - Ian Lance Taylor    
- [[https://www.youtube.com/watch?v=YHRO5WQGh0k][The Scheduler Saga]] - Kavya Joshi    

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Приведены возможные решения.

** Упражнение 1

*Часть* *A* Создайте программу, в которой объявлены две анонимные функции. Одна из них отсчитывает
от 100 до 0 вниз, а другая - от 0 до 100 вверх. Выведите на экран каждое число с
уникальным идентификатором каждой горутины. Затем создайте горутины из этих функций
и не позволяйте main завершиться, пока горутины не будут выполнены.

*Часть* *B* Выполнение программы параллельно.

.play goroutines/exercise1.go
.play goroutines/answer1.go
