Загрязнение интерфейсами
Загрязнение интерфейсами возникает из-за того, что люди проектируют программное обеспечение с использованием интерфейсов, вместо того чтобы обнаруживать их.

* Загрязнение интерфейсами

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Загрязнение интерфейсами возникает из-за того, что люди проектируют программное обеспечение
с использованием интерфейсов, вместо того чтобы обнаруживать их.

** Обзор Кода

- *Пример* *1:* Создание загрязнения интерфейсами
- *Пример* *2:* Устранение загрязнения интерфейсами

.play composition/pollution/example1.go
.play composition/pollution/example2.go

** Загрязнение Интерфейсами

Загрязнение интерфейсами возникает из-за того, что люди проектируют программное обеспечение с использованием
интерфейсов, вместо того чтобы обнаруживать их. Сначала следует разработать конкретное решение для проблемы.
Затем вы можете определить, где программа должна быть полиморфной, если это вообще необходимо.

Вот что я слышал от других разработчиков.

"Я использую интерфейсы, потому что нам нужно использовать интерфейсы".

Нет. Мы не обязаны использовать интерфейсы. Мы используем интерфейсы, когда это практично и разумно.
У использования интерфейсов есть цена: уровень косвенности и выделение при хранении конкретных значений
внутри них. Если стоимость выделения не соответствует выгоде получаемой от разделения, вы не должны
использовать интерфейсы.

"Мне нужно иметь возможность тестировать свой код, поэтому мне нужно использовать интерфейсы".

Нет. В первую очередь вы должны проектировать свой API для пользователя, а не для моего теста.
Если API нельзя протестировать, следует подвергнуть сомнению его использование. Существуют различные
уровни API. На более низком уровне непубличные API могут и должны сосредотачиваться на тестировании.
Высокоуровневые публичные API должны сосредотачиваться на удобстве использования.

Функции, принимающие входные данные в чистом виде и возвращающие результирующие данные, являются
наиболее тестируемыми. Отделите преобразование данных от того, откуда берутся данные, и куда они
направляются. Это упражнение по рефакторингу, которое следует выполнять во время цикла инженерной
разработки.

Ниже приведен пример, который создает загрязнение интерфейсами по причине использования интерфейса тогда,
когда в нём нет необходимости.

    type Server interface {
        Start() error
        Stop() error
        Wait() error
    }

Интерфейс Server определяет контракт для серверов TCP. Проблема здесь в том, что мне не нужен
контракт, вам нужна реализация. Будет только одна реализация, особенно если вы ее реализуете сами.
Вам не нужно, чтобы кто-то еще реализовал это за вас.

Плюс, этот интерфейс основан на существительном, а не на глаголе. Конкретные типы - это
существительные, поскольку они представляют конкретную проблему. Интерфейсы описывают поведение,
и Server - это не поведение.

Вот несколько способов выявления загрязнения интерфейсами:

- Пакет объявляет интерфейс, который соответствует всему API его собственного конкретного типа.
- Интерфейсы экспортируются, но конкретные типы, реализующие интерфейс, являются непубличными.
- Фабричная функция для конкретного типа возвращает значение интерфейса с внутренним значением непубличного конкретного типа.
- Интерфейс можно удалить, и для пользователя API ничего не изменится.
- Интерфейс не разделяет API от изменений.

Рекомендации по загрязнению интерфейсами:

Используйте интерфейсы:

- Когда пользователи API должны предоставить детали реализации.
- Когда у API есть несколько реализаций, которые требуется поддерживать.
- Когда части API, которые могут изменяться, были выделены и требуют разделения.

Подвергайте сомнению использование интерфейса:

- Когда его единственная цель - создание тестируемых API (сначала создавайте удобные API).
- Когда он не обеспечивает поддержку API для отделения от изменений.
- Когда не ясно, как интерфейс улучшает код.
