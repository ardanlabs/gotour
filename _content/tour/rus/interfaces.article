Интерфейсы
Интерфейсы придают программам структуру и поощряют дизайн на основе композиции.

* Интерфейсы

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Интерфейсы придают программам структуру и поощряют дизайн на основе композиции. Они дают возможность
провести аккуратную разделительную черту между различными компонентами. Стандартизация интерфейсов
позволяет объявлять чёткие структурированные ожидания. Разделение ведёт к уменьшению взаимозависимостей
между компонентами и типами данных, которые эти компоненты используют. Это ведёт к корректности, 
повышению качества и улучшению поддерживаемости ПО.

** Обзор кода

- *Пример* *1:* Повторяющийся код, требующий полиморфизма
- *Пример* *2:* Полиморфизм
- *Пример* *3:* Наборы методов
- *Пример* *4:* Адрес значения
- *Пример* *5:* Хранение по значению
- *Пример* *6:* Декларации типов
- *Пример* *7:* Условные декларации типов
- *Пример* *8:* Пустой интерфейс и выбор типа
- *Пример* *9:* Хранение значений

.play interfaces/example1.go
.play interfaces/example2.go
.play interfaces/example3.go
.play interfaces/example4.go
.play interfaces/example5.go
.play interfaces/example6.go
.play interfaces/example7.go
.play interfaces/example8.go
.play interfaces/example9.go

** Семантика интерфейса

Интерфейсы позволяют группировать конкретные данные вместе по тому общему, что эти данные могут делать. Т.е. мы
фокусируемся на том, что данные могут делать, а не на том, что это данные из себя
представляют. Интерфейсы также помогают снизить связанность кода, работая с данными
на основе того что они могут делать. Это не ограничивается одним единственным типом данных.

Вам нужно постараться понять, какие ожидаются изменения данных, и с помощью интерфейсов
снизить связанность программного код с этими изменений. Интерфейсы должны описывать поведение,
а не состояние. Они должны быть глаголами, а не существительными.

Наилучший выбор - это обобщённые интерфейсы, которые фокусируются на поведении. Интерфейсы с
более чем одним методом имеют больше причин для изменения. Интерфейсы, основанные на существительных,
обычно сложнее использовать повторно, они больше подвержены изменениям и противоречат основному
назначению интерфейсов. Неопределенность в части ожидаемых изменений - это не повод строить догадки,
а указатель на необходимость остановиться и узнать больше. Вам следует различать код защищающий
от мошенничества, и код, защищающий от несчастных случаев.

Используйте интерфейс, когда:

- Пользователи API должны предоставить подробности реализации.
- У API есть несколько реализаций, которые необходимо поддерживать внутренее.
- Вы обнаружили части API, которые могут измениться, и хотите их развязать.

Не используйте интерфейс:

- Просто ради использования интерфейса.
- Для обобщения алгоритма.
- Когда пользователи могут объявить свои собственные интерфейсы.
- Если не ясно, как интерфейс улучшает код.

** Интерфейсы не работают со значениям

Первый важный момент который необходимо понять - это то, что интерфейсы объявляют тип, который не работает со значением.

    type reader interface {
        read(b []byte) (int, error)
    }

Тип reader  является не типом struct, а типом interface. Его объявление основано не на состоянии,
а на поведении. Интерфейсы объявляют набор методов поведения, которое конкретные данные должны
продемонстрировать для удовлетворения интерфейса. В типах interface нет ничего конкретного,
поэтому они сами по себе не работают со значениями.

    var r reader

Поскольку они не работают со значениями, создание переменной (такой как r) несколько необычно, потому что в нашей
модели программирования r не существует, она не представляет собой значение. В r нет ничего, чем вы
можете манипулировать или преобразовать. Это критическая концепция, которую следует понять.
Я никогда не работаю со значениями интерфейса, только с конкретными значениями.
Интерфейс имеет представление для компилятора (внутренний тип), но с точки зрения нашей
модели программирования интерфейсы не содержат значения.

** Реализация интерфейсов

Go - это язык, в котором конвенции более важны чем конфигурация. Это остаётся верным и в случае
когда конкретный тип реализует интерфейс.

    type reader interface {
        read(b []byte) (int, error)
    }
    
    type file struct {
        name string
    }
    
    func (file) read(b []byte) (int, error) {
        s := "<rss><channel><title>Going Go</title></channel></rss>"
        copy(b, s)
        return len(s), nil
    }

Этот код объявляет тип с именем file, а затем объявляет метод с именем read.
На основе этих двух объявлений можно сказать следующее:

"Теперь конкретный тип file реализует интерфейс reader с использованием семантики значения"

Каждое сказанное выше слово важно. В Go все, что вам нужно сделать - это объявить полный
набор методов поведения, определенных интерфейсом, чтобы реализовать этот интерфейс.
В данном случае именно это я сделал, так как интерфейс reader объявляет только
одно действие поведения с именем read.
    
    type reader interface {
        read(b []byte) (int, error)
    }
    
    type pipe struct {
        name string
    }
    
    func (pipe) read(b []byte) (int, error) {
        s := `{name: "Bill", title: "developer"}`
        copy(b, s)
        return len(s), nil
    }

Этот код объявляет тип с именем pipe, а затем объявляет метод с именем read.
Основываясь на этих двух объявлениях можно сказать следующее:

"Теперь конкретный тип pipe реализует интерфейс reader с использованием семантики значения"

Теперь у вас есть два конкретных типа, реализующих интерфейс reader. Два конкретных
типа, каждый со своей уникальной реализацией. Один тип читает файловые системы, а
другой - сети.

** Полиморфизм

Полиморфизм означает, что фрагмент кода изменяет свое поведение в зависимости от
конкретных данных, с которыми он работает. Это было сказано Томом Курцем, изобретателем
BASIC. Это определение мы будем использовать впредь.
    
    // retrieve может читать любое устройство и обрабатывать данные.
    func retrieve(r reader) error {
        data := make([]byte, 100)
    
        len, err := r.read(data)
        if err != nil {
            return err
        }
    
        fmt.Println(string(data[:len]))
        return nil
    }

Посмотрите на тип данных, который принимает эта функция. Она ожидает значение типа reader.
Это невозможно, так как reader - это интерфейс, а интерфейсы - это типы не содержащие данных.
Невозможно запросить значения reader, так как его не существует.

Если функция не запрашивает значения reader, то что она запрашивает?
Она запрашивает единственное, что она может запросить - конкретные данные.

Функция retrieve - полиморфная функция, потому что она запрашивает конкретные
данные не на основе того, что это за данные (конкретный тип), а на основе того,
что эти данные могут делать (тип интерфейса).

    f := file{"data.json"}
    p := pipe{"cfg_service"}
    
    retrieve(f)
    retrieve(p)

Мы можем создать два конкретных значения, одно типа file, а другое - типа pipe.
Затем можно передать копию каждого значения в полиморфную функцию. Это возможно,
поскольку каждое из этих значений реализует полный набор методов поведения,
определенных интерфейсом reader.

Когда конкретное значение file передается в retrieve, значение сохраняется во внутреннем типе
состоящем из 2х слов и представляющем значением интерфейса.

.image /tour/rus/static/img/i1.png

Второе слово интерфейса указывает на хранимое значение. В данном случае
это копия значения file, поскольку используются семантики значения. Первое слово
указывает на особую структуру данных, которая называется iTable.

iTable выполняет 2 функции:

- Она описывает тип хранимого значения. В нашем случае это значение file.
- Она даёт доступ к указателям на набор методов реализованные для типа хранимого значения.

Когда вызывается метод read для значения интерфейса, выполняется поиск по iTable,
чтобы найти конкретную реализацию метода read, связанную с типом. Затем вызывается
метод принадлежащий значению, хранящемуся во втором слове.

Можно сказать, что retrieve - это полиморфная функция, потому что конкретное
значение pipe может быть передано в retrieve, после чего вызов метода read для
значения интерфейса изменяет свое поведение. Теперь вызов read читает сеть
вместо чтения файла.

** Правила набора методов

Реализация интерфейса с использованием семантики указателя накладывает некоторые
требования связанные с соблюдением интерфейса.

    type notifier interface {
        notify()
    }

    type user struct {
        name  string
        email string
    }

    func (u *user) notify() {
        fmt.Printf("Sending User Email To %s<%s>\n", u.name, u.email)
    }

    func sendNotification(n notifier) {
        n.notify()
    }

    func main() {
        u := user{"Bill", "bill@email.com"}
        sendNotification(u)
    }

Интерфейс "notifier" реализован типом "user" с использованием семантики указателя.
Когда для создания полиморфного вызова используются семантики значения, компилятор
выдает следующее сообщение об ошибке:

        "cannot use u (type user) as type notifier in argument to sendNotification:
        user does not implement notifier (notify method has pointer receiver)"

Это связано с тем, что в спецификации есть особые правила относительно наборов методов.
Эти правила определяют, какие методы присоединены к значениям, а какие - к указателям типа,
и они существуют для поддержания высшего уровня целостности в программе.

Вот правила, определенные в спецификации:

- Для любого *значения* типа T в набор методов этого значения входят только те методы, которые реализованы с *получаетелем-значением* для этого типа.
- Для любого *адреса* типа T в набор методов этого значения входят *все методы*, реализованные для этого типа.

Другими словами, при работе с адресом (указателем) все реализованные методы присоединены
и доступны для вызова. При работе со значением присоединены и доступны только те методы,
которые реализованы с получателем-значением.

В предыдущем уроке о методах мы могли вызывать метод для конкретных данных, независимо
от семантики данных, объявленной получателем. Это потому, что компилятор может
адаптироваться для выполнения вызова. В этом случае значение хранится внутри интерфейса,
и методы должны существовать. Никаких адаптаций делать нельзя.

Теперь встает вопрос: почему нельзя присоединять методы с получателем-указателем к значениям
типа T? В чем заключается проблема с целостностью?

Одна из причин заключается в том, что нельзя гарантировать, что каждое значение типа T
будет иметь адрес. Если у значения нет адреса, его нельзя передавать по ссылке.

    type duration int

    func (d *duration) notify() {
            fmt.Println("Sending Notification in", *d)
    }

    func main() {
        duration(42).notify()
    }

Ошибка компилятора:

    cannot call pointer method on duration(42)
    cannot take the address of duration(42)

В этом примере значение 42 является константой типа int. Несмотря на то, что
значение преобразуется в значение типа duration, оно не хранится в переменной.
Это означает, что значение никогда не находится в стеке или куче, и у него
нет адреса. Константы существуют только на этапе компиляции.

Вторая причина - ещё более важная. Компилятор говорит вам, что вы не можете
использовать семантику значения, если вы выбрали семантику указателя. Другими 
словами, вас заставляют совместно использовать значение с интерфейсом, поскольку 
создать копию значения, на которое указывает указатель, не безопасно. Если вы выбрали 
реализацию метода с семантикой указателя, вы показываете, что значение этого типа 
не безопасно копировать.

    func main() {
        u := user{"Bill", "bill@email.com"}
        sendNotification(&u)
    }

Чтобы устранить сообщение компилятора, необходимо при вызове полиморфной функции 
использовать семантику указателя и передавать указатель на u. Ответ не заключается
в изменении метода для использования семантики значения.

** Срез Интерфейсов

При объявлении среза типа interface мы можем группировать разные конкретные значения
основываясь на их поведении. Вот почему в Go не нужна концепция подтипов.
Речь идет не об общем ДНК, а об общем поведении.

    type printer interface {
        print()
    }

    type canon struct {
        name string
    }

    func (c canon) print() {
            fmt.Printf("Printer Name: %s\n", c.name)
    }

    type epson struct {
        name string
    }

    func (e *epson) print() {
            fmt.Printf("Printer Name: %s\n", e.name)
    }

    func main() {
        c := canon{"PIXMA TR4520"}
        e := epson{"WorkForce Pro WF-3720"}

            printers := []printer{
            c,
            &e,
        }
        c.name = "PROGRAF PRO-1000"
        e.name = "Home XP-4100"

            for _, p := range printers {
            p.print()
        }
    }

Output:

    Printer Name: PIXMA TR4520
    Printer Name: Home XP-4100

Код показывает, как срез интерфейсного типа printer позволяет создавать
коллекцию различных конкретных типов printer. Это позволяет итерировать
по коллекции и использовать полиморфизм, так как вызов p.print меняет
свое поведение в зависимости от конкретного значения, с которым работает код.

Пример также показывает, как выбор семантики данных изменяет поведение программы.
При хранении данных с использованием семантики значения, изменения в исходном
значении не видны. Это потому, что копия сохраняется внутри интерфейса.
При использовании семантики указателя любые изменения в исходном значении видны.

** Заметки

- Набор методов для значения включает только методы, реализованные с получателем-значением.
- Набор методов для указателя включает методы, реализованные как с получателем-указателем, так и с получателем-значением.
- Методы, объявленные с получателем-указателем, реализуют интерфейс только с указателями.
- Методы, объявленные с получателем-значением, реализуют интерфейс как с получателем-значением, так и с получателем-указателем.
- Правила наборов методов применяются к интерфейсам.
- Интерфейсы - это ссылочные типы, не используйте указатели на них.
- Интерфейсы - это то, каким образом создаётся полиморфное поведение в Go.

** Цитаты

"Полиморфизм означает, что вы пишете определённую программу, и она ведет себя по-разному в зависимости от данных, с которыми она работает." - Том Курц (изобретатель BASIC)

"Пустой интерфейс не говорит ни о чем." - Роб Пайк

"Проектирование - это искусство устройства кода таким, чтобы он работал сегодня и был изменяемым навсегда." - Санди Метц

"Правильная абстракция развязывает код, чтобы каждое изменение не разносилось эхом по всей кодовой базе." - Ронна Штейнберг

** Дополнительное чтение

- [[https://golang.org/doc/effective_go.html#interfaces][Интерфейсы]]
- [[https://blog.golang.org/laws-of-reflection][Законы рефлексии]] - Роб Пайк
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Методы, интерфейсы и встроенные типы Go]] - Уильям Кеннеди
- [[https://rakyll.org/interface-pollution/][Загрязнение интерфейсов]] - JBD
- [[https://bravenewgeek.com/abstraction-considered-harmful/][Абстракции считаются вредными]] - Тайлер Трит
- [[https://www.ardanlabs.com/blog/2018/03/interface-values-are-valueless.html][Интерфейсы не содержат значений]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2017/07/interface-semantics.html][Семантика интерфейса]] - Уильям Кеннеди
- [[https://www.hyrumslaw.com/][Закон Хайрума]] - Хайрум
- [[https://www.youtube.com/watch?v=Pjz9WrXeOW0][Инженерное нововведение - почему ограничения критичны]] - Андре Эрикссон (ОБЯЗАТЕЛЬНО ПОСМОТРИТЕ)

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1

*Часть* *A:* Объявите интерфейс с именем speaker и методом с именем speak. Объявите структуру
с именем english, представляющую человека, говорящего на английском, и структуру с именем
chinese для человека, говорящего на китайском. Реализуйте интерфейс speaker для каждой структуры,
используя получатель-значение, и следующие литеральные строки: "Hello World" и "你好世界".
Объявите переменную типа speaker и присвойте ей адрес значения типа english, а затем вызовите метод.
Повторите это для значения типа chinese.

*Часть* *B:* Добавьте новую функцию с именем sayHello, принимающую значение типа speaker.
Реализуйте эту функцию для вызова метода speak на значении интерфейса. Затем создайте новые
значения каждого типа и используйте эту функцию.

.play interfaces/exercise1.go
.play interfaces/answer1.go
