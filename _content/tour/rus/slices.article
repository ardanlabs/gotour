Срезы
Срезы (слайсы) - чрезвычайно важная структура данных в Go. Они лежат в основе гибкого, эффективного и динамичного управления и манипулирования данными. Всем программистам Go очень полезно знать, как работают срезы и как ими пользоваться.

* Срезы

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Срезы - чрезвычайно важная структура данных в Go. Они лежат в основе гибкого, эффективного и
динамичного управления и манипулирования данными. Всем программистам Go очень полезно знать,
как работают срезы и как ими пользоваться.

.image /tour/rus/static/img/sl1.png

** Обзор кода

- *Пример* *1:* Объявление и Длина
- *Пример* *2:* Типы ссылок
- *Пример* *3:* Добавление к срезам
- *Пример* *4:* Создание срезов из срезов
- *Пример* *5:* Срезы и ссылки
- *Пример* *6:* Строки и срезы
- *Пример* *7:* Функции с переменным числом параметров
- *Пример* *8:* Механика функции `range`
- *Пример* *9:* Эффективные Обходы
- *Пример* *10:* Трёх-индексовые срезы

.play slices/example1.go
.play slices/example2.go
.play slices/example3.go
.play slices/example4.go
.play slices/example5.go
.play slices/example6.go
.play slices/example7.go
.play slices/example8.go
.play slices/example9.go
.play slices/example10.go

** Создание среза

Создание среза можно выполнить несколькими способами.

    // Срез строк, установленный в состояние нулевого значения.
    var slice []string

    // Пустой срез строк.
    slice := []string{}

    // Срез строк длиной и ёмкостью 5.
    slice := make([]string, 5)

    // Срез строк, длиной 5 и ёмкостью 8.
    slice := make([]string, 5, 8)

    // Срез строк со значениями - длиной и ёмкостью 5.
    slice := []string{"A", "B", "C", "D", "E"}

Как вы видите, встроенная функция make позволяет предварительно выделить как длину,
так и ёмкость базового массива. Если компилятор знает размер на этапе компиляции,
базовый массив может быть создан в стеке.

** Длина среза по сравнению с ёмкостью

Длина среза представляет количество элементов, которые можно читать и записывать.
Ёмкость представляет общее количество элементов, которые существуют в базовом массиве
с определённой позиции указателя.

Благодаря синтаксическому сахару срезы выглядят и ощущаются как массивы.

    slice := make([]string, 5)
    slice[0] = "Яблоко"
    slice[1] = "Апельсин"
    slice[2] = "Банан"
    slice[3] = "Виноград"
    slice[4] = "Слива"

Вы можете отличить конструкцию среза и массива, так как размер массива
должен быть известен на этапе компиляции, в то время как для срезов это не обязательно.

Если вы попытаетесь получить доступ к элементу за пределами длины среза,
вы получите ошибку времени выполнения.

    slice := make([]string, 5)
    slice[5] = "Raspberry"

Ошибка компилятора:

    Error: panic: runtime error: index out of range slice[5] = "Runtime error"

В этом примере длина среза составляет 5, и я пытаюсь получить доступ к 6-му элементу,
который не существует.

** Семантическое руководство по данным для срезов

В качестве руководства, если данные, с которыми вы работаете, являются срезом, то используйте
семантику значений для перемещения данных внутри программы. Это включает объявление полей в структурах.

    func Foo(data []byte) []byte

    type Foo struct {
        X []int
        Y []string
        Z []bool
    }

Это относится ко всем внутренним структурам данных Go (срезам, картам, каналам, интерфейсам и функциям).

Одна из причин перехода к семантике указателей - это необходимость передачи среза для декодирования
или десериализации. Использование указателей для этих типов операций допустимо, но если это не очевидно,
то такие вещи необходимо документировать.

** Смежная структура памяти

Идея среза заключается в использовании массива, который является наиболее эффективной структурой данных
с точки зрения аппаратного обеспечения. Однако вам нужно сохранять динамичность и эффективность,
учитывая количество обрабатываемых данных и принимая во внимание будущий рост.

    func main() {
        slice := make([]string, 5, 8)
        slice[0] = "Apple"
        slice[1] = "Orange"
        slice[2] = "Banana"
        slice[3] = "Grape"
        slice[4] = "Plum"

        inspectSlice(slice)
    }

    func inspectSlice(slice []string) {
        fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
        for i := range slice {
            fmt.Printf("[%d] %p %s\n", i, &slice[i], slice[i])
        }
    }

Вывод:

    Length[5] Capacity[8]
    [0] 0xc00007e000 Apple
    [1] 0xc00007e010 Orange
    [2] 0xc00007e020 Banana
    [3] 0xc00007e030 Grape
    [4] 0xc00007e040 Plum

Функция inspectSlice показывает, что у среза есть базовый массив с предсказуемым
шагом. Она также показывает, что длина и ёмкость среза могут быть разными.
Обратите внимание, как функция печати проходит только по длине среза.

** Добавление к срезам

Язык Go предоставляет встроенную функцию под названием append для добавления значений
к существующему срезу.

    var data []string

    for record := 1; record <= 102400; record++ {
        data = append(data, fmt.Sprintf("Rec: %d", record))
    }

Функция append работает со срезом, даже когда срез инициализирован в нулевое состояние.
Интересным является дизайн API append, потому что для мутации он использует семантику значений.
Append получает копию значения среза, он модифицирует свою собственную копию,
а затем возвращает эту копию вызывающей стороне.

Почему API разработан таким образом? Это потому, что идиома состоит в использовании семантики
значений для передвижения значения среза внутри программы. Это необходимо иметь в виду
даже при операции мутации. Кроме того, семантика мутации значений является самым безопасным
способом выполнения мутации, поскольку мутация выполняется на собственной копии данных в рамках функции.

Append всегда сохраняет непрерывный блок памяти для базового массива среза, даже после увеличения.
Это важно для аппаратного обеспечения.

.image /tour/rus/static/img/sl2.png

Каждый раз, когда вызывается функция append, функция проверяет, совпадают длина и ёмкость среза
или нет. Если они одинаковы, это означает, что для нового значения нет места в базовом массиве.
В этом случае append создает новый базовый массив (удваивая или увеличивая на 25%), а затем
копирует значения из старого в новый. После этого новое значение может быть добавлено.

.image /tour/rus/static/img/sl3.png

Если они не совпадают, это означает, что в массиве есть достаточно ёмкости для добавления
дополнительного элемента. Одно место из резервной ёмкости используется для добавления значения
к длине среза. Это делает операцию append очень эффективной.

Пока ёмкость базового массива не превышает 1024 элементов, новые базовые массивы конструируются,
удваивая размер существующего массива. После того как базовый массив превысит 1024 элемента,
увеличение происходит на 25%.

*ЗАМЕЧАНИЕ:* *То* *как* *функция* *append* *изменяет* *ёмкость* *исходного* *массива,*
*изменилось* *с* *версии* *Go* *1.18.*

- [[https://tip.golang.org/doc/go1.18#runtime][https://tip.golang.org/doc/go1.18#runtime]]

** Создание срезов из срезов

Срезы дают возможность избежать дополнительного копирования и выделения памяти
для основного массива,  когда нужно выделить определенные элементы основного массива
для различных операций.

Синтаксис срезов можно записать следующим образом [a:b), что означает включить элементы
с индекса a до b, но не включая b.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]

Переменная slice2 - это новое значение среза, которое сейчас разделяет тот же исходный
массив, что и slice1. Однако slice2 позволяет обращаться только к элементам с индексами
2 и 3 (C и D) исходного массива среза. Длина slice2 равна 2, а не 5, как в slice1, а
ёмкость равна 3, так как сейчас есть 3 элемента с этой позиции указателя.

.image /tour/rus/static/img/sl4.png

Лучше всего думать о срезе, фокусируясь на длине с помощью следующей нотации
[a:a+len] - индекс `a` плюс длина.

Используя функцию inspect:

    func inspectSlice(slice []string) {
        fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
        for i, s := range slice {
            fmt.Printf("[%d] %p %s\n",
                i,
                &slice[i],
                s)
        }
    }

Вы можете увидеть это в действии:

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    inspectSlice(slice1)
    inspectSlice(slice2)

Вывод:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[3]
    [0] 0xc00007e020 C     <-- ТОТ ЖЕ ИНДЕКС, ЧТО И 2 В СРЕЗЕ 1
    [1] 0xc00007e030 D     <-- ТОТ ЖЕ ИНДЕКС, ЧТО И 3 В СРЕЗЕ 1

Обратите внимание, что два разных среза используют один и тот же базовый массив.
В этом можно убедиться, сравнив адреса.

Здесь хорошо то, что не происходит выделения памяти на куче. Компилятор знает размер
исходного массива для slice1 на этапе компиляции. Передача копии значения среза
в функцию inspectSlice позволяет хранить все значения на стеке.

** Изменения исходного массива

Когда вы используете slice2 для изменения значения строки по индексу 0, любое значение
среза, которое использует тот же базовый массив (где адрес для этого индекса является
частью длины среза), увидит изменение.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    slice2[0] = "CHANGED"
    inspectSlice(slice1)
    inspectSlice(slice2)

Вывод:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 CHANGED
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[3]
    [0] 0xc00007e020 CHANGED
    [1] 0xc00007e030 D

Важно всегда сохранять бдительность, при изменении значений с помощью индексов,
в ситуациях когда базовый массив используется другим срезом.

.image /tour/rus/static/img/sl5.png

Что если вы вместо этого используете встроенную функцию append?

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    slice2 = append(slice2, "CHANGED")
    inspectSlice(slice1)
    inspectSlice(slice2)

Вывод:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 CHANGED
    Length[3] Capacity[3]
    [0] 0xc00007e020 C
    [1] 0xc00007e030 D
    [2] 0xc00007e040 CHANGED

Функция append создает тот же побочный эффект, но он скрыт. В этом случае,
увеличение длины slice2 за счёт ёмкости привело к изменению значения
по адресу 0xc00007e040. К сожалению, slice1 уже использовал этот адрес в своей длине.

.image /tour/rus/static/img/sl6.png

Один из способов избежать побочного эффекта - создании slice2 используя нотацию среза
с тремя индексами, чтобы длина и ёмкость имели одинаковое значение 2.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4:4]
    inspectSlice(slice1)
    inspectSlice(slice2)

Вывод:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[2]
    [0] 0xc00007e020 C
    [1] 0xc00007e030 D

Трёх-индексовый синтаксис для создания среза [a:b:c], когда b и c должны быть одинаковы,
так как [a-b] задает длину и [a-c] задает ёмкость. Теперь длина и ёмкость
slice2 одинаковы.

Теперь снова используйте встроенную функцию append:

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4:4]
    slice2 = append(slice2, "CHANGED")
    inspectSlice(slice1)
    inspectSlice(slice2)

Вывод:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[3] Capacity[4]
    [0] 0xc000016080 C
    [1] 0xc000016090 D
    [2] 0xc0000160a0 CHANGED

Обратите внимание, после вызова append, у slice2 появился новый базовый массив.

.image /tour/rus/static/img/sl7.png

Это видно при сравнении адресов срезов. В этом случае изменение значений
в slice2 не вызвала побочного эффекта для slice1.

** Ручное копирование срезов

Есть встроенная функция copy, которая позволяет выполнять поверхностное копирование
срезов. Так как строка имеет базовый массив байтов, которые неизменны, она
может использоваться в качестве источника, но не приёмника.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice3 := make([]string, len(slice1))
    copy(slice3, slice1)

    inspectSlice(slice1)
    inspectSlice(slice3)

Вывод:

    Length[5] Capacity[5]
    [0] 0xc00005c050 A
    [1] 0xc00005c060 B
    [2] 0xc00005c070 C
    [3] 0xc00005c080 D
    [4] 0xc00005c090 E
    Length[5] Capacity[5]
    [0] 0xc00005c0a0 A
    [1] 0xc00005c0b0 B
    [2] 0xc00005c0c0 C
    [3] 0xc00005c0d0 D
    [4] 0xc00005c0e0 E

Пока у приёмника есть правильные тип и длина, встроенная функция copy может
выполнить поверхностное копирование.

** Срезы используют мутацию семантики указателя

Важно помнить, что даже если вы используете семантику значения для перемещения
среза по программе, при чтении и записи среза вы используете семантику указателя.
Совместное использование отдельных элементов среза различными частями программы может
привести к нежелательным побочным эффектам.

    // Создаём срез для 1 user, устанавливаем указатель на этого пользователя,
    // используем указатель для обновления лайков.

    users := make([]user, 1)
    ptrUsr0 := &users[0]
    ptrUsr0.likes++

    for i := range users {
        fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
    }

Output:

    User: 0 Likes: 1

Срез используется для хранения коллекции пользователей. Затем указатель устанавливается
на первого пользователя и используется для обновления лайков. Результат показывает,
что использование указателя работает.

.image /tour/rus/static/img/sl8.png

Затем к коллекции добавляется новый пользователь, и указатель снова используется для
добавления лайка первому пользователю.

    // Добавить нового пользователя в коллекцию. Снова используйте указатель
    // для обновления лайков.

    users = append(users, user{})
    ptrUsr0.likes++

    for i := range users {
        fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
    }

Output:

    User: 0 Likes: 1
    User: 1 Likes: 0

Однако, поскольку функция append заменила базовый массив на новый, указатель
обновляет старый базовый массив, и лайки теряются. Результат показывает, что
лайки первого пользователя не увеличились.

.image /tour/rus/static/img/sl9.png

Нужно быть осторожным с тем, будет ли срез использоваться в операции добавления (append)
во время работы программы. Необходимо обдумать, как вы делитесь срезом. Делиться отдельными
индексами может быть не лучшей идеей. Даже делиться значением целого среза может не работать,
при добавлении элементов. Вероятно, лучший способ - использовать срез как поле в структуре
и делиться значением структуры.

** Эффективность линейного обхода
Прелесть среза заключается в его способности выполнять линейные обходы, которые
механически симпатичны при использовании семантики значений для минимизации выделения
памяти в куче.

    x := []byte{0x0A, 0x15, 0x0e, 0x28, 0x05, 0x96, 0x0b, 0xd0, 0x0}

    a := x[0]
    b := binary.LittleEndian.Uint16(x[1:3])
    c := binary.LittleEndian.Uint16(x[3:5])
    d := binary.LittleEndian.Uint32(x[5:9])

    println(a, b, c, d)

Код выполняет линейный обход, создавая значения срезов, которые считывают разные секции
байтового массива от начала до конца.

.image /tour/rus/static/img/sl10.png

Все значения в этом примере остаются в стеке. Дополнительные копии данных внутри байтового среза
не создаются.

** Примечания

- Срезы похожи на динамические массивы с особым встроенным функционалом.
- Есть разница между длиной и ёмкостью среза, и каждый из них выполняет свою функцию.
- Срезы позволяют создавать несколько "видов" одного базового массива.
- Срезы могут увеличиваться с помощью встроенной функции append.

** Дополнительное чтение

- [[https://blog.golang.org/go-slices-usage-and-internals][Использование и внутренности срезов в Go]] - Эндрю Герранд
- [[https://blog.golang.org/strings][Строки, байты, руны и символы в Go]] - Роб Пайк
- [[https://blog.golang.org/slices][Механика функции 'append': массивы, срезы (и строки) в Go]] - Роб Пайк
- [[https://www.ardanlabs.com/blog/2013/08/understanding-slices-in-go-programming.html][Понимание срезов в программировании на Go]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2013/08/collections-of-unknown-length-in-go.html][Коллекции неизвестной длины в Go]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2013/09/iterating-over-slices-in-go.html][Итерирование по срезам в Go]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2013/09/slices-of-slices-of-slices-in-go.html][Срезы срезов в Go]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2013/12/three-index-slices-in-go-12.html][Трёх-индексные срезы в Go 1.2]] - Уильям Кеннеди
- [[https://github.com/golang/go/wiki/SliceTricks][Фокусы со Срезами]]
- [[https://go-review.googlesource.com/c/go/+/347917][Среда выполнения: Сглаживание формулы роста срезов]] - Команда Go

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1

*Часть* *А:* Объявите пустой срез целых чисел. Создайте цикл, который добавляет 10 значений в срез.
Пройдите по срезу и отобразите каждое значение.

*Часть* *Б:* Объявите срез из пяти строк и инициализируйте его строковыми литералами.
Отобразите все элементы. Возьмите срез с индексами один и два и отобразите позицию индекса
и значение каждого элемента в новом срезе.

.play slices/exercise1.go
.play slices/answer1.go
