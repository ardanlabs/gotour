Хеш-таблицы
Хеш-таблица - это классический пример контейнерного типа, который может использовать реальные преимущества дженериков.

* Дженерики - Хэш-таблицы

Хеш-таблица - это классический пример контейнерного типа, который может использовать реальные преимущества
дженериков. Эта реализация была написана Мэттом Лэйхером (@mdlayer) в блоге
который он написал. Это отличный пример того, что возможно с дженериками.

** Видео

Посмотрите доклад о дженериках, в котором я рассказываю обо всех
примерах, приведенных в этом разделе.

.html generics-video.html

** Code Review

- *Пример* *1*: Хэш-таблица

.play generics/hash-table/example1.go

** Объяснение

Этот код немного сложнее того, что у вас было до сих пор. Это то, что вы можете
ожидать от реальных реализаций. На протяжении всего этого раздела вы 
увидите два вида кода. До и после применения нового синтаксиса для
дженериков.

    type hashFunc func(key K, buckets int) int

Этот тип объявляет сигнатуру хэш-функции, которая используется хэш-таблицей для
вычисления позиции корзины для хранения и извлечения данных. Пользователь должен реализовать
и предоставлять эту функцию при построении хэш-таблицы.  Функция принимает
ключ и количество корзин, из которых она может выбирать. Поскольку вы хотите, чтобы эта система была
общей с точки зрения типов, используемых для ключа и значения, вы объявляете параметр
с именем `key` и типом в виде одной заглавной буквы `K`.

Далее, мы применим новый синтаксис чтобы сделать `K` дженериком

    type hashFunc[K comparable] func(key K, buckets int) int <-- CHANGED

После имени типа добавьте квадратные скобки с общим типом `K` и ограничением `comparable`. 
Поскольку значения `key` типа должны использоваться в операции сравнения, документировать это теперь имеет смысл, даже если в реализации хэш-функции этого не требуется. Последовательность - это все
с точки зрения читабельности, понимания и возможности сопровождения с в дальнейшем.

Этот тип представляет собой пару `key/value` данных, которые будут храниться в хэш-таблице.

    type keyValuePair struct {
        Key K
        Value V
    }

Задача этого типа - хранить фактические данные с соответствующим ключом. Далее
код объявляет ключевое поле типа `K` и поле значений типа `V`.

Теперь вы можете применить синтаксис дженерика к `K` и `V` 

    type keyValuePair[K comparable, V any] struct { <-- CHANGED
        Key K
        Value V
    }

После имени типа добавьте квадратные скобки с дженерик типами `K` и `V`. В
этом объявлении `K` представляет ключ, как и раньше, а `V` - значение, которое может быть
быть чем угодно.

Этот тип представляет собой хэш-таблицу, которая управляет хэш-функцией и набором
корзин для хранения данных `key/value`.

    type Table struct {
        hashFunc hashFunc
        buckets int
        data [][]keyValuePair
    }

Тип `Table` содержит три поля: хэш-функцию, количество корзин и
данные, которые представляются в виде среза пар `key/value`. Внешний срез
представляет корзины, а внутренний срез - пары `key/value`, которые хранятся
внутри корзины.

Теперь примените синтаксис дженерика объявлея тип ключа и значения, а затем
примените их к полям.

    type Table[K comparable, V any] struct { <-- CHANGED
        hashFunc hashFunc[K] <-- CHANGED
        buckets int
        data [][]keyValuePair[K, V] <-- CHANGED
    }

После имени типа добавьте квадратные скобки с дженерик типами `K` и `V`.
Объявление типа `hashFunc` требует информации о конкретном типе, который будет использоваться для
ключа. Объявление типа `keyValuePair` требует информации о конкретном
типе для ключа и значения.

Это фабричная функция, которая может сконструировать `Table` для использования.

    func New(
        buckets int,
        hf hashFunc
    ) *Table {
        
        return &Table{
            hashFunc: hf,
            buckets: buckets,
            data: make([][]keyValuePair, buckets),
        }
    }

Функция фабрики принимает количество корзин для управления и хэш-функцию
для выбора корзины для хранения и поиска данных. Когда создается значение таблицы
количество корзин используется для построения среза, задавая длину
внешнего среза как количество используемых корзин.

Теперь примените синтаксис дженерика, чтобы объявить общие типы ключа и значения и
примените их к типам, которые необходимо построить.

    func New[K comparable, V any]( <-- CHANGED
        buckets int,
        hf hashFunc[K],            <-- CHANGED
    ) *Table[K, V] {               <-- CHANGED
        
        return &Table[K, V]{       <-- CHANGED
            hashFunc: hf,
            buckets: buckets,
            data: make([][]keyValuePair[K, V], buckets), <-- CHANGED
        }
    }

После имени типа добавьте квадратные скобки и общие типы `K` и `V`. Затем
`K` применяется к входному параметру `hf` для завершения объявления типа `hashFunc`.
Типы `K` и `V` применяются к создаваемому и возвращаемому типу `Table`.
Наконец, инициализация поля данных требует применения `K` и `V` к
синтаксис построения типа `KeyValuePair`.

Это метод, который может вставлять значения в хэш-таблицу на основе заданного ключа.

    type Table[K comparable, V any] struct {
        hashFunc hashFunc[K]
        buckets int
        table [][]keyValuePair[K, V]
    }

    func (t *Table) Insert(key K, value V) {
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.table[bucket] {
            if key == kvp.Key {
                t.table[bucket][idx].Value = value
                return
            }
        }

        kvp := keyValuePair{
            Key: key,
            Value: value,
        }
        t.table[bucket] = append(t.table[bucket], kvp)
    }

Метод `Insert` объявлен для приема ключа и значения тех же дженерик типов
которые объявлены для типа `Table`. Первым шагом при вставке является определение
корзины для хранения. Это делается путем вызова хэш-функции с
указанным ключом. Хэш-функция возвращает integer-значение, которое представляет корзину
для использования.

Затем функция проверяет, не был ли указанный ключ уже использован для хранения
значение в выбранной корзине. Это выполняется путем перебора существующего набора
пар `key/value` в корзине. Если ключ уже существует, значение для этого ключа
обновляется. Если ключ не найден, то создается новое значение пары `key/value`,
инициализируется и добавляется к фрагменту для выбранной корзины.

Теперь примените синтаксис дженерика, чтобы объявить дженерик типы ключа и значения и
примените их к типам, которые необходимо сконструировать.

    func (t *Table[K, V]) Insert(key K, value V) { <-- CHANGED
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.table[bucket] {
            if key == kvp.Key {
                t.table[bucket][idx].Value = value
                return
            }
        }
    
        kvp := keyValuePair[K, V]{                 <-- CHANGED
            Key: key,
            Value: value,
        }
        t.table[bucket] = append(t.table[bucket], kvp)
    }

После имени типа в получателе добавьте квадратные скобки и общие
типы `K` и `V`. Единственное другое изменение - это применение `K` и `V` к синтаксису построения
типа `KeyValuePair`.

Этот метод может извлекать значения из хэш-таблицы на основе указанного
ключа.

    func (t *Table) Retrieve(key K) (V, bool) {
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.data[bucket] {
            if key == kvp.Key {
                return t.data[bucket][idx].Value, true
            }
        }
    
        var zero V
        return zero, false
    }

Метод `Retrieve` объявлен для приема ключа и возврата копии значения
хранящегося для этого ключа. Первым шагом извлечения является определение корзины, которая была
использовался для хранения. Это делается путем вызова хэш-функции с указанным
ключом. Хэш-функция возвращает integer-значение, представляющее корзину для поиска
в котором нужно искать.

Затем функция выполняет итерации по коллекции пар `key/value`, хранящихся внутри
корзины, поочередно извлекая указанный ключ. Если ключ найден, возвращается копия значение, а вызывающей стороне передается `true`. Если ключ не найден, возвращается нулевое
значение, а вызывающей стороне выдается `false`.

Теперь примените синтаксис дженерика, чтобы объявить общие типы ключа и значения 
применяя их к типам, которые необходимо сконструировать.

    func (t *Table[K, V]) Get(key K) (V, bool) { <-- CHANGED
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.data[bucket] {
            if key == kvp.Key {
                return t.data[bucket][idx].Value, true
            }
        }
    
        var zero V
        return zero, false
    }

После названия типа в получателе добавьте квадратные скобки и дженерик
типы `K` и `V`. Никаких других изменений в коде не требуется.

Это небольшая программа для проверки реализации хэш-таблицы.

    func main() {
        const buckets = 8
        . . .
    }

Начните с константы, определяющей количество корзин в хэш-таблице.

    import (
        "hash/fnv"
    )
    
    func main() {
        . . .
        
        hashFunc1 := func(key string, buckets int) int {
            h := fnv.New32()
            h.Write([]byte(key))
            return int(h.Sum32()) % buckets
        }

        . . .
    }

Далее объявите хэш-функцию, в которой в качестве ключа указывается строка. Сайт
реализация использует пакет `fnv` из стандартной библиотеки, который реализует
`FNV-1` и `FNV-1a`, некриптографические хэш-функции, созданные Гленом Фаулером,
Лэндоном Кертом Ноллом и Фонгом Во. `FNV` означает хэш-функцию Фаулера-Нолла-Во.

Операция модуляции со значением корзины заставляет конечное значение попадать в
диапазон количества корзин.

    import (
        "hash/fnv"
    )
    
    func main() {
        . . .
        
        table1 := New[/*key*/ string, /*value*/ int](buckets, hashFunc1)
        
        . . .
    }

Далее создайте хэш-таблицу, явно указав, что ключ будет иметь тип `string`
а значение - типа `int`. Во входных параметрах нет ничего, что могло бы помочь компилятору вывести эту информацию.

Чтобы показать, что хэш-таблица является дженериком, 
определим вторую хэш-функцию и таблицу.

    import (
        "hash/fnv"
    )
    
    func main() {
        . . .
    
        hashFunc2 := func(key int, buckets int) int {
            return key % buckets
        }

        table2 := New[/*key*/ int, /*value*/ string](buckets, hashFunc2)
    
        . . .
    }

TЭта хэш-функция объявляет integer в качестве ключа и выполняет простую операцию по модулю
со значением корзины по отношению к ключу. Затем создается новая таблица
где ключом является целое число, а значением - строка. В обратную сторону от
первой таблицы.

    import (
        "hash/fnv"
    )
    
    func main() {
        . . .
    
        words := []string{"foo", "bar", "baz"}
        for i, word := range words {
            table1.Insert(word, i)
            table2.Insert(i, word)
        }
    
        for i, s := range append(words, "nope!") {
            v1, ok1 := table1.Retrieve(s)
            fmt.Printf("t1.Rtr(%v) = (%v, %v)\n", s, v1, ok1)
            
            v2, ok2 := table2.Retrieve(i)
            fmt.Printf("t2.Rtr(%v) = (%v, %v)\n", i, v2, ok2)
        }
    }

Output:

    t1.Rtr(foo) = (0, true)
    t2.Rtr(0) = (foo, true)
    t1.Rtr(bar) = (1, true)
    t2.Rtr(1) = (bar, true)
    t1.Rtr(baz) = (2, true)
    t2.Rtr(2) = (baz, true)
    t1.Rtr(nope!) = (0, false)
    t2.Rtr(3) = (, false)

В заключение напишите код для хранения и извлечения значений из двух соответствующих
таблиц.
