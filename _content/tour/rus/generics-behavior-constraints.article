Поведение как Ограничение

Каждый идентификатор типа требует объявленное ограничение, чтобы компилятор знал, какие конкретные
типы он может или не может подставить на место идентификатора

* Дженерики - Поведение как Ограничение

Каждый идентификатор типа требует объявленное ограничение, чтобы компилятор знал, какие конкретные
типы он может или не может подставить на место идентификатора. Объявление является обязательным, даже если 
оно не накладывает никаких реальных ограничений на тип, как, например, any. 

** Видео

Посмотрите рассказ про Дженерики ниже, который проведет вас через все 
примеры секции Тура.

.html generics-video.html

** Обзор Кода

- *Пример* *1*: Реализация stringify для конкретного типа
- *Пример* *2*: Реализация stringify через утверждение типов
- *Пример* *3*: Реализация stringify с использованием рефлексии
- *Пример* *4*: Реализация stringify с использованием дженериков

.play generics/behavior-constraints/example1.go
.play generics/behavior-constraints/example2.go
.play generics/behavior-constraints/example3.go
.play generics/behavior-constraints/example4.go

** Объяснение

Интересно, что концепция ограничения поведения уже существует в языке

    type User struct {
        name string
    }
    
    func (u User) String() string {
        return u.name
    }
    
    type Stringer interface {
        String() string
    }
    
    func Concrete(u User) {
        u.String()
    }

    func Polymorphic(s Stringer) {
        s.String()
    }

Код выше определяет конкретный тип User и реализует для него метод String, возвращающий имя пользователя. Далее
объявляет интерфейс Stringer, декларирующий поведение в виде метода String, возвращающего строку. Благодаря ранее
реализованному методу User, мы можем сказать, что User реализует интерфейс Stringer.

Функция Concrete это функция, принимающая аргументы, основываясь на том, чем они являются. 
В то время как Polymorphic это функция, принимащая аргументы, основываясь на том, что они могут делать. 
В это и заключается главное отличие между принимающими конкретные типы и полиморфными функциями. Первые
ограничены конкретным типом данных, в то время как последние нет. Однако, есть ограничение на то, какие
конкретные данные могут быть переданы в полиморфные функции.

Интерфейс Stringer определяет это ограничение через набор методов, таким образом описывая поведение,
которым должен обладать конкретный тип. Когда он применяется в качестве входного типа, компилятор
может гарантировать, что при каждом вызове функции переданные данные будут удовлетворять это поведение.

Дженерик функции также требуют ограничение поведения

    func stringify[T fmt.Stringer](slice []T) []string {
        ret := make([]string, 0, len(slice))
        
        for _, value := range slice {
            ret = append(ret, value.String())
        }
        
        return ret
    }

Выше реализована дженерик функция stringify. Она принимает срез элементов с типом Т и
возвращает срез строк, где каждый элемент это строковое представление соответствующего
входного элемента. Эта реализация возможна благодаря вызову метода String у каждого элемента.

Проблема в том, что компилятору необходимо проверять, что значения типа Т действительно имеют метод String. При объявлении дженерик типа Т, мы также объявляем интерфейс fmt.Stringer как ограничение. Благодаря этому компилятор знает как проверять любые подставленные конкретные типы.

И это прекрасно, потому что концепция интерфейса переиспользуется, так что 
нет необходимости в добавлении новых ключевых слов.

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1

С использованием дженериков реализуйте функцию marshal, сериализующую JSON и принимающую только значения, удовлетворяющие интерфейс json.Marshaler.

.play generics/behavior-constraints/exercise1.go 
.play generics/behavior-constraints/answer1.go
