Методы
Функция называется методом, когда у этой функции объявлен приёмник.

* Методы

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Функция называется методом, когда у этой функции объявлен приёмник.
Получатель - это параметр, объявленный между ключевым словом func
и именем функции.

** Обзор кода

- *Пример* *1:* Объявление и поведение приёмника
- *Пример* *2:* Именованные методы типов
- *Пример* *3:* Переменные функций/методов
- *Пример* *4:* Типы функций
- *Пример* *5:* Семантика значений и указателей

.play methods/example1.go
.play methods/example2.go
.play methods/example3.go
.play methods/example4.go
.play methods/example5.go

** Объявление методов

Существует два типа приёмников: приёмники значений для реализации семантики значений
и приёмники указателей для реализации семантики указателей.

    type user struct {
        name  string
        email string
    }

    func (u user) notify() {
        fmt.Printf("Sending User Email To %s<%s>\n", u.name, u.email)
    }

    func (u *user) changeEmail(email string) {
        u.email = email
        fmt.Printf("Changed User Email To %s\n", email)
    }

Функция notify реализована с приёмником значения. Это означает, что метод
работает с семантикой значения и будет оперировать с собственной копией значения,
переданной ему при вызове.

Функция changeEmail реализована с приёмником указателя. Это означает,
что метод работает с семантикой указателя и будет оперировать в рамках совместного доступа к значению,
переданной ему при вызове.

За редким исключением, набор методов для типа не должен смешивать
приёмники значений и указателей. Согласованность семантики данных крайне важна,
и это включает в себя объявление методов.

** Вызов методов

При вызове метода компилятору не важно, точно ли соответствует значение,
используемое при вызове, семантике данных приёмника. Компилятор просто
хочет значение или указатель того же типа.

    bill := user{"Bill", "bill@email.com"}
    bill.notify()
    bill.changeEmail("bill@hotmail.com")

Как вы видите - здесь создано значение типа user и присвоено переменной bill.
В случае вызова notify переменная bill соответствует типу приёмника,
который использует приёмник значения. В случае вызова changeEmail переменная bill
не соответствует типу приёмника, который использует приёмник указателя.
Тем не менее компилятор принимает вызов метода и передает переменную bill методу.
Go адаптируется, чтобы сделать вызов.

Всё работает точно так же, когда переменная, используемая для вызова, является указателем.

    bill := &user{"Bill", "bill@email.com"}
    bill.notify()
    bill.changeEmail("bill@hotmail.com")

В этом случае переменная bill - это указатель на значение типа user.
Опять же, Go адаптируется, чтобы выполнить вызов метода при вызове метода notify.

Если бы Go не адаптировался, вот как вы должны были бы сделать те же самые вызовы методов.

    bill := user{"Bill", "bill@email.com"}
    (&bill).changeEmail("bill@hotmail.com")

    bill := &user{"Bill", "bill@email.com"}
    (*bill).notify()

Я рад, что нам не приходится этого делать при вызове методов в Go.

** Рекомендации по семантике данных для Встроенных Типов

В качестве рекомендации, если данные, с которыми вы работаете, являются встроенным типом
(срез, карта, канал, функция, интерфейс), тогда используйте семантику значений для передачи
данных в программе. Это также относится к объявлению полей в структурах. Однако, при чтении
и записи, необходимо помнить, что вы используете семантику указателей.

    type IP []byte
    type IPMask []byte

Эти типы объявлены в пакете net, который является частью стандартной библиотеки.
Они объявлены на основе среза байтов. Благодаря этому, данные типы следуют рекомендациям
для встроенных типов.

    func (ip IP) Mask(mask IPMask) IP {
        if len(mask) == IPv6len && len(ip) == IPv4len && allFF(mask[:12]) {
            mask = mask[12:]
        }
        if len(mask) == IPv4len && len(ip) == IPv6len &&
            bytesEqual(ip[:12], v4InV6Prefix) {
            ip = ip[12:]
        }
        n := len(ip)
        if n != len(mask) {
            return nil
        }
        out := make(IP, n)
        for i := 0; i < n; i++ {
            out[i] = ip[i] & mask[i]
        }
        return out
    }

С методом Mask для приёмника, параметра и возвращаемого аргумента используется семантика значений.
Этот метод принимает собственную копию значения Mask, мутирует это значение, а затем
возвращает изменённую копию. Этот метод использует мутацию семантики значения.
Это не ошибка и не случайность.

Функция может решить, какие данные ввода и вывода ей нужны. Чего она не может решить,
так это семантики данных для передачи внутри программы. Данные определяют
это решение, и функция должна ему соответствовать. Вот почему Mask реализует api семантики
мутации значения. Функция должна уважать то, как срез передается внутри программы.

    func ipEmptyString(ip IP) string {
        if len(ip) == 0 {
            return ""
        }
        return ip.String()
    }

Функция `ipEmptyString` также использует семантику значений для ввода и вывода.
Эта функция принимает свою копию значения IP и возвращает строковое значение.
Здесь не используется семантика указателей, потому что данные (а не функция)
определяют семантику данных.

Единственным исключением для использования семантики значений является случай,
когда вам нужно передать срез или карту в функцию, выполняющую десериализацию или декодирование.

** Рекомендации по семантике данных для типов структур

Как рекомендация, если данные, с которыми вы работаете, являются структурой, при принятии решения
вам необходимо подумать о том, что из себя представляют эти данные. Хорошее общее правило - задать себе
вопрос, представляет ли структура данные или API. Если структура представляет данные, используйте
семантику значений. Если структура представляет API, используйте семантику указателя.

    type Time struct {
        sec  int64
        nsec int32
        loc  *Location
    }

Вот структура Time из пакета time. Если считать что Time представляет собой данные, то для этой структуры
следует использовать семантику значений.

Если при рассмотрении существующего кода вы хотите узнать, какая семантика данных была выбрана,
поищите фабричную функцию. Тип возвращаемого значения фабричной функции должен определять семантику данных,
выбранную разработчиком.

    func Now() Time {
        sec, nsec := now()
        return Time{sec + unixToInternal, nsec, Local}
    }

Now - это фабричная функция для создания значений Time. Посмотрите на возвращаемое значение,
оно использует семантику значений. Это указывавет на необходимость использования семантики значений
для передачи значений Time. Это означает, что каждая функция получает свою собственную копию
значения Time и поля в структуре следует объявлять как значения типа Time.

    func (t Time) Add(d Duration) Time {
        t.sec += int64(d / 1e9)
        nsec := int32(t.nsec) + int32(d%1e9)
        if nsec >= 1e9 {
            t.sec++
            nsec -= 1e9
        } else if nsec < 0 {
            t.sec--
            nsec += 1e9
        }
        t.nsec = nsec
        return t
    }

Add - это метод, который должен выполнить операцию мутации. Если вы посмотрите внимательно,
вы увидите, что функция использует мутацию семантики значений. Метод Add при вызове получает свою
копию значения Time, мутирует свою собственную копию, а затем возвращает копию обратно вызывающему.
Опять же, это самый безопасный способ выполнения операции мутации.

    func div(t Time, d Duration) (qmod2 int, r Duration) {}

Вот ещё один пример, где функция div принимает значение типа Time и Duration (int64),
а затем возвращает значения типа int и Duration. Семантика значений используется
для типа Time и для всех встроенных типов. Duration имеет базовый тип int64.

    func (t *Time) UnmarshalBinary(data []byte) error {}
    func (t *Time) GobDecode(data []byte) error {}
    func (t *Time) UnmarshalJSON(data []byte) error {}
    func (t *Time) UnmarshalText(data []byte) error {}

Эти четыре метода из пакета Time, казалось бы, нарушают правила согласованности семантики данных.
Почему они используют семантику указателя? Потому что они реализуют интерфейс, где сигнатура
метода зафиксирована. Поскольку реализация требует мутации, семантика указателя - единственный выбор.

Вот рекомендация: Если используется семантика значения, вы можете переключиться на семантику
указателя для некоторых функций, при условии, что вы не позволите данным в оставшейся
цепочке вызовов переключиться обратно на семантику значения. Как только вы переключились
на семантику указателя, все последующие вызовы с этой точки должны придерживаться семантики указателя.
Вы никогда, ни в коем случае, не должны переходить от указателя к значению. Копировать значение,
на которое указывает указатель, небезопасно.

    func Open(name string) (file *File, err error) {
        return OpenFile(name, O_RDONLY, 0)
    }

Функция Open из пакета os показывает, что при использовании значения типа File
используется семантика указателя. Значения File должны быть совместными и никогда не должны
копироваться.

    func (f *File) Chdir() error {
        if f == nil {
            return ErrInvalid
        }
        if e := syscall.Fchdir(f.fd); e != nil {
            return &PathError{"chdir", f.name, e}
        }
        return nil
    }

Метод Chdir использует приемник указателя, даже если этот метод не изменяет значение File.
Это потому, что значения File должны быть совместными и не должны копироваться.

    func epipecheck(file *File, e error) {
        if e == syscall.EPIPE {
            if atomic.AddInt32(&file.nepipe, 1) >= 10 {
                sigpipe()
            }
        } else {
            atomic.StoreInt32(&file.nepipe, 0)
        }
    }

Функция epipecheck также принимает значения File, используя семантику указателя.

** Методы - это просто функции

Методы - это просто функции, обёрнутые в синтаксический сахар, дающий возможность данным
показать своё поведение.

    type data struct {
        name string
        age  int
    }

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

Здесь объявлен тип и два метода. Метод displayName использует семантику значения,
а setAge - семантику указателя.

Заметка: Не реализуйте сеттеры и геттеры в Go. Они не выполняют функции api - в таких случаях
лучше сделать эти поля экспортируемыми.

    d := data{
        name: "Bill",
    }

    d.displayName()
    d.setAge(21)

Конструируется значение типа data и вызываются методы.

    data.displayName(d)
    (*data).setAge(&d, 21)

Поскольку методы - это просто функции с синтаксическим сахаром, их можно
вызывать как функции. Вы можете убедиться, что приемник - это на самом деле первый параметр.
При вызове метода компилятор незаметно преобразует его.

Заметка: Не вызывайте методы таким образом в вашем коде, но будьте готовы встретиться с этим синтаксисом
в сообщениях об ошибках инструментов.

** Знайте поведение кода

Если вы знаете семантику данных, то вы знаете поведение кода.
Если вы знаете поведение кода, то вы знаете стоимость его выполнения.
Когда вы знаете стоимость, то вы инженер.

Имея нижеприведённый тип и набор методов:

    type data struct {
        name string
        age  int
    }

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

Вы можете написать следующий код.

    func main() {
        d := data{
            name: "Bill",
        }

        f1 := d.displayName
        f1()
        d.name = "Joan"
        f1()
    }

Вывод:

    My Name Is Bill
    My Name Is Bill

Всё начинается с создания значения типа `data` и присвоения его переменной d.
Затем метод displayName, связанный с d, присваивается переменной f1.
Это не вызов метода, а присваивание, которое создает уровень косвенности.
Функции - это значения в Go и они принадлежат набору встроенных типов.

После присваивания, метод можно вызвать косвенно с использованием
переменной f1. В результате отображается имя Bill. Затем данные изменяются,
так что имя теперь Joan, и метод снова вызывается через переменную f1.
Изменений не видно. Снова выводится Bill. Почему?

.image /tour/rus/static/img/m1.png

Это связано с семантикой данных. Метод displayName использует
приемник значения, поэтому используется семантика значения.

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

Это означает, что переменная f1 поддерживает и работает с собственной
копией d. При вызове метода через переменную f1 всегда используется
копия, и эта копия защищена от изменений. Это именно то, что нам нужно
при использовании семантики значений.

Теперь давайте сделаем то же самое, но с методом setAge.

    func main() {
        d := data{
            name: "Bill",
        }

        f2 := d.setAge
        f2(45)
        d.name = "Sammy"
        f2(45)
    }

Вывод:

    Bill Is Age 45
    Sammy Is Age 45

На этот раз метод setAge присваивается переменной f2. Снова
выполняется косвенный вызов метода через переменную f2, передавая
45 для возраста Bill. Затем имя Bill изменяется на Sammy, и
переменная f2 снова используется для вызова метода. На этот раз
вы видите изменение.

.image /tour/rus/static/img/m2.png

Функция setAge использует указательный приемник, поэтому setAge не оперирует
с собственной копией переменной d, а работает непосредственно с переменной d.
Следовательно, f2 работает с совместным доступом, и вы видите изменение.

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

Не зная семантику данных, вы не знаете поведение кода.
Семантика данных реальна и она влияет на поведение.

** Примечания

Методы - это функции, включающие при объявлении переменную приемника.
Приемники связывают метод с типом и могут использовать семантику значения или указателя.
Семантика значения означает, что копия значения передается через границы программы.
Семантика указателя означает, что копия адреса значений передается через границы программы.
Придерживайтесь единой семантики для данного типа и будьте последовательными.

** Цитаты

"Методы допустимы, когда разумно или практично, чтобы часть данных раскрывала свои возможности." - Уильям Кеннеди

** Дополнительное чтение

- [[https://golang.org/doc/effective_go.html#methods][Методы]]
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Методы, интерфейсы и встроенные типы Go]] - Уильям Кеннеди
- [[https://www.ardanlabs.com/blog/2018/01/escape-analysis-flaws.html][Недостатки Анализа Утечек]] - Уильям Кеннеди

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1

Объявите структуру, представляющую бейсбольного игрока. Включите поля name, atBats и hits.
Объявите метод, который вычисляет средний показатель бита игрока. Формула: Hits / AtBats.
Объявите срез этого типа и инициализируйте его несколькими игроками.
Пройдите по срезу, отображая имя игрока и его средний показатель бита.

.play methods/exercise1.go
.play methods/answer1.go
