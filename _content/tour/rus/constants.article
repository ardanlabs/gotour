Константы
Одной из уникальных особенностей Go является то, как язык реализует константы.

* Константы

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Посмотреть видео]]
- Если вам нужна финансовая помощь - заполните нашу [[https://www.ardanlabs.com/scholarship/][заявку на стипендию]]

Одной из уникальных особенностей Go является то, как язык реализует константы.
Правила для констант в спецификации языка уникальны для Go. Они обеспечивают
гибкость, необходимую Go для того, чтобы наш код оставался читабельным и интуитивно
понятным, сохраняя при этом безопасность типов.

Константы могут быть типизированными или нетипизированными. Когда константа нетипизирована,
она считается определенного вида (kind). Константы данного вида могут быть неявно
преобразованы компилятором. Это происходит на этапе компиляции, а не во время выполнения.

** Обзор кода

- *Пример* *1:* Объявление и инициализация констант
- *Пример* *2:* Параллельная система типов (Kind) (отсутствует)
- *Пример* *3:* iota
- *Пример* *4:* Неявное преобразование

.play constants/example1.go
.play constants/example2.go
.play constants/example3.go
.play constants/example4.go

    const ui = 12345     // вид (kind): целое число
    const uf = 3.141592  // вид: число с плавающей запятой

Нетипизированные числовые константы имеют точность в 256 бит, как указано
в спецификации языка. Они основаны на определенном виде.

    const ti int     = 12345     // тип: int
    const tf float64 = 3.141592  // тип: float64

Типизированные константы используют систему типов констант, но их точность ограничена.

    const myUint8 uint8 = 1000 // Ошибка компиляции: константа 1000 переполняет uint8

Это не работает, потому что число 1000 слишком велико для хранения в uint8.

    var answer = 3 * 0.333  // float64 = KindFloat(3) * KindFloat(0.333)

Константная арифметика поддерживает использование различных видов констант.
Для обработки таких ситуаций используется "продвижение видов" (Kind Promotion).
Все это происходит неявно. Переменная answer в этом примере будет иметь тип float64
и представлять 0.999 с точностью 64 бит.

    const third = 1 / 3.0  // KindFloat = KindFloat(1) / KindFloat(3.0)

Константа third будет иметь вид float и представлять 1/3 с точностью 256 бит.

    const zero = 1 / 3  // KindInt = KindInt(1) / KindInt(3)

Константа zero будет иметь вид целого числа и установлена в 0, так как целочисленное
деление не имеет остатка.

    const one int8 = 1
    const two = 2 * one  // int8(2) * int8(1)

Это пример константной арифметики между типизированными и нетипизированными константами.
В данном случае константа вида продвигается до константы типа. Константа two будет
иметь тип int8 и установлена в 2.

    const maxInt = 9223372036854775807

Это максимальное значение для 64-битного целого числа.

    const bigger = 9223372036854775808543522345

Kонстанта bigger имеет значение намного большее, чем максимальное 64-битное целое число,
но ее можно хранить в константе вида int, так как константы вида int не ограничены
64 битами точности.

Однако, если бы bigger была константой типа int64, это бы не скомпилировалось.

    const bigger int64 = 9223372036854775808543522345

Ошибка компиляции:

    constant 9223372036854775808543522345 overflows int64



** IOTA

IOTA предоставляет поддержку для установки последовательных целых констант.  Возможно,
название происходит от функции ⍳ из языка программирования APL. В APL функция ⍳
(представлена девятой буквой греческого алфавита, айота) используется для создания нулевого
массива последовательных, возрастающих целых чисел заданной длины.

    const (
        A1 = iota  // 0 : Начинается с 0
        B1 = iota  // 1 : Увеличивается на 1
        C1 = iota  // 2 : Увеличивается на 1
    )
    fmt.Println(A1, B1, C1)

Вывод:

    0 1 2

Ключевое слово iota работает в рамках блока констант и начинается со значения 0.
Затем для каждой последующей константы, объявленной в блоке, iota увеличивается на 1.

    const (
        A2 = iota  // 0 : Начинается с 0
        B2         // 1 : Увеличивается на 1
        C2         // 2 : Увеличивается на 1
    )
    fmt.Println(A2, B2, C2)

Вывод:

    0 1 2

Нет необходимости повторять ключевое слово iota. Последовательный характер целых констант
подразумевается, при его первом применении.

    const (
        A3 = iota + 1  // 1 : 0 + 1
        B3             // 2 : 1 + 1
        C3             // 3 : 2 + 1
    )
    fmt.Println(A3, B3, C3)

Вывод:

    1 2 3

Если вы не хотите применять математический шаблон, вы можете выполнить математические
вычисления и применить их в дальнейших увеличениях значения iota.

    const (
        Ldate= 1 << iota  //  1 : Сдвиг 1 налево на 0.  0000 0001
        Ltime             //  2 : Сдвиг 1 налево на 1.  0000 0010
        Lmicroseconds     //  4 : Сдвиг 1 налево на 2.  0000 0100
        Llongfile         //  8 : Сдвиг 1 налево на 3.  0000 1000
        Lshortfile        // 16 : Сдвиг 1 налево на 4.  0001 0000
        LUTC              // 32 : Сдвиг 1 налево на 5.  0010 0000
    )

    fmt.Println(Ldate, Ltime, Lmicroseconds, Llongfile, Lshortfile, LUTC)

Вывод:

    1 2 4 8 16 32

Вы можете использовать этот функционал, как это делает пакет Log, для установки флагов.
В данном случае, для вычисления значений флагов, используется значения iota вычисленные путем операции с битами

** Заметки

- Константы - это не переменные.
- Они существуют только на этапе компиляции.
- Нетипизированные константы могут быть неявно преобразованы, в то время как типизированные константы и переменные - не могут.
- Представьте себе нетипизированные константы как имеющие Вид, а не Тип.
- Изучите явные и неявные преобразования.
- Познакомьтесь с мощью констант и их использованием в стандартной библиотеке.

** Дополнительное чтение

- [[https://golang.org/ref/spec#Constants][Спецификации констант]]
- [[https://blog.golang.org/constants][Константы]] - Роб Пайк
- [[https://www.ardanlabs.com/blog/2014/04/introduction-to-numeric-constants-in-go.html][Введение в числовые константы в Go]] - Уильям Кеннеди

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1

*Часть* *A:* Объявите нетипизированную и типизированную константы и выведите их значения.

*Часть* *B:* Разделите две литеральные константы в типизированную переменную и выведите значение.

.play constants/exercise1.go
.play constants/answer1.go
