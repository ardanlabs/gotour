Основы
Учимся писать базовую функцию с использованием дженериков.

* Дженерики - Основы

Учимся писать базовую функцию с использованием дженериков.

** Видео

Посмотрите рассказ про Дженерики ниже, который проведет вас через все 
примеры секции Тура.

.html generics-video.html

** Обзор Кода

- *Пример* *1*: Реализация print для конкретного типа
- *Пример* *2*: Реализация print через утверждение типов
- *Пример* *3*: Реализация print с использованием рефлексии
- *Пример* *4*: Реализация print с использованием дженериков

.play generics/basics/example1.go
.play generics/basics/example2.go
.play generics/basics/example3.go
.play generics/basics/example4.go

** Объяснение

Если вы хотите общую функцию, печатающую срез любого типа без использования рефлексии,
вы можете использовать новый синтаксис дженериков.

    func print[T any](slice []T) {
        fmt.Print("Generic: ")
        
        for _, v := range slice {
            fmt.Print(v, " ")
        }

        fmt.Print("\n")
    }

Это реализация функции, которая может напечатать срез любого типа с использованием
нового синтаксиса дженериков. В отличие от кода с использованием рефлексии, этот синтаксис хорош тем,
что код внутри функции может использовать синтаксис и функции конкретных типов.

Нам необходимо сообщить компилятору, что мы не будем объявлять тип T явно и что он должен 
быть определен компилятором во время компиляции. Для этого новый синтаксис использует квадратные скобки.
Квадратные скобки определяют список общих идентификаторов типов, специфичных для функции, 
которые необходимо определить на этапе компиляции. Это то, как мы сообщаем компилятору, что типы с этими
именами не будут явно объявлены заранее и необходимо определить их во время компиляции программы.

Примечание: Несмотря на то, что текущий пример использует только один идентификатор типов, в квадратных
скобках вы можете объявить любое их количество. Например, [T, S, R any]

Для лучшей читаемости, вы можете выбрать любые названия для идентификаторов типов. В текущем примере
код использует заглавную букву T, чтобы показать, что в функцию может быть передан срез произвольного типа (конкретный
тип будет определен при компиляции). Использование единичных заглавных букв для названий типов списков является 
распространенной практикой, уходящей корнями к более старым языкам программирования, таким как C++ и Java.

Также, внутри квадратных скобок можно встретить слово any. Оно накладывает ограничение на то, каким типом 
может быть T. Компилятор требует, чтобы все идентификаторы типов имели четко описанные ограничения.
Встроенное ограничение any указывает на отсутствие ограничений для типа T.

    numbers := []int{1, 2, 3}
    print[int](numbers)

    strings := []string{"A", "B", "C"}
    print[string](strings)
    
    floats := []float64{1.7, 2.2, 3.14}
    print[float64](floats)

Выше показано как вызвать функцию print с явным указанием конкретного типа для T. Такой синтаксис 
отражает идею о том, что объявление функции func name[T any](slice []T) определяет два набора параметров.
Первый набор это тип, отображаемый в соответствующие идентификаторы типов, в то время как второй набор 
это данные, отображаемые в соответствующие входящие переменные.

К счастью, компилятор может вывести тип, таким образом убирая необходимость явно указывать тип функции при вызове. 

    numbers := []int{1, 2, 3}
    print(numbers)
    
    strings := []string{"A", "B", "C"}
    print(strings)
    
    floats := []float64{1.7, 2.2, 3.14}
    print(floats)

Код выше показывает как можно вызвать функцию print явно не передавая информацию о её типах. 
На момент вызова функции, компилятор способен определить конкретный тип Т и создать версию функции 
для работы со срезом этого конкретного типа. Компилятор умеет выводить тип основываясь на данных, 
переданных в функцию в месте вызова.

* Упражнения

Используйте шаблон в качестве отправной точки для выполнения упражнений. Здесь представлен возможный вариант решения.

** Упражнение 1

С использованием дженериков реализуйте функцию marshal, принимающую любое значение и 
десериализующую его в JSON. Функция должна возвращать полученный JSON и значение ошибки. Объявите
тип struct с названием User и двумя полями, Name и Age. Затем, создайте значение 
с типом User и передайте его в функцию marshal.

.play generics/basics/exercise1.go 
.play generics/basics/answer1.go
