Giả lập hành vi (Mocking)
Vì trình biên dịch có thể thực hiện việc phân tích mã tĩnh để xác định xem một giá trị cụ thể
có triển khai interface hay không nên developer khai báo loại cụ thể cũng không cần cung cấp interface.

* Mocking

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Xem Video]]
- Cần hỗ trợ Học phí, hãy sử dụng [[https://www.ardanlabs.com/scholarship/] [Đơn xin Học bổng]] của chúng tôi

Cách tốt nhất để tận dụng lợi thế của việc nhúng là thông qua mẫu thiết kế tổng hợp.
Ý tưởng là kết hợp các kiểu lớn hơn từ các kiểu nhỏ hơn và tập trung vào thành phần
của hành vi.

** Code Review

- *Ví dụ* *1:* Mocking

.chạy composition/mocking/example1.go

** Sự sở hữu Interface

Một điểm khác biệt của Go so với các ngôn ngữ khác là ý tưởng về quy ước cao hơn
cấu hình. Điều này thực sự thể hiện qua cách Go xử lý việc tuân thủ interface.
Vì trình biên dịch có thể thực hiện phân tích mã tĩnh để xác định xem một giá trị cụ thể
có triển khai một interface hay không, nên developer khai báo loại cụ thể mà không cần
cung cấp interface.

    package pubsub

    type PubSub struct {
        host string
    }

    func New(host string) *PubSub {
        return &PubSub{
            host: host,
        }
    }

    func (ps *PubSub) Publish(key string, v interface{}) error {
        // PRETEND THERE IS A SPECIFIC IMPLEMENTATION.
        return nil
    }

    func (ps *PubSub) Subscribe(key string) error {
        // PRETEND THERE IS A SPECIFIC IMPLEMENTATION.
        return nil
    }

Bạn vừa viết một API mới cung cấp cách triển khai cụ thể cho việc Publish và
Subscribe. Không có interface nào được cung cấp vì API này không cần.
Đây là một việc implement cụ thể duy nhất.

Điều gì sẽ xảy ra nếu một developer sử dụng API mới này cần một interface bởi vì
họ có nhu cầu mock implement này trong quá trình test? Trong Go, developer đó
có thể khai báo interface và trình biên dịch có thể xác định sự đúng đắn.

    package main

    type publisher interface {
        Publish(key string, v interface{}) error
        Subscribe(key string) error
    }

    type mock struct{}

    func (m *mock) Publish(key string, v interface{}) error {
        // ADD MY MOCK FOR THE PUBLISH CALL.
        return nil
    }

    func (m *mock) Subscribe(key string) error {
        // ADD MY MOCK FOR THE SUBSCRIBE CALL.
        return nil
    }

Code này trong package main đang khai báo một interface. Interface này đại diện cho
API mà ứng dụng đang sử dụng từ package pubsub. Developer đã triển khai pubsub
của riêng mình để test. Mấu chốt ở đây là developer không trực tiếp sử dụng bất kỳ
implement cụ thể nào mà decouples thông qua interface của riêng mình.

    func main() {
        pubs := []publisher{
            pubsub.New("localhost"),
            &mock{},
        }

        for _, p := range pubs {
            p.Publish("key", "value")
            p.Subscribe("key")
        }
    }

Ví dụ, function main xây dựng một bộ sưu tập được khởi tạo với việc implement pubsub và mock.
Interface publisher cho phép điều này. Sau đó, một vòng lặp for range được implement để
hiển thị cách code của ứng dụng được abstract từ bất kỳ implement cụ thể nào.