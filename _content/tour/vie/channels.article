Kênh (Channel)
Kênh cho phép các goroutine giao tiếp với nhau thông qua việc sử dụng cơ chế gửi tín hiệu.

* Kênh (Channel)

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Xem Video]]
- Cần hỗ trợ Học phí, hãy sử dụng [[https://www.ardanlabs.com/scholarship/][Đơn xin Học bổng]] 
của chúng tôi.

Hãy nghĩ về `channel` không phải là một cấu trúc dữ liệu, mà là một cơ chế để gửi tín hiệu.
Điều này đi theo hướng ý tưởng rằng bạn gửi và nhận từ một `channel`, không phải đọc và viết.
Nếu vấn đề trước mặt bạn không thể được giải quyết với tín hiệu, nếu từ tín hiệu không
xuất hiện từ miệng bạn, bạn cần phải đặt câu hỏi về việc sử dụng `channel`.

** Code Review

- *Example* *1:* Wait for result
- *Example* *2:* Fan out
- *Example* *3:* Wait for task
- *Example* *4:* Pooling
- *Example* *5:* Fan out semaphore
- *Example* *6:* Bounded work pooling
- *Example* *7:* Drop
- *Example* *8:* Cancellation
- *Example* *9:* Retry timeout
- *Example* *10:* Channel cancellation

.play channels/example1.go
.play channels/example2.go
.play channels/example3.go
.play channels/example4.go
.play channels/example5.go
.play channels/example6.go
.play channels/example7.go
.play channels/example8.go
.play channels/example9.go
.play channels/example10.go

** Cơ chế của channel

Để đảm bảo sự toàn vẹn của tín hiệu, ta phải đánh đổi bằng việc không xác định được độ trễ.
Người gửi sẽ không biết họ cần phải đợi bao lâu để người nhận chấp nhận tín hiệu.
Phải đợi người nhận tạo ra độ trễ chặn (blocking latency). Trong trường hợp này,
độ trễ chặn không xác định. Người gửi phải đợi trong một khoảng thời gian không xác định,
cho đến khi người nhận có thể nhận tín hiệu.

Chờ đợi người nhận có nghĩa là cơ chế nhận xảy ra trước cơ chế gửi.
Với `channel`, cơ chế nhận xảy ra trước vài nanosecond, nhưng nó vẫn xảy ra trước.
Điều này có nghĩa là người nhận nhận tín hiệu và sau đó rời đi, đảm bảo cho phép người gửi tiếp tục.

Nếu quá trình không thể chờ đợi một khoảng thời gian không xác định thì sao?
Nếu loại độ trễ đó không hoạt động thì sao? Như vậy thì không thể đảm bảo ở mức tín hiệu,
nó cần phải ở bên ngoài nó. Cơ chế làm việc phía sau là gửi xảy ra trước khi nhận.
Người gửi có thể gửi tín hiệu mà không cần người nhận có sẵn.
Vì vậy, người gửi có thể đi ra và không phải đợi.
Cuối cùng, bạn hy vọng, người nhận sẽ xuất hiện và lấy tín hiệu.

Điều này giảm chi phí độ trễ của việc gửi, nhưng nó tạo ra sự không chắc chắn về việc nhận tín hiệu
và do đó không biết có vấn đề với người nhận ở phía trên hay không.
Điều này có thể tạo ra quá trình chấp nhận công việc mà không bao giờ được bắt đầu hoặc hoàn thành.
Nó có thể tạo ra một sức ép lớn và hệ thống có thể bị quá tải.

Điều thứ hai cần tập trung vào là bạn có cần gửi dữ liệu với tín hiệu không?
Nếu tín hiệu yêu cầu truyền dữ liệu, thì tín hiệu được truyền 1 đến 1 giữa các `goroutine`.
Nếu một `goroutine` mới cũng cần nhận tín hiệu, thì phải gửi tín hiệu thứ hai.

Nếu dữ liệu không cần được truyền với tín hiệu, thì tín hiệu có thể được truyền 1 đến 1
hoặc 1 đến nhiều giữa các `goroutine`.
Tín hiệu không có dữ liệu được sử dụng chủ yếu cho việc hủy bỏ hoặc tắt.
Nó được thực hiện bằng cách đóng `channel`.

Điều thứ ba cần tập trung vào là trạng thái của `channel`. Một `channel` có thể ở 1 trong 3 trạng thái.

Một `channel` có thể ở trạng thái `nil` bằng cách khởi tạo `channel` với trạng thái giá trị 0 (zero value).
Gửi và nhận tín hiệu trên `channel` trong trạng thái này sẽ bị chặn. Điều này tốt cho các tình huống
khi bạn muốn thực hiện dừng ngắn hạn của công việc.

Một `channel` có thể ở trạng thái `open` bằng cách sử dụng hàm `make` tích hợp sẵn.
Gửi và nhận tín hiệu trên `channel` trong trạng thái này sẽ hoạt động trong các điều kiện sau:

*Unbuffered* *Channels:* 

- Đảm bảo ở mức tín hiệu với việc nhận xảy ra trước khi gửi. Các `goroutine` gửi và nhận
cần phải đến cùng một không gian và thời gian để tín hiệu được xử lý.

*Buffered* *Channels:*

- Đảm bảo bên ngoài mức tín hiệu với việc gửi xảy ra trước khi nhận.
Nếu bộ đệm không đầy, việc gửi có thể hoàn thành, ngược lại sẽ bị chặn.
Nếu bộ đệm không trống, việc nhận có thể hoàn thành, ngược lại sẽ bị chặn.

Một `channel` có thể ở trạng thái `closed` bằng cách sử dụng hàm tích hợp sẵn `close`.
Bạn không cần phải đóng `channel` để giải phóng bộ nhớ, nó chỉ để thay đổi trạng thái.
Gửi vào một `channel` đã đóng sẽ gây `panic`, tuy nhiên nhận từ một `channel` đã đóng
sẽ trả về ngay lập tức.

Với tất cả thông tin này, bạn có thể tập trung vào các mẫu `channel`.
Tập trung vào sự truyền dẫn tín hiệu là quan trọng.
Ý tưởng là, nếu bạn cần một sự đảm bảo ở mức tín hiệu hay không, dựa trên các vấn đề về độ trễ.
Nếu bạn cần truyền dữ liệu với tín hiệu hay không, dựa trên việc xử lý hủy bỏ hoặc không.
Bạn muốn chuyển đổi cú pháp thành các ý nghĩa này.

** Hướng dẫn thiết kế

- Đọc thêm các [[https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html][hướng dẫn thiết kế]] cho `channel`.

** Biểu đồ

*Guarantee* *Of* *Delivery* (*Đảm* *bảo* *giao* *nhận*)

Việc "đảm bảo giao nhận" dựa trên một câu hỏi: "Tôi có cần đảm bảo rằng tín hiệu được gửi
bởi một `goroutine` cụ thể đã được nhận hay chưa?"

.image /tour/eng/static/img/guarantee_of_delivery.png

*Signaling* *With* *Or* *Without* *Data* (*Truyền* *tín* *hiệu* *với* *hoặc* *không* *dữ* *liệu*)

Khi bạn truyền tín hiệu với dữ liệu, có ba tùy chọn cấu hình `channel` bạn có thể chọn
tùy thuộc vào loại "đảm bảo" bạn cần.

.image /tour/eng/static/img/signaling_with_data.png

Truyền tín hiệu không có dữ liệu phục vụ mục đích chính là hủy bỏ.
Nó cho phép một `goroutine` truyền tín hiệu cho một `goroutine` khác để hủy bỏ
những gì họ đang làm và tiếp tục. Hủy bỏ có thể được thực hiện bằng cả `unbuffered`
và `buffered` `channel`.

.image /tour/eng/static/img/signaling_without_data.png

*State* (*Trạng* *thái*)

Hành vi của một `channel` được ảnh hưởng trực tiếp bởi trạng thái hiện tại của nó.
Trạng thái của một `channel` có thể là `nil`, `open` hoặc `closed`.

.image /tour/eng/static/img/state.png

** Đọc thêm

- [[https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html][The Behavior Of Channels]] - William Kennedy  
- [[https://golang.org/ref/mem#tmp_7][Channel Communication]]    
- [[http://blog.golang.org/share-memory-by-communicating][Share Memory By Communicating]] - Andrew Gerrand    
- [[https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html][The Nature Of Channels In Go]] - William Kennedy    
- [[http://matt-welsh.blogspot.com/2010/07/retrospective-on-seda.html][A Retrospective on SEDA]] - Matt Welsh    
- [[https://www.youtube.com/watch?v=KBZlN0izeiY][Understanding Channels]] - Kavya Joshi    

** "Phù" bộ đệm - 2011

Hãy cẩn thận khi sử dụng bộ đệm lớn với ý tưởng làm giảm độ trễ.

- Bộ đệm lớn ngăn chặn thông báo kịp thời về áp lực phía sau.
- Chúng ngăn chặn khả năng giảm áp lực phía sau một cách kịp thời.
- Chúng có thể làm tăng độ trễ thay vì giảm nó.
- Dùng `buffered channel` để cung cấp một cách duy trì sự liên tục.
- Đừng sử dụng chúng chỉ vì hiệu suất.
- Sử dụng chúng để xử lý tốt các chuyển động dữ liệu được xác định trước.
- Sử dụng chúng để đối phó với các vấn đề về tốc độ ánh sáng giữa các chuyển động.

*Video*

- [[https://www.youtube.com/watch?v=qbIozKVz73g][Bufferbloat: Dark Buffers in the Internet]]  
- [[http://www.bufferbloat.net/projects/cerowrt/wiki/Bloat-videos][Buffer Bloat Videos]]  

* Bài tập

Dùng các mẫu như một điểm khởi đầu để hoàn thành các bài tập. Một bài giải có thể được cung cấp.

** Bài tập 1

Viết một chương trình trong đó hai `goroutine` truyền một số nguyên qua lại với nhau 10 lần.
Hiển thị khi mỗi `goroutine` nhận số nguyên. Tăng số nguyên với mỗi lần truyền.
Một khi số nguyên bằng 10, kết thúc chương trình một cách sạch sẽ.

.play channels/exercise1.go 
.play channels/answer1.go

** Bài tập 2

Viết một chương trình sử dụng "fan out pattern" để tạo ra 100 số ngẫu nhiên đồng thời.
Mỗi `goroutine` tạo ra một số ngẫu nhiên duy nhất và trả về số đó cho `goroutine` chính
qua một `buffered` `channel`. Đặt kích thước bộ đệm của `channel` để việc gửi không bao giờ
bị chặn. Đừng cấp phát nhiều bộ đệm hơn bạn cần. Cho phép `goroutine` chính hiển thị
mỗi số ngẫu nhiên nó nhận được và sau đó kết thúc chương trình.

.play channels/exercise2.go 
.play channels/answer2.go

** Bài tập 3

Viêt một chương trình tạo ra tối đa 100 số ngẫu nhiên đồng thời. Đừng gửi tất cả 100 giá trị
để số lượng gửi/nhận là không xác định. 

.play channels/exercise3.go 
.play channels/answer3.go
 
** Bài tập 4
s
Viết một chương trình tạo ra tối đa 100 số ngẫu nhiên đồng thời sử dụng một `worker pool`.
Từ chối các giá trị chẵn. Tắt các `worker` khi 100 số lẻ đã được thu thập.

.play channels/exercise4.go 
.play channels/answer4.go
