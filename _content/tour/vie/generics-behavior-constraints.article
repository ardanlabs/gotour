Hành vi như là Ràng buộc
Mỗi kiểu generic yêu cầu phải khai báo một ràng buộc để trình biên dịch biết những kiểu thay thế cụ thể nào nó có thể chấp nhận hoặc từ chối tại thời điểm biên dịch.

* Generics - Behavior As Constraint

Mỗi kiểu generic yêu cầu phải khai báo một ràng buộc để trình biên dịch biết
những kiểu thay thế cụ thể nào nó có thể chấp nhận hoặc từ chối tại thời điểm biên dịch.
Việc này bắt buộc ngay cả khi không có ràng buộc thực sự nào về kiểu generic có thể là gì,
do đó phải khai báo trước định danh ràng buộc any.

** Video

Hãy xem video của tôi về Generics, nó sẽ hướng dẫn bạn tất cả những
ví dụ trong phần này của Tour.

.html generics-video.html

** Code Review

- *Example* *1*: Hàm stringify cụ thể
- *Example* *2*: Type assertion hàm stringify
- *Example* *3*: Interface hàm stringify
- *Example* *4*: Hàm generic stringify

.play generics/behavior-constraints/example1.go
.play generics/behavior-constraints/example2.go
.play generics/behavior-constraints/example3.go
.play generics/behavior-constraints/example4.go

** Giải thích

Thật thú vị, khái niệm về ràng buộc đã tồn tại sẵn trong ngôn ngữ.

    type User struct {
        name string
    }
    
    func (u User) String() string {
        return u.name
    }
    
    type Stringer interface {
        String() string
    }
    
    func Concrete(u User) {
        u.String()
    }

    func Polymorphic(s Stringer) {
        s.String()
    }

Code này xác định một kiểu cụ thể có tên là User và thực hiện một phương thức có tên là
String trả về tên của người dùng. Sau đó một kiểu interface được khai báo có tên Stringer,
khai báo một hành vi String, trả về một chuỗi. Cảm ơn phương thức được khai báo cho User,
bạn có thể cho rằng kiểu cụ thể mà User thực hiện interface Stringer sử dụng ngữ nghĩa có giá trị.

Hàm Concrete chỉ là một hàm chấp nhận dữ liệu cụ thể dựa trên nó là gì. Hàm Polymorphic cũng chỉ như vậy,
một hàm chấp nhận dữ liệu cụ thể dựa trên những gì nó có thể làm. Đây là sự khác biệt chính
giữa chức năng concrete và polymorphic. Một cái được giới hạn ở một kiểu dữ liệu, cái còn lại thì không.
Tuy nhiên, có một ràng buộc về dữ liệu concrete nào có thể được chuyển vào hàm polymorphic.

Interface Stringer xác định ràng buộc đó bằng cách khai báo một tập hợp những hành vi
mà dữ liệu cụ thể đó phải có khả năng thể hiện được. Khi được áp dụng làm kiểu đầu vào,
trình biên dịch có thể đảm bảo ràng buộc về hành vi được đáp ứng mỗi khi hàm được gọi.

Có những hàm generic sẽ yêu cầu cùng kiểu ràng buộc về hành vi.

    func stringify[T fmt.Stringer](slice []T) []string {
        ret := make([]string, 0, len(slice))
        
        for _, value := range slice {
            ret = append(ret, value.String())
        }
        
        return ret
    }

Đây là hàm generic stringify (xâu chuỗi). Nó chấp nhận một slide thuộc kiểu T nào đó và trả về một
slice các giá trị chuỗi, chứa phiên bản được xâu chuỗi của mỗi giá trị từ bộ sưu tập đầu vào.
Chìa khóa để làm cho hàm này hoạt động là lệnh gọi phương thức String cho mỗi giá trị của kiểu T.

Vấn đề là trình biên dịch cần biết và xác minh rằng các giá trị kiểu T có
một phương thức tên String. Khi kiểu generic T được khai báo, interface fmt.Stringer
được cung cấp như là một ràng buộc. Trình biên dịch bấy giờ biết rằng kiểm tra bất kỳ kiểu
thay thế nào và dữ liệu được truyền vào hàm cho tập hợp phương thức của hành vi này.

Điều này thật tuyệt vời vì interface đang được sử dụng lại cho cùng một mục đích và
ngôn ngữ không cần thêm từ khóa mới.

* Bài tập

Sử dụng bài mẫu để bắt đầu giải quyết các bài tập. Một câu trả lời mẫu đã được cung cấp.

** Bài tập 1

Triển khai một hàm generic tên là marshal có thể sắp xếp JSON nhưng chỉ 
chấp nhận các giá trị implement interface json.Marshaler.

.play generics/behavior-constraints/exercise1.go 
.play generics/behavior-constraints/answer1.go
