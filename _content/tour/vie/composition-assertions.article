Chuyển đổi Kiểu và Xác nhận (Type Conversions And Assertions)
Cùng tìm hiểu cách làm việc của Chuyển đổi Kiểu và Xác nhận nhé.

* Chuyển đổi Kiểu và Xác nhận

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Xem Video]]
- Cần hỗ trợ Học phí, hãy sử dụng [[https://www.ardanlabs.com/scholarship/] [Đơn xin Học bổng]] của chúng tôi

Type Conversion cho phép dữ liệu của một kiểu chuyển sang loại khác. Một loại
khai báo cho phép bạn đặt câu hỏi nếu có một giá trị thuộc kiểu đã cho được lưu trữ
bên trong một interface.

** Code Review

- *Ví dụ* *1:* Interface Conversions
- *Ví dụ* *2:* Runtime Type Assertions
- *Ví dụ* *3:* Behavior Changes

.chạy composition/assertions/example1.go
.chạy composition/assertions/example2.go
.chạy composition/assertions/example3.go

** Chuyển đổi Interface Ngầm

Như bạn đã thấy trong ví dụ trước, một giá trị interface thuộc một kiểu có thể
được truyền cho một kiểu interface khác nếu giá trị cụ thể được lưu trữ bên trong
interface thực hiện cả hai hành vi. Đây có thể được coi là một sự chuyển đổi
interface ngầm, nhưng tốt hơn nên nghĩ về cách dữ liệu cụ thể được di chuyển qua
các interface trong một trạng thái tách rời.

    type Mover interface {
        Move()
    }

    type Locker interface {
        Lock()
        Unlock()
    }

    type MoveLocker interface {
        Mover
        Locker
    }

Với ba interface này thì MoveLocker là sự kết hợp của Mover và Locker.

    type bike struct{}

    func (bike) Move() {
        fmt.Println("Moving the bike")
    }

    func (bike) Lock() {
        fmt.Println("Locking the bike")
    }

    func (bike) Unlock() {
        fmt.Println("Unlocking the bike")
    }

Và với kiểu bike cụ thể này implement cả ba interface. Bạn có thể làm gì?

    var ml MoveLocker
    var m Mover

Bạn có thể xây dựng một giá trị thuộc kiểu MoveLocker và Mover về trạng thái zero value.
Đây là những giá trị interface thực sự vô giá trị.

    ml = bike{}

Sau đó, bạn có thể xây dựng một giá trị của kiểu bike về trạng thái zero value và gán một
bản sao vào biến MoveLocker ml. Điều này có thể thực hiện được vì bike implement
cả ba hành vi và trình biên dịch có thể thấy rằng việc triển khai có tồn tại.

    m = ml

Sau đó, bạn có thể gán biến MoveLocker ml cho biến Mover m. Điều này khả thi bởi vì
tôi không gán giá trị interface ml mà là giá trị cụ thể được lưu trữ bên trong
ml (là giá trị bike). Trình biên dịch biết bất kỳ giá trị cụ thể nào được lưu trữ bên trong
ml cũng phải triển khai interface Mover.

Tuy nhiên, việc sau đây không hợp lệ. 

    ml = m

Đầu ra:

    cannot use m (type Mover) as type MoveLocker in assignment:
        Mover does not implement MoveLocker (missing Lock method)

Bạn không thể gán lại biến Mover m cho biến MoverLocker ml vì trình biên dịch chỉ có thể
đảm bảo rằng giá trị cụ thể được lưu trữ bên trong m biết cách Move. Tại thời điểm biên dịch,
nó không biết liệu giá trị cụ thể có biết cách Lock và Unlock hay không.

** Cơ chế xác nhận kiểu (Type Assertion Mechanics)

Type assertion cho phép bạn đặt câu hỏi lúc runtime, liệu có giá trị nào của
kiểu đã cho được lưu trữ bên trong một interface. Bạn thấy điều đó với cú pháp m.(bike).

    b := m.(bike)
    ml = b

Trong trường hợp này, bạn đang hỏi liệu có giá trị bike nào được lưu trữ bên trong m tại
thời điểm mã được thực thi không. Nếu có thì biến b sẽ được cấp một bản sao của giá trị
được lưu trữ bike. Sau đó, bản sao có thể được sao chép bên trong biến interface ml.

Nếu không có giá trị bike được lưu trữ bên trong giá trị interface thì chương trình sẽ panic.
Bạn muốn lẽ ra phải có một giá trị bike được lưu trữ. Điều gì sẽ xảy ra nếu có một giá trị bike
và đó có hợp lệ không? Do đó, bạn cần dạng thứ hai của type assertion.

    b, ok := m.(bike)

Trong dạng này, nếu ok là true thì sẽ có giá trị bike được lưu trữ bên trong interface.
Nếu ok là false thì không có bike nào được lưu trữ và chương trình không panic.
Tuy nhiên, biến b vẫn thuộc kiểu bike nhưng nó được đặt ở trạng thái zero value.

    func main() {
        mvs := []fmt.Stringer{
            Car{},
            Cloud{},
        }

        for i := 0; i < 10; i++ {
            rn := rand.Intn(2)

            if v, is := mvs[rn].(Cloud); is {
                fmt.Println("Got Lucky:", v)
                continue
            }

            fmt.Println("Got Unlucky")
        }
    }

Giả sử chương trình khai báo hai kiểu có tên là Car và Cloud mà mỗi kiểu implement
interface fmt.Stringer, bạn có thể xây dựng một collection cho phép bạn lưu trữ một
giá trị của cả Car và Cloud. Sau đó 10 lần, bạn chọn ngẫu nhiên một số từ 0 đến 1,
và thực hiện type assertion để xem liệu giá trị tại chỉ mục ngẫu nhiên đó có chứa một
giá trị Cloud không. Vì có thể nó không thuộc kiểu Cloud nên dạng thứ hai của
type assertion là cực kỳ quan trọng ở đây.