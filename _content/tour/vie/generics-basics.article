Basics
Cùng tìm hiểu cách để viết một hàm generic print cơ bản.

* Generics - Basics

Cùng tìm hiểu cách để viết một hàm generic print cơ bản.

** Video

Hãy xem video của tôi về Generics, nó sẽ hướng dẫn bạn tất cả những
ví dụ trong phần này của Tour.

.html generics-video.html

** Code Review

- *Example* *1*: Triển khai cụ thể của print
- *Example* *2*: Triển khai Type Assertion của print
- *Example* *3*: Triển khai Reflection của print
- *Example* *4*: Triển khai generic của print

.play generics/basics/example1.go
.play generics/basics/example2.go
.play generics/basics/example3.go
.play generics/basics/example4.go

** Giải thích

Nếu bạn muốn viết một hàm print duy nhất có thể xuất ra một slice thuộc bất kỳ loại nào
và không sử dụng reflection, bạn có thể sử dụng cú pháp generics mới.

    func print[T any](slice []T) {
        fmt.Print("Generic: ")
        
        for _, v := range slice {
            fmt.Print(v, " ")
        }

        fmt.Print("\n")
    }

Đây là việc triển khai một hàm print đơn lẻ có thể xuất ra một slice kiểu bất kỳ
đã cho bằng cách sử dụng cú pháp generics mới. Điều thú vị về cú pháp này là
code bên trong hàm có thể sử dụng cú pháp và các hàm built-in có thể hoạt động với
một kiểu cụ thể. Đây không phải là trường hợp khi bạn sử dụng interface rỗng để viết
code generic.

Cần phải có một cách để thông báo cho trình biên dịch rằng bạn sẽ không khai báo kiểu T
một cách rõ ràng, nhưng nó phải được trình biên dịch xác định tại thời điểm biên dịch.
Cú pháp mới sử dụng dấu ngoặc vuông. Các dấu ngoặc xác định một danh sách các mã định danh
generic đại diện cho các kiểu cụ thể cho hàm cần được định nghĩa tại thời điểm biên dịch.
Đó là cách bạn báo cho trình biên dịch biết rằng các kiểu với tên này sẽ không được khai báo
trước khi chương trình được biên dịch. Những kiểu này cần phải được tính toán ra tại thời điểm biên dịch.

Chú ý: Bạn có thể có nhiều kiểu định danh được xác định bên trong dấu ngoặc dù hiện tại chỉ sử dụng một.
Ví dụ: [T, S, R any]

Bạn có thể đặt tên cho các kiểu định danh này bất cứ tên gì bạn muốn để giúp dễ đọc code.
Trong trường hợp này, code đang sử dụng ký tự T in hoa để mô tả một slide thuộc kiểu T nào đó
(được xác định tại thời điểm biên dịch) sẽ được chuyển vào. Đó là một thành ngữ để sử dụng
các chữ cái viết hoa đơn lẻ khi nói đến các collection và đó cũng là một convention được áp dụng
cho các ngôn ngữ lập trình cũ hơn như C++ và Java.

Ngoài ra còn có cách sử dụng any bên trong dấu ngoặc. Điều này thể hiện một sự ràng buộc về kiểu T
có thể là kiểu gì. Trình biên dịch yêu cầu tất cả các kiểu generic phải có một ràng buộc được
xác định rõ ràng. Ràng buộc any được khai báo trước bởi trình biên dịch và nói rằng không có
ràng buộc nào về kiểu T cả.

    numbers := []int{1, 2, 3}
    print[int](numbers)

    strings := []string{"A", "B", "C"}
    print[string](strings)
    
    floats := []float64{1.7, 2.2, 3.14}
    print[float64](floats)

Đây là cách thực hiện việc call đến hàm print generic nơi thông tin kiểu cho T được cung cấp
rõ ràng tại vị trí call. Cú pháp mô phỏng ý tưởng rằng khai báo hàm func name[T Any](slice []T)
xác định hai tập tham số. Tập đầu tiên là loại ánh xạ tới các kiểu định danh tương ứng và
thứ hai là dữ liệu ánh xạ tới các biến đầu vào tương ứng.

May mắn thay, trình biên dịch có thể suy ra kiểu và loại bỏ nhu cầu chuyển thông tin kiểu vào
một cách rõ ràng tại vị trí call.

    numbers := []int{1, 2, 3}
    print(numbers)
    
    strings := []string{"A", "B", "C"}
    print(strings)
    
    floats := []float64{1.7, 2.2, 3.14}
    print(floats)

Code này cho thấy cách bạn có thể gọi các hàm print generic mà không cần phải chuyển
thông tin kiểu một cách rõ ràng. Tại nơi gọi hàm, trình biên dịch có thể xác định kiểu
sử dụng cho T và xây dựng một phiên bản cụ thể của hàm để hỗ trợ các slice thuộc kiểu đó.
Trình biên dịch có khả năng suy ra kiểu dữ liệu với thông tin nó có tại nơi gọi
từ dữ liệu được truyền vào.

* Bài tập

Sử dụng bài mẫu làm điểm khởi đầu để hoàn thành các bài tập. Một đáp án mẫu đã được cung cấp.

** Bài tập 1

Triển khai một hàm generic có tên là marshal, hàm này có thể chấp nhận bất kỳ giá trị nào
và sắp xếp giá trị đó thành JSON, trả về JSON và một lỗi. Khai báo một kiểu struct
có tên User với hai trường Name và Age. Sau đó xây dựng một giá trị của kiểu User và
chuyển giá trị đó cho hàm marshal generic.

.play generics/basics/exercise1.go 
.play generics/basics/answer1.go
