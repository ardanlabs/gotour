Pointers
Pointers provide a way to share data across program boundaries. Having the ability to share and reference data with a pointer provides the benefit of efficiency. There is only one copy of the data and everyone can see it changing. The cost is that anyone can change the data which can cause side effects in running programs.


* Pointers

Pointers provide a way to share data across program boundaries. Having the ability to share and reference data with a pointer provides the benefit of efficiency. There is only one copy of the data and everyone can see it changing. The cost is that anyone can change the data which can cause side effects in running programs.

* Notes

- Use pointers to share data.
- Values in Go are always pass by value.
- "Value of", what's in the box. "Address of" ( **&** ), where is the box.
- The (*) operator declares a pointer variable and the "Value that the pointer points to".

* Escape Analysis

- When a value could be referenced after the function that constructs the value returns.
- When the compiler determines a value is too large to fit on the stack.
- When the compiler doesnâ€™t know the size of a value at compile time.
- When a value is decoupled through the use of function or interface values.

* Garbage Collection History

The design of the Go GC has changed over the years:

- Go 1.0, Stop the world mark sweep collector based heavily on tcmalloc.
- Go 1.2, Precise collector, wouldn't mistake big numbers (or big strings of text) for pointers.
- Go 1.3, Fully precise tracking of all stack values.
- Go 1.4, Mark and sweep now parallel, but still stop the world.
- Go 1.5, New GC design, focusing on latency over throughput.
- Go 1.6, GC improvements, handling larger heaps with lower latency.
- Go 1.7, GC improvements, handling larger number of idle goroutines, substantial stack size fluctuation, or large package-level variables.
- Go 1.8, GC improvements, collection pauses should be significantly shorter than they were in Go 1.7, usually under 100 microseconds and often as low as 10 microseconds.
- Go 1.9, Large object allocation performance is significantly improved in applications using large (>50GB) heaps containing many large objects.
- Go 1.10, Many applications should experience significantly lower allocation latency and overall performance overhead when the garbage collector is active.

Garbage Collection Semantics

- [[https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html][Garbage Collection Semantics Part I]] - William Kennedy

* Stack vs Heap

"The stack is for data that needs to persist only for the lifetime of the function that constructs it, and is reclaimed without any cost when the function exits. The heap is for data that needs to persist after the function that constructs it exits, and is reclaimed by a sometimes costly garbage collection." - Ayan George

* Links

Pointer Mechanics

- [[https://golang.org/doc/effective_go.html#pointers_vs_values][Pointers vs. Values]]    
- [[https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html][Language Mechanics On Stacks And Pointers]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2014/12/using-pointers-in-go.html][Using Pointers In Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/07/understanding-pointers-and-memory.html][Understanding Pointers and Memory Allocation]] - William Kennedy    

Stacks

- [[https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub][Contiguous Stack Proposal]]  

Escape Analysis and Inlining

- [[https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw][Go Escape Analysis Flaws]]  
- [[https://github.com/golang/go/wiki/CompilerOptimizations][Compiler Optimizations]]

Garbage Collection

- [[http://gchandbook.org/][The Garbage Collection Handbook]]  
- [[https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md][GC Pacer Redesign - 2021]] - Michael Knyszek  
- [[https://en.wikipedia.org/wiki/Tracing_garbage_collection][Tracing Garbage Collection]]  
- [[https://blog.golang.org/go15gc][Go Blog - 1.5 GC]] 
- [[https://www.youtube.com/watch?v=aiv1JOfMjm0&index=16&list=PL2ntRZ1ySWBf-_z-gHCOR2N156Nw930Hm][Go GC: Solving the Latency Problem]]  
- [[http://rubinius.com/2013/06/22/concurrent-garbage-collection][Concurrent garbage collection]]  
- [[https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit][Go 1.5 concurrent garbage collector pacing]]  
- [[https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md][Eliminating Stack Re-Scanning]]  
- [[https://groups.google.com/forum/m/#!topic/golang-nuts/KJiyv2mV2pU][Why golang garbage-collector not implement Generational and Compact gc?]] - Ian Lance Taylor  
- [[https://blog.golang.org/ismmkeynote][Getting to Go: The Journey of Go's Garbage Collector]] - Rick Hudson  
- [[https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html][Garbage Collection In Go : Part I - Semantics]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html][Garbage Collection In Go : Part II - GC Traces]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html][Garbage Collection In Go : Part III - GC Pacing]] - William Kennedy  
- [[https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/][Go memory ballast: How I learnt to stop worrying and love the heap]] - Ross Engers  

Static Single Assignment Optimizations

- [[https://www.youtube.com/watch?v=D2-gaMvWfQY][GopherCon 2015: Ben Johnson - Static Code Analysis Using SSA]]  
- [[https://godoc.org/golang.org/x/tools/go/ssa][package ssa]]    
- [[https://www.youtube.com/watch?v=FnGCDLhaxKU][Understanding Compiler Optimization]]

Debugging code generation

- [[https://rakyll.org/codegen/][Debugging code generation in Go]] - JBD    

* Code Review

- *Example* *1:* Pass by Value
- *Example* *2:* Sharing Data I
- *Example* *3:* Sharing Data II
- *Example* *4:* Escape Analysis
- *Example* *5:* Stack Grow

.play pointers/example1/example1.go

.play pointers/example2/example2.go
.play pointers/example3/example3.go
.play pointers/example4/example4.go
.play pointers/example5/example5.go


* Excercises

Escape Analysis Flaws

Excercise 1

.play pointers/flaws/example1/example1_test.go


Exercise 2

Declare a struct type and create a value of this type. Declare a function that can change the value of some field in this struct type. Display the value before and after the call to your function.

.play pointers/exercises/template2/template2.go


* Answer

.play pointers/exercises/exercise1/exercise1.go
.play pointers/exercises/exercise2/exercise2.go



All material is licensed under the [[http://www.apache.org/licenses/LICENSE-2.0][Apache License Version 2.0, January 2004]].
