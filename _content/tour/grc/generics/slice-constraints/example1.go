//go:build OMIT

// Όλα τα υλικά είναι αδειοδοτημένα υπό την Άδεια Apache Έκδοση 2.0, Ιανουάριος 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Δείγμα προγράμματος, προκειμένου να παρουσιαστεί ο τρόπος ορισμού
// περιορισμών με βάση φέτες.
package main

import (
	"fmt"
)

// Η operateFunc ορίζει ένα τύπο συνάρτησης, που παίρνει μια τιμή
// κάποιου τύπου T και επιστρέφει μια τιμή του ίδιου τύπου T
// (που θα προσδιοριστεί αργότερα).
//
// Η Slice ορίζει ένα περιορισμό ώστε τα δεδομένα είναι μια φέτα
// κάποιου τύπου T (που θα προσδιοριστεί αργότερα).

type operateFunc[T any] func(t T) T

type Slice[T any] interface {
	~[]T
}

// Όταν είναι σημαντικό η φέτα που περνάει ως είσοδος να είναι ακριβώς η
// ίδια με την φέτα που επιστρέφεται, χρησιμοποιήστε έναν περιορισμό
// τύπου για φέτες. Αυτό εξασφαλίζει ότι η φέτα S που επιστρέφεται
// ως αποτέλεσμα είναι η ίδια με την εισερχόμενη φέτα S.

func operate[S Slice[T], T any](slice S, fn operateFunc[T]) S {
	ret := make(S, len(slice))
	for i, v := range slice {
		ret[i] = fn(v)
	}
	return ret
}

// Αν δεν σας ενδιαφέρει ο περιορισμός που ορίστηκε παραπάνω, τότε η
// operate2 παρέχει μια απλούστερη μορφή. Η operate2 δουλεύει επειδή
// μπορείς ακόμα να εκχωρήσεις μια φέτα κάποιου τύπου T στα ορίσματα
// εισόδου και εξόδου. Όμως οι πραγματικοί τύποι των ορισμάτων εισόδου
// και εξόδου θα βασίζονται στους υποκείμενους τύπους. Σε αυτή την
// περίπτωση, πρόκειται όχι για μια φέτα από Numbers, αλλά για μια
// φέτα από ακέραιους. Αυτό δεν ισχύει με την συνάρτηση operate, παραπάνω.

func operate2[T any](slice []T, fn operateFunc[T]) []T {
	ret := make([]T, len(slice))
	for i, v := range slice {
		ret[i] = fn(v)
	}
	return ret
}

// Η υποψία είναι ότι τον περισσότερο καιρό η operate2 είναι αυτό
// που ζητάτε: είναι απλούστερη και περισσότερο ευέλικτη: Μπορεί
// κανείς πάντα να εκχωρήσει μια []int σε μια μεταβλητή Numbers
// και το αντίστροφο. Όμως αν χρειάζεστε να διατηρήσετε τον
// εισερχόμενο τύπο και στο αποτέλεσμα για κάποιο λόγο, θα πρέπει
// να χρησιμοποιήσετε την operate.

// =============================================================================

// Αυτός ο κώδικας ορίζει έναν επώνυμο τύπο, που βασίζεται σε μια
// φέτα από ακέραιους. Ένας ακέραιος είναι ο υποκείμενος τύπος.
//
// Η Double είναι μια συνάρτηση, που παίρνει μια τιμή τύπου Numbers,
// πολλαπλασιάζει κάθε τιμή στην υποκείμενη φέτα ακεραίων και επιστρέφει
// αυτή την νέα τιμή Numbers.
//
// Η Γραμμή 73 έχει μετατραπεί σε σχόλιο επειδή ο μεταγλωττιστής είναι
// αρκετά έξυπνος, ώστε να συνάγει τους τύπους για τους S και T. Ο κώδικας
// στο σχόλιο παρουσιάζει τους τύπους, που συνάγονται.
//
// Η operate2 δεν χρησιμοποιείται στο παράδειγμα.

type Numbers []int

func DoubleUnderlying(n Numbers) Numbers {
	fn := func(n int) int {
		return 2 * n
	}

	numbers := operate2(n, fn)
	fmt.Printf("%T", numbers)
	return numbers
}

func DoubleUserDefined(n Numbers) Numbers {
	fn := func(n int) int {
		return 2 * n
	}

	numbers := operate(n, fn)
	fmt.Printf("%T", numbers)
	return numbers
}

// =============================================================================

func main() {
	n := Numbers{10, 20, 30, 40, 50}
	fmt.Println(n)

	n = DoubleUnderlying(n)
	fmt.Println(n)

	n = DoubleUserDefined(n)
	fmt.Println(n)
}
