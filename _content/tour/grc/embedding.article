Ενσωμάτωση 
Οι ενσωματωμένοι τύποι παρέχουν το τελευταίο στοιχείο, που διευκολύνει τον καταμερισμό και την επαναχρησιμοποίηση κατάστασης και συμπεριφοράς, μεταξύ τύπων.

* Ενσωμάτωση

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εάν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιήστε το Σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Οι ενσωματωμένοι τύποι παρέχουν το τελευταίο στοιχείο, που διευκολύνει τον 
καταμερισμό και την επαναχρησιμοποίηση κατάστασης και συμπεριφοράς, 
μεταξύ τύπων. Μέσω της χρήσης της προαγωγής εσωτερικών τύπων, τα 
πεδία και οι μέθοδοι τύπου ενός εσωτερικού τύπου, μπορούν να είναι
άμεσα προσβάσιμα, με αναφορές του εξωτερικού τύπου

** Επισκόπηση Κώδικα 

- *Παράδειγμα* *1:* Δηλώσεις Πεδίων 			   
- *Παράδειγμα* *2:* Ενσωματώνοντας Τύπους
- *Παράδειγμα* *3:* Ενσωματωμένοι τύποι και διεπαφές
- *Παράδειγμα* *4:* Υλοποιήσεις διεπαφών εξωτερικών και εσωτερικών τύπων 
	
.play embedding/example1.go
.play embedding/example2.go
.play embedding/example3.go		   
.play embedding/example4.go

** Μηχανισμοί Ενσωμάτωσης

Αυτό το πρώτο παράδειγμα δεν παρουσιάζει την ενσωμάτωση, δείχνει μόνο την δήλωση δύο τύπων struct
που λειτουργούν μαζί, ως ένα πεδίο από τον ένα τύπο, στον άλλο.

    type user struct {
        name  string
        email string
    }

    type admin struct {
        person user        // ΔΕΝ Πρόκειται για Ενσωμάτωση
        level  string
    }

Αντίθετα, το παρακάτω παρουσιάζει την ενσωμάτωση.

    type user struct {
        name  string
        email string
    }

    type admin struct {
        user               // Ενσωμάτωση Σημειολογίας Τιμής
        level  string
    }

Το πεδίο person απομακρύνεται και παραμένει μόνο το όνομα, του τύπου. Μπορεί κανείς να 
ενσωματώσει ένα τύπο, κάνοντας χρήση σημειολογίας δείκτη διεύθυνσης.

    type user struct {
        name  string
        email string
    }

    type admin struct {
        *user              // Ενσωμάτωση Σημειολογίας Δείκτη Διεύθυνσης
        level  string
    }

Σε αυτή την περίπτωση, ενσωματώνεται ένας δείκτης διεύθυνσης, του τύπου. Σε κάθε περίπτωση,
η πρόσβαση στην ενσωματωμένη τιμή γίνεται μέσω της χρήσης του ονόματος, του τύπου.

Ο καλύτερος τρόπος να σκεφτεί κανείς σχετικά με την ενσωμάτωση, είναι να δει τον τύπο user, σαν 
ένα εσωτερικό τύπο και τον admin, σαν ένα εξωτερικό τύπο. Είναι ακριβώς αυτή η σχέση μεταξύ 
εσωτερικών/εξωτερικών που είναι μαγική διότι, εξαιτίας της ενσωμάτωσης, οτιδήποτε σχετίζεται 
με τον εσωτερικό τύπο (τόσο τα πεδία, όσο και οι μέθοδοι τύπων) είναι δυνατόν να προαχθεί ένα
επίπεδο επάνω, στον εξωτερικό τύπο.

    type user struct {
        name  string
        email string
    }

    func (u *user) notify() {
        fmt.Printf("Sending user email To %s<%s>\n",
            u.name,
            u.email)
    }

    type admin struct {
        *user              // Ενσωμάτωση Σημειολογίας Δείκτη Διεύθυνσης 
        level  string
    }

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        ad.user.notify()
        ad.notify() // Προαγωγή προς τον εξωτερικό τύπο 
    }

Αποτέλεσμα:

    Sending user email To john smith<john@yahoo.com>
    Sending user email To john smith<john@yahoo.com>

Από την στιγμή που προστίθεται μια μέθοδος τύπου με το όνομα notify για τον τύπο user 
και στην συνέχεια μια μικρή συνάρτηση main, μπορεί να δει κανείς, ότι το 
αποτέλεσμα είναι το ίδιο, είτε καλέσει κανείς την μέθοδο τύπου notify απευθείας, μέσω 
της τιμής του εσωτερικού δείκτη διεύθυνσης ή μέσω της τιμής του εξωτερικού τύπου.
Η μέθοδος notify δηλώνεται για τον τύπο user και είναι προσβάσιμη απευθείας, από την
τιμή τύπου admin.

Μολονότι κάτι σαν αυτό παραπάνω, μοιάζει με την κληρονομικότητα, οφείλει κανείς να είναι 
προσεκτικός. Το παραπάνω δεν αφορά την επαναχρησιμοποίηση της κατάστασης, αλλά αφορά την 
προαγωγή της συμπεριφοράς (στμ. ένα επίπεδο τύπου επάνω).

    type notifier interface {
        notify()
    }

    func sendNotification(n notifier) {
        n.notify()
    }

Παραπάνω προστίθεται μια διεπαφή και μια πολυμορφική συνάρτηση που αποδέχεται κάθε 
πραγματική τιμή, που υλοποιεί το πλήρες σύνολο μεθόδων τύπου της συμπεριφοράς, που 
ορίζεται από την διεπαφή notifier. Που, εν τέλει, πρόκειται απλά για μια μονάχα 
μέθοδο τύπου, με το όνομα notify.

Εξαιτίας της ενσωμάτωσης και της προαγωγής, οι τιμές του τύπου admin, τώρα, υλοποιούν 
την διεπαφή.

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        sendNotification(&ad)
    }

Αποτέλεσμα:

    Sending user email To john smith<john@yahoo.com>

Κανείς, μπορεί να αποστείλει την διεύθυνση μνήμης της τιμής admin, στην πολυμορφική συνάρτηση, 
καθώς η ενσωμάτωση προωθεί την συμπεριφορά notify προς τα επάνω, στον τύπο admin.

    type admin struct {
        *user  // Ενσωμάτωση Σημειολογίας Δείκτη Διεύθυνσης
        level  string
    }

    func (a *admin) notify() {
        fmt.Printf("Sending admin Email To %s<%s>\n",
            a.name,
            a.email)
    }

Όταν ο εξωτερικός τύπος υλοποιεί μια μέθοδο τύπου, που είναι ήδη υλοποιημένη από τον εσωτερικό 
τύπο, η προώθηση δεν πραγματοποιείται. 

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        sendNotification(&ad)
    }

Αποτέλεσμα:
    
    Sending admin email To john smith<john@yahoo.com>

Κανείς, μπορεί να παρατηρήσει ότι, τώρα εκτελείται η μέθοδος τύπου, του εξωτερικού τύπου.

** Σημειώσεις

- Η ενσωμάτωση τύπων επιτρέπει τον διαμοιρασμό της κατάστασης ή της συμπεριφοράς μεταξύ τύπων.
- Ο εσωτερικός τύπος δεν χάνει ποτέ την ταυτότητα του.
- Δεν πρόκειται για κληρονομικότητα.
- Μέσω της προαγωγής, τα πεδία των εσωτερικών τύπων και οι μέθοδοι τύπων μπορούν να είναι προσβάσιμοι, 
  μέσω του εξωτερικού τύπου.
- Ο εξωτερικός τύπος μπορεί να παρακάμψει την συμπεριφορά του εσωτερικού τύπου.

** Πρόσθετα Αναγνώσματα

- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Μέθοδοι τύπων, Διεπαφές και Ενσωματωμένοι Τύποι στην Go]] - William Kennedy    
- [[https://rakyll.org/typesystem/][Η Ενσωμάτωση δεν είναι κληρονομικότητα]] - JBD  

* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

Αλλάξτε τον κώδικα από το πρότυπο. Προσθέστε ένα νέο τύπο CachingFeed που ενσωματώνει τον Feed και 
παρακάμπτει την μέθοδο τύπου Fetch.

.play embedding/exercise1.go
.play embedding/answer1.go
