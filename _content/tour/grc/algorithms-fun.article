Διασκεδαστικά Προβλήματα
Αυτό το τμήμα περιέχει ένα σύνολο διασκεδαστικών προκλήσεων κώδικα, που επιδεικνύουν κάποιες από τις δυνατότητες που προσφέρει η Go.

* Πρόβλημα Κοιμώμενου Κουρέα

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εάν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιήστε το Σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Αυτό το παράδειγμα προγράμματος υλοποιεί το πρόβλημα του κοιμώμενου κουρέα.

- Περισσότερες πληροφορίες στο [[https://en.wikipedia.org/wiki/Sleeping_barber_problem][https://en.wikipedia.org/wiki/Sleeping_barber_problem]]

Υπάρχει ένας κουρέας στο κουρείο, μια καρέκλα για κούρεμα και `n` καρέκλες
για πελάτες σε αναμονή να εξυπηρετηθούν. Αν δεν υπάρχουν πελάτες, ο κουρέας
κάθεται στην καρέκλα για κούρεμα και παίρνει έναν υπνάκο. Ένας νέος πελάτης
πρέπει να ξυπνήσει τον κουρέα. Οι επόμενοι πελάτες περιμένουν στις καρέκλες, που
είναι διαθέσιμες για αναμονή αν υπάρχουν ακόμα άδειες ή φεύγουν, αν όλες οι 
καρέκλες είναι γεμάτες.

*Αποτέλεσμα:*

    Opening the shop
    Barber ready to work
    Customer "cust-1" entered shop
    Customer "cust-1" takes a seat and waits
    Barber servicing customer "cust-1"
    Barber finished customer "cust-1"
    Barber taking a nap
    Customer "cust-2" entered shop
    Customer "cust-2" takes a seat and waits
    Barber servicing customer "cust-2"
    Customer "cust-3" entered shop
    Customer "cust-3" takes a seat and waits
    Barber finished customer "cust-2"
    Barber servicing customer "cust-3"
    Customer "cust-4" entered shop
    Customer "cust-4" takes a seat and waits
    Closing the shop
    Barber finished customer "cust-3"
    Barber servicing customer "cust-4"
    Barber finished customer "cust-4"
    Shop closed

.play algorithms/fun/barber.go

* Συχνότητα

Αυτό το παράδειγμα προγράμματος παρουσιάζει, πως να υλοποιηθεί μια 
συνάρτηση, η οποία μπορεί να βρει την συχνότητα εμφάνισης ενός rune,
που χρησιμοποιείται σε συγκεκριμένη πρόταση.

- Σειριακή: Ένας γραμμικός αλγόριθμος, που πραγματοποιεί την μέτρηση των rune.
- Ταυτόχρονη: Ένας αλγόριθμος ταυτόχρονης εκτέλεσης, που πραγματοποιεί την μέτρηση των rune.

.play algorithms/fun/freq_sequential.go
.play algorithms/fun/freq_concurrent.go

* Κωδικοποίηση/Αποκωδικοποίηση Ποσότητας Μεταβλητού Μήκους.

Αυτό το παράδειγμα προγράμματος, επιδεικνύει πως η Go μπορεί να χρησιμοποιηθεί, προκειμένου να 
υλοποιηθεί κωδικοποίηση/αποκωδικοποίηση ποσότητας μεταβλητού μήκους.

- Περισσότερες πληροφορίες στο [[https://en.wikipedia.org/wiki/Variable-length_code][https://en.wikipedia.org/wiki/Variable-length_code]]

Εν συντομία, ο στόχος αυτής της κωδικοποίησης είναι η κωδικοποίηση ακέραιων
τιμών με τέτοιο τρόπο, ώστε να εξοικονομηθούν byte. Μόνο τα πρώτα 7 bit κάθε
byte είναι σημαντικά (δεξιά στοίχιση, περίπου όπως συμβαίνει και με ένα byte
κωδικοποίησης ASCII). Συνεπώς, αν κανείς έχει μια τιμή 32-bit, πρέπει να την 
αναλύσει σε μια σειρά από byte των 7-bit. Ασφαλώς, θα υπάρχει ένα μεταβλητό πλήθος 
byte, που θα εξαρτάται από τον συγκεκριμένο ακέραιο. Προκειμένου να υποδειχθεί
ποιό είναι το τελευταίο byte στην σειρά, αφήνει κανείς το 7ο bit καθαρό. Σε 
όλα τα προηγούμενα byte, το 7ο bit λαμβάνει τιμή.

Επομένως, αν ένας ακέραιος βρίσκεται μεταξύ των 0-127, μπορεί να αναπαρασταθεί
ως ένα byte. Ο μεγαλύτερος ακέραιος που επιτρέπεται είναι ο 0FFFFFFF, που 
μεταφράζεται σε μεταβλητό μήκος 4 byte. Παρακάτω, παρουσιάζονται παραδείγματα 
διαφορών χρόνου ως τιμές 32-bit, καθώς και οι ποσότητες μεταβλητού μήκους, στις 
οποίες αυτές μεταφράζονται:

    ΑΡΙΘΜΟΣ        ΜΕΤΑΒΛΗΤΗ ΠΟΣΟΤΗΤΑ
    00000000              00
    00000040              40
    0000007F              7F
    00000080             81 00
    00002000             C0 00
    00003FFF             FF 7F
    00004000           81 80 00
    00100000           C0 80 00
    001FFFFF           FF FF 7F
    00200000          81 80 80 00
    08000000          C0 80 80 00
    0FFFFFFF          FF FF FF 7F

Μια ποσότητα μεταβλητού μήκους (VLQ) είναι ένας γενικός τρόπος κωδικοποίησης, 
που χρησιμοποιεί ένα αυθαίρετο αριθμό δυαδικών οκτάδων (byte αποτελούμενα από οκτώ bit), 
προκειμένου να αναπαρασταθεί ένας αυθαίρετα μεγάλος αριθμός. Είχε οριστεί, προκειμένου να
χρησιμοποιηθεί στην προδιαγραφή αρχείων MIDI[1], ώστε να εξοικονομηθεί ο πρόσθετος 
χώρος, σε κάποιο σύστημα με περιορισμούς πόρων και είναι επίσης σε χρήση στον μετέπειτα 
τύπο αρχείου Επεκτάσιμης Διαμόρφωσης Μουσικής (XMF). Ένα VLQ είναι ουσιαστικά μια 
αναπαράσταση βάσης 128, ενός ακέραιου χωρίς πρόσημο, με την προσθήκη του όγδοου bit να 
σηματοδοτεί την συνέχιση των byte. Περισσότερα, στο παρακάτω παράδειγμα.

	Int:    16384
	IntHex: 0x00004000
	IntBin: 00000000 00000000 01000000 00000000
	VLQHex: 0x81 0x80 0x00
	VLQBin: 00000000 10000001 10000000 00000000

Έστω ότι θέλει κανείς να αναπαραστήσει τον αριθμό 3435 με VLQ. Το 3435 σε
στο δυαδικό σύστημα είναι 110101101011. Αυτό δεν χωράει σε ένα byte. Επομένως,
θα κοπεί από το τέλος σε τμήματα των 7 bit.

    Επτάδα	7	6	5	4	3	2	1
    #1		1	1	0	1	0	1	1
    #2		0	0	1	1	0	1	0

Στην συνέχεια, προστίθεται στην αρχή σε όλες, εκτός από την τελευταία επτάδα, 
η τιμή 1-bit, προκειμένου να σηματοδοτηθεί ότι ακολουθεί μια ακόμα οχτάδα, 
ενώ προστίθεται στην αρχή της τελευταίας επτάδας η τιμή 0-bit, που σηματοδοτεί 
ότι πρόκειται για την τελευταία οκτάδα. 

    Οκτάδα   8	7	6	5	4	3	2	1
    #1       0	1	1	0	1	0	1	1
    #2       1	0	0	1	1	0	1	0

Τέλος, οι διαθέσιμες οκτάδες συνδέονται στην σειρά, με την πιο σημαντική οκτάδα,
πρώτη και γίνεται

Κωδικοποίηση: 10011010 01101011  Δεκαεξαδικό: 0x9A 0x6B

*Πρόσθετοι* *Πόροι:*

- [[https://en.wikipedia.org/wiki/Variable-length_quantity][https://en.wikipedia.org/wiki/Variable-length_quantity]]
- [[https://blogs.infosupport.com/a-primer-on-vlq/][https://blogs.infosupport.com/a-primer-on-vlq/]]

*Για* *μια* *εξαιρετική* *υλοποίηση* *του* *αλγόριθμου* *κανεί* *μπορεί* *να* *επισκεφθεί:*

- [[https://github.com/go-audio/midi/blob/master/varint.go][https://github.com/go-audio/midi/blob/master/varint.go]]

.play algorithms/fun/vlq.go