Μίμηση Διεπαφών
Εφόσον ο μεταγλωττιστής μπορεί να πραγματοποιήσει ανάλυση στατικού κώδικα, προκειμένου να εξακριβώσει αν μια πραγματική τιμή υλοποιεί μια διεπαφή, ο developer που δηλώνει τον πραγματικό τύπο δεν χρειάζεται να παρέχει και εκείνος διεπαφές.

* Μίμηση Διεπαφών

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιήστε το Σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Ο καλύτερος τρόπος να εκμεταλλευτεί κανείς την ενσωμάτωση τύπων, είναι κάνοντας χρήση 
του πρότυπου του συνθετικού σχεδιασμού. Η ιδέα είναι, να συνθέτει κανείς μεγαλύτερους 
τύπους από μικρότερους τύπους και να επικεντρώνεται στην σύνθεση της συμπεριφοράς τους.

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1:* Μίμηση Διεπαφών

.play composition/mocking/example1.go

** Ιδιοκτησία Διεπαφής

Ένα πράγμα που είναι διαφορετικό στην Go από άλλες γλώσσες, είναι η ιδέα της σύμβασης 
αντί της ρύθμισης. Αυτή η ιδέα φαίνεται με τον τρόπο που η Go χειρίζεται την συμμόρφωση
με διεπαφές. Καθώς ο μεταγλωττιστής μπορεί να πραγματοποιήσει ανάλυση στατικού κώδικα 
για να προσδιορίσει αν μια πραγματική τιμή υλοποιεί μια διεπαφή, ο developer που δηλώνει τον 
πραγματικό τύπο, δεν χρειάζεται και αυτός να παρέχει διεπαφές.

    package pubsub

    type PubSub struct {
        host string
    }

    func New(host string) *PubSub {
        return &PubSub{
            host: host,
        }
    }

    func (ps *PubSub) Publish(key string, v interface{}) error {
        // ΑΣ ΠΡΟΣΠΟΙΗΘΟΥΜΕ ΟΤΙ ΥΠΑΡΧΕΙ ΣΥΓΚΕΚΡΙΜΕΝΗ ΥΛΟΠΟΙΗΣΗ.
        return nil
    }

    func (ps *PubSub) Subscribe(key string) error {
        // ΑΣ ΠΡΟΣΠΟΙΗΘΟΥΜΕ ΟΤΙ ΥΠΑΡΧΕΙ ΣΥΓΚΕΚΡΙΜΕΝΗ ΥΛΟΠΟΙΗΣΗ.
        return nil
    }

Ας υποτεθεί ότι μόλις υλοποιήθηκε ένα νέο API, που παρέχει μια πραγματική υλοποίηση 
για τις Publish και Subscribe. Δεν παρέχονται άλλες διεπαφές, επειδή αυτό το API δεν 
τις χρειάζεται. Πρόκειται για μια πραγματική υλοποίηση.

Τι θα συμβεί αν ο developer της εφαρμογής, που θέλει να χρησιμοποιήσει αυτό το νέο 
API, χρειάζεται μια διεπαφή, διότι πρέπει να μιμηθεί την παρούσα υλοποίηση, κατά την
διενέργεια ελέγχων; Στην Go, ο developer μπορεί να δηλώσει την διεπαφή και ο μεταγλωττιστής 
μπορεί να διαπιστώσει την συμμόρφωση.

    package main

    type publisher interface {
        Publish(key string, v interface{}) error
        Subscribe(key string) error
    }

    type mock struct{}

    func (m *mock) Publish(key string, v interface{}) error {
        // ΠΡΟΣΘΕΣΕ ΤΗΝ ΜΙΜΗΣΗ ΤΗΣ ΚΛΗΣΗΣ PUBLISH.
        return nil
    }

    func (m *mock) Subscribe(key string) error {
        // ΠΡΟΣΘΕΣΕ ΤΗΝ ΜΙΜΗΣΗ ΤΗΣ ΚΛΗΣΗΣ SUBSCRIBE.
        return nil
    }

Ο παραπάνω κώδικας στο πακέτο main δηλώνει μια διεπαφή. Αυτή η διεπαφή αντιπροσωπεύει 
το API, που χρησιμοποιεί η εφαρμογή, από το πακέτο pubsub. Ο developer έχει πραγματοποιήσει την 
προσωπική του υλοποίηση των τύπων στο pubsub, για την διενέργεια ελέγχων. Το κλειδί εδώ είναι, 
ότι δεν χρησιμοποιείται καμία πραγματική υλοποίηση απευθείας, αλλά πραγματοποιείται αποσύνδεση, 
μέσω των ίδιων των διεπαφών.

    func main() {
        pubs := []publisher{
            pubsub.New("localhost"),
            &mock{},
        }

        for _, p := range pubs {
            p.Publish("key", "value")
            p.Subscribe("key")
        }
    }

Για την παροχή ενός παραδείγματος, η συνάρτηση main παραπάνω, δημιουργεί μια συλλογή 
η οποία λαμβάνει αρχική τιμή, σύμφωνα με την υλοποίηση στο pubsub και την μιμούμενη αυτού 
υλοποίηση. Η διεπαφή publisher επιτρέπει να συμβεί κάτι τέτοιο. Στην συνέχεια, υλοποιείται 
επαναλαμβανόμενη πρόσβαση, με την χρήση του range της for, προκειμένου να παρουσιάσει ότι 
ο κώδικας της εφαρμογής, είναι απομακρυσμένος από την όποια πραγματική υλοποίηση. 
