Δείκτες Διεύθυσνης
Οι δέικτες διεύθυνσης είναι χρήσιμοι προκειμένου να μοιράζεται κανείς τιμές κατά μήκος των ορίων ενός προγράμματος.

* Pointers

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθείστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιείστε το σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Οι δέικτες διεύθυνσης είναι χρήσιμοι προκειμένου να μοιράζεται κανείς τιμές κατά μήκος των ορίων ενός προγράμματος. Υπάρχουν 
διάφορα είδη ορίων σε κάθε πρόγραμμα. Το πιο κοινό απ' όλα είναι αυτό μεταξύ κλήσεων συναρτήσεων.
Υπάρχει ακόμα ένα όριο μεταξύ διαφορετικών Goroutines για το οποίο υπάρχουν σημειώσεις παρακάτω.

** Ανασκόπηση Κώδικα

- *Παράδειγμα* *1:* Περνώντας Παραμέτρους ως Τιμές
- *Παράδειγμα* *2:* Κοινή Χρήση Δεδομένων I
- *Παράδειγμα* *3:* Κοινή Χρήση Δεδομένων II
- *Παράδειγμα* *4:* Ανάλυση Διαφυγής
- *Παράδειγμα* *5:* Μεγέθυνση Στοίβας

.play pointers/example1.go
.play pointers/example2.go
.play pointers/example3.go
.play pointers/example4.go
.play pointers/example5.go

Όταν ένα πρόγραμμα γραμμένο στην Go ξεκινά, το εκτελέσιμο (runtime) της Go δημιουργεί μια Goroutine. Οι Goroutines είναι
ελαφριά νήματα εκτέλεσης λειτουργιών (threads) επιπέδου εφαρμογής που φέρουν την ίδια σημασιολογία ως επί το πλείστον με την λειτουργία 
των νημάτων εκτέλεσης λειτουργιών (threads) του συστήματος. Η δουλειά τους είναι ο έλεγχος της εκτέλεσης ενός διακριτού συνόλου
οδηγιών. Κάθε πρόγραμμα της Go έχει τουλάχιστον 1 Goroutine την οποία αποκαλούμε ως την κύρια (main) Goroutine.

Κάθε Goroutine αποκτά το δικό της τμήμα μνήμης που ονομάζεται στοίβα. Κάθε στοίβα ξεκινάει 
σαν μια δεύσμευση μνήμης 2048 byte (2k). Είναι πολύ μικρή αρχικά, αλλά οι στοίβες μπορούν να μεγαλώσουν με το πέρας του χρόνου.

.image /tour/grc/static/img/p1.png

Κάθε φορά που καλείται μια συνάρτηση, δεσμεύεται ένα τμήμα διαθέσιμου χώρου για την στοίβα προκειμένου να επιτρέψει στην Goroutine
να εκτελέσει τις οδηγίες που σχετίζονται με αυτή την συνάρτηση. Κάθε ξεχωριστό τμήμα της μνήμης 
αποκαλείται πλαίσιο μνήμης.

Το μέγεθος του πλαισίου μνήμης για μια συνάρτηση υπολογίζεται στο στάδιο της μεταγλώττισης. Καμία τιμή
δεν μπορεί να σημιουργηθεί στην στοίβα αν ο μεταγλωτιστής δεν γνωρίζει το μέγεθος αυτής της τιμής κατά το 
στάδιο της μεταγλώττισης. Αν ο μεταγλωττιστής δεν γνωρίζει το μέγεθος της τιμής στο στάδιο της μεταγλώττισης, η
τιμή πρέπει να δημιουργηθεί στον σωρό (heap).
 
Οι στοίβες εκκαθαρίζονται αυτόματα και η μηδενικές τιμές μεταβλητών συμβάλλουν στον ορισμό αρχικής τιμής της στοίβας.
Κάθε φορά που καλεί κανείς μια συνάρτηση και σχηματίζεται ένα πλαίσιο μνήμης, η μνήμη
για αυτό το πλαίσιο λαμβάνει αρχική τιμή, κάτι που είναι ο τρόπος με τον οποίο η στοίβα εκκαθαρίζεται αυτόματα. Όταν μια συνάρτηση 
επιστρέφει, η μνήμη για το συγκεκριμένο πλαίσιο μνήμης αφήνεται στην ησυχία του, καθώς δεν είναι γνωστό αν η συγκεκριμένη μνήμη
θα χρειαστεί ξανά. Θα ήταν αναποτελεσματικό να λαμβάνει αρχική τιμή η μνήμη μετά την επιστροφή των συναρτήσεων.

*Περνώντας* *Παραμέτρους* *ως* *Τιμές* 

Όλα τα δεδομένα μετακινούνται μέσα στο πρόγραμμα ως τιμές. Αυτό σημαίνει ότι καθώς τα δεδομένα διασχίζουν 
τα όρια του προγράμματος, η κάθε συνάρτηση ή η κάθε Goroutine αποκτά το δικό της αντίγραφο των
δεδομένων. Υπάρχουν δύο είδη δεδομένων που κανείς μπορεί να δουλέψει, η τιμή αυτή καθ' ευατή (int,
string, user) ή η διεύθυνση της τιμής στην μνήμη. Οι διευθύνσεις μνήμης είναι δεδομένα που χρειάζεται να αντιγραφούν 
και να αποθηκευτούν διασχίζοντας τα όρια ενός προγράμματος.

Ο ακόλουθος κώδικας προσπαθεί να εξηγήσει τα παραπάνω περισσότερο.

    func main() {

        // Δημιουργία μεταβλητής ακέραιου τύπου με τιμή 10.
        count := 10

        // Προκειμένου να πάρει κανείς την διεύθυνση μνήμης μιας τιμής, μπορεί να χρησιμοποιήσει τον τελεστή &.
        println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

        // Περνώντας ένα αντίγραφο της "τιμής της" count (αυτό που βρίσκεται μέσα στο κουτί)
        // στην συνάρτηση increment1.
        increment1(count)

        // Τυπώνοντας την "τιμή της" και την "διεύθυνση της" παραμέτρου count.
        // Η τιμή της count δεν θα αλλάξει μετά την κλήση της συνάρτησης.
        println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

        // Περνώντας ένα αντίγραφο της "διεύθυνσης της" count (που βρίσκεται το κουτί)
        // στην συνάρτηση increment2. Αυτό θεωρείται πάλι ότι περνάει 
        // την παράμετρο ως τιμή και όχι ότι την περνάει ως αναφορά (pass by reference) καθώς οι διευθύνσεις είναι τιμές.
        increment2(&count)

        // Τυπώνοντας την "τιμή της" και την "διεύθυνση της" παραμέτρου count.
        // Η τιμή της count έχει αλλάξει μετά την κλήση της συνάρτησης.
        println(
            "count:\tValue Of[", 
            count, "]\tAddr Of[", &count, "]")
    }

    // Η increment1 ορίζει την συνάρτηση να δέχεται το δικό της αντίγραφο μιας
    // ακέραιας τιμής.
    func increment1(inc int) {

        // Αυξάνοντας το τοπικό αντίγραφο της int τιμής του καλούντος.
        inc++
        println("inc1:\tValue Of[", inc, "]\tAddr Of[", &inc, "]")
    }

    // Η increment2 ορίζει την συνάρτηση να δέχεται το δικό τηα αντίγραφο μιας
    // διεύθυνσης που δείχνει σε ακέραια τιμή.
    // Οι μεταβλητές διεύθυνσης μνήμης είναι ρητή τύποι και ορίζονται με την χρήση του τελεστή *.
    func increment2(inc *int) {

        // Αυξάνοντας την int τιμή του καλούντος μέσω της διεύθυνσης μνήμης.
        *inc++
        println(
            "inc2:\tValue Of[", 
            inc, "]\tAddr Of[", &inc, 
            "]\tPoints To[", *inc, "]")
    }

Αποτέλεσμα:

    count:  Value Of[ 10 ]  Addr Of[ 0xc000050738 ]
    inc1:   Value Of[ 11 ]  Addr Of[ 0xc000050730 ]
    count:  Value Of[ 10 ]  Addr Of[ 0xc000050738 ]
    inc2:   Value Of[ 0xc000050738 ] Addr Of[ 0xc000050748 ] Points To[ 11 ]
    count:  Value Of[ 11 ]  Addr Of[ 0xc000050738 ]

** Σημειώσεις 

- Κανείς χρησιμοποιεί διευθύνσεις μνήμης προκειμένου να μπορεί να μοιράζεται τα δεδομένα.
- Οι τιμές στην Go πάντα διαθέτονται προκειμένου να περάσουν ως παράμετροι σε συναρτήσεις ως τιμές (pass by value).
- "Η τιμή της", τι βρίσκεται δηλαδή μέσα στο κουτί. "Η διεύθυνση της" ( & ), που βρίσκεται δηλαδή το κουτί.
- Ο τελεστής ( * ) ορίζει μια μεταβλητή διεύθυνσης μνήμης και "Η τιμή την οποία η διεύθυνση μνήμης υποδεικνύει".

** Ανάλυση Διαφυγής

Ο αλγόριθμος που χρησιμοποιεί ο μεταγλωτιστής προκειμένου να διαπιστώσει αν μια τιμή πρέπει να δημιουργηθεί 
στην στοίβα ή στον σωρό ονομάζεται "ανάλυση διαφυγής". Η ονομασία του αλγορίθμου το
παρουσιάζει σαν οι τιμές να δημιουργούνται πρώτα στην στοίβα και στην συνέχεια διαφεύγουν (ή μετακινούνται)
στον σωρό όταν αυτό κριθεί αναγκαίο. ΔΕΝ είναι έτσι όμως. Η δημιουργία μιας τιμής συμβαίνει μόνο
μια φορά, και ο αλγόριθμος ανάλυσης διαφυγής αποφασίζει που θα συμβεί αυτό (στοίβα 
ή σωρός). Μόνο η δημιουργια στον σωρό αποκαλείται καταμερισμός μνήμης (allocation) στην Go.

Η κατανόηση της ανάλυσης διαφυγής αφορά την κατανόηση της ιδιοκτησίας των τιμών. Η ιδέα είναι,
όταν μια τιμή δημιουργείται εντός του πλαισίου αναφοράς μιας συνάρτησης, τότε η συνάρτηση αυτή 
κατέχει την ιδιοκτησία της τιμής. Από εκεί κανείς χρειάζεται να ρωτήσει αν η τιμή πρέπει να 
συνεχίσει να υπάρχει όταν η συνάρτησ στη οποία ανήκει επιστρέψει; Αν η απάντησ είναι όχι, τότε η τιμή μπορεί 
να δημιουργηθεί στην στοίβα. Αν η απάντηση είναι ναι, τότε η τιμή πρέπει να δημηουργηθεί 
στον σωρό.

Σημείωση: Ο κανόνας της ιδιοκτησίας είναι ένα ς καλός βασικός κανόνας για να αναγνωρίζει κανείς εκείνο τον κώδικα
που προκαλεί καταμερισμό μνήμης. Ομως, κανείς πρεπει αν συνειδητοποιήσει ότι η ανάλυση διαφυγής έχει μειωνεκτήματα τα οποία μπορούν 
να οδηγήσουν σε μη προφανείς καταμερισμούς μνήμης. Επίσης, ο αλγόριθμος χρησιμοποιεί κάθε ευκαιρία προκειμένου
να χρησιμοποιήσει βελτιστοποιήσεις του μεταγλωτιστή προκειμένου να εξοικονομήσει καταμερισμούς μνήμης.

    // user represents a user in the system.
    type user struct {
        name  string
        email string
    }

    func stayOnStack() user {
        u := user{
            name:  "Bill",
            email: "bill@email.com",
        }

        return u
    }

Η συνάρτηση stayOnStack χρησιμοποιεί σημειολογία τιμών προκειμένου να επιστρέψει μια τιμή user στον
καλούντα. Με άλλα λόγια, ο καλών αποκτά ένα αντίγραφο της τιμής user που 
δημιουργείται.

Οταν η συνάρτηση stayOnStack καλείται και επιστρέφει, η τιμή user που δημιουργεί
δεν χρειάζεται πια να υπάρχει, καθώς ο καλών αποκτά το δικό του αντίγραφο. Επομένως,
η δημουργία της τιμής user εντός της stayOnStack μπορεί να συμβεί στην στοίβα.
Δεν πραγματοποιείται κανένας καταμερισμός μνήμης.

    type user struct {
        name  string
        email string
    }

    func escapeToHeap() *user {
        u := user{
            name:  "Bill",
            email: "bill@email.com",
        }

        return &u
    }

Η συνάρτηση escapeToHeap χρησιμοποιεί σημασιολογία δείκτη διευθύνσεων προκειμένου να επιστρέψει μια τιμή user πίσω
στον καλώντα. Με άλλα λόγια, ο καλώντας αποκτάει κοινή πρόσβαση (μια διεύθυνση) στην 
τιμή user που δημιουργείται.

Οταν η συνάρτηση escapeToHeap καλείται και επιστρέφει, η τιμή user που δημιουργεί
χρειάζεται να συνεχίζει να υπάρχει, καθώς ο καλώντας έχει κοινή πρόσβαση στην τιμή.
Επομένως, η δημιουργία της τιμής user μέσα στην escapeToHeap δεν μπορεί να συμβεί
στην στοίβα, πρέπει να συμβεί στον σωρό. Πραγματοποιείται καταμερισμός μνήμης.

Αναλογιζόμενος κανείς τι θα συνέβαινε αν η τιμή user του τελευταίου παραδείγματος δημιουργούνταν 
στην στοίβα ενώ την ίδια στιγμή χρησιμοποούνταν σημασιολογία δείκτων διευθύνσεων για την επιστροφή,
προκύπτουν τα ακόλουθα.

.image /tour/grc/static/img/p2.png

Ο καλώντας θα έπαιρνε ένα αντίγραφο της διεύθυνσης στοίβας από το επόμενο πλαίσιο μνήμης και η ακεραιότητα
των δεδομένων θα χανόταν. Οταν ο έλεγχος επιστρέφει στην καλούσα συνάρτηση, η μνήμη στη
στοίβα όπου βρίσκεται η τιμή user καθίσταται ξανά διαθέσιμη για χρήση. Την στιγμή που η καλούσα συνάρτηση 
πραγματοποιεί κλήση άλλης συνάρτησης, ένα νέο πλαίσιο μνήμης διανέμεται και η μνήμη ακυρώνεται,
καταστρέφοντας έτσι την κοινή τιμή.

Γι' αυτό κανείς σκέφτεται την στοίβα ως κάτι που ανανεώνεται. Η ανάθεση της μηδενικής τιμής
βοηθάει κάθε πλαίσιο μνήμης της στοίβας που χρειάζεται κανείς να εκκαθαρίζεται χωρίς την χρήση του συλλέκτη σουπιδιών (GC). Η στοίβα
εκκαθαρίζει τον εαυτό της καθώς ένα πλαίσιο μνήμης λαμβάνεται και παίρνει αρχική τιμή για την εκτέλεση κάθε 
κλήσης συνάρτησης. Η στοίβα εκκαθαρίζεται κατά την διάρκεια κλήσεων συναρτήσεων και όχι όταν επιστρέφουν επειδή
ο μεταγλωτιστής δεν γνωρίζει αν η μνήμη στην στοίβα θα χρειαστεί ξανά.

Η ανάλυση διαφθγής αποφασίζει αν μια τιμή δημιουργείται στην στοίβα (το default) ή αν 
δημιουργείται στον σωρό (η διαφυγή). Με την συνάρτηση stayOnStack, μεταφέρεται έαν αντίγραφο της τιμής 
στον καλώντα, επομένως είανι ασφαλές να παραμείνει η τιμή στην στοίβα. Με την συνάρτηση escapeToHeap, 
ο καλώντας λαμβάνει ένα αντίγραφο της διεύθυνσης της τιμής (γίνεται δηλαδή διαμοιρασμός της 
στοίβας) επομένως δεν είναι ασφαλές να παραμείνει η τιμή στην στοίβα.

Υπάρχουν πολλές μικρές λεπτομέρειες που σχετίζονται με την ανάλυση διαφυγής, επομένως για να μάθει κανείες περισσότερα
μπορεί να διαβάσει την ανάρτηση στο κεφάλαιο 14 με τίτλο, Μηχανισοί της Ανάλυσης Διαφυγής.

Σημείωση: Από την έκδοση 1.17, η Go άλλαξε το ABI (application binary interface) προκειμένου να 
υλοποιήσει ένα νέο τρόπο για να περνάει κανείς τιμές εισόδου και εξόδου κάνοντας χρήση καταχωρητών (registers)
αντί για την μνήμη στην στοίβα. Αυτό είναι ενεργοποιημένο για το Linux, το MacOS, και τα Windows για την
αρχιτεκτονική 64-bit x86. Αυτό σημαίνει ότι ορισμένες τιμές εισόδου μιας συνάρητηση δεν θα 
αντιγράφονται στην στοίβα, αλλά ορισμένες μπορεί κάτι που εξαρτάται από την πρακτική εφαρμογή της χρήσης των καταχωρητών.
Κάτι τέτοιο δεν αλλάζει τίποτα από την σημασιολογία που περιγράφεται σε αυτό το κεφάλαιο.

** Σημειώσεις

- When a value could be referenced after the function that constructs the value returns.
- When the compiler determines a value is too large to fit on the stack.
- When the compiler doesn’t know the size of a value at compile time.
- When a value is decoupled through the use of function or interface values.

** Garbage Collection Semantics

Once a value is constructed on the heap, the Garbage Collector (GC) has to get
involved. The most important part of the GC is the pacing algorithm. It determines
the frequency/pace that the GC has to run in order to maintain the smallest heap
possible in conjunction with the best application throughput.

- [[https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html][Garbage Collection Semantics Part I]] - William Kennedy

** Stack vs Heap

"The stack is for data that needs to persist only for the lifetime of the function
that constructs it, and is reclaimed without any cost when the function exits. The
heap is for data that needs to persist after the function that constructs it exits,
and is reclaimed by a sometimes costly garbage collection." - Ayan George

** Stack Growth

The size of each frame for every function is calculated at compile time. This means,
if the compiler doesn’t know the size of a value at compile time, the value must be
constructed on the heap. An example of this is using the built-in function make to
construct a slice whose size is based on a variable.

    b := make([]byte, size) // Backing array allocates on the heap.

Go uses a contiguous stack implementation to determine how stacks grow and shrink.
One alternative Go could have used is a segmented stack implementation, which is
used by some operating systems.

Every function call comes with a little preamble that asks, "Is there enough stack
space for this new frame?". If yes, then no problem and the frame is taken and
initialized. If not, then a new larger stack must be constructed and the memory on
the existing stack must be copied over to the new one. This requires changes to
pointers that reference memory on the stack. The benefits of contiguous memory and
linear traversals with modern hardware is the tradeoff for the cost of the copy.

Because of the use of contiguous stacks, no Goroutine can have a pointer to some
other Goroutine’s stack. There would be too much overhead for the runtime to keep
track of every pointer to every stack and readjust those pointers to the new location.

** Extra Reading

**Pointer* *Mechanics*

- [[https://golang.org/doc/effective_go.html#pointers_vs_values][Pointers vs. Values]]    
- [[https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html][Language Mechanics On Stacks And Pointers]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2014/12/using-pointers-in-go.html][Using Pointers In Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/07/understanding-pointers-and-memory.html][Understanding Pointers and Memory Allocation]] - William Kennedy    

*Stacks*

- [[https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub][Contiguous Stack Proposal]]  

*Escape* *Analysis* *and* *Inlining*

- [[https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw][Go Escape Analysis Flaws]]  
- [[https://github.com/golang/go/wiki/CompilerOptimizations][Compiler Optimizations]]

*Garbage* *Collection*

- [[http://gchandbook.org/][The Garbage Collection Handbook]]  
- [[https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md][GC Pacer Redesign - 2021]] - Michael Knyszek  
- [[https://en.wikipedia.org/wiki/Tracing_garbage_collection][Tracing Garbage Collection]]  
- [[https://blog.golang.org/go15gc][Go Blog - 1.5 GC]] 
- [[https://www.youtube.com/watch?v=aiv1JOfMjm0&index=16&list=PL2ntRZ1ySWBf-_z-gHCOR2N156Nw930Hm][Go GC: Solving the Latency Problem]]  
- [[http://rubinius.com/2013/06/22/concurrent-garbage-collection][Concurrent garbage collection]]  
- [[https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit][Go 1.5 concurrent garbage collector pacing]]  
- [[https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md][Eliminating Stack Re-Scanning]]  
- [[https://groups.google.com/forum/m/#!topic/golang-nuts/KJiyv2mV2pU][Why golang garbage-collector not implement Generational and Compact gc?]] - Ian Lance Taylor  
- [[https://blog.golang.org/ismmkeynote][Getting to Go: The Journey of Go's Garbage Collector]] - Rick Hudson  
- [[https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html][Garbage Collection In Go : Part I - Semantics]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html][Garbage Collection In Go : Part II - GC Traces]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html][Garbage Collection In Go : Part III - GC Pacing]] - William Kennedy  
- [[https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/][Go memory ballast: How I learnt to stop worrying and love the heap]] - Ross Engers  

*Static* *Single* *Assignment* *Optimizations*

- [[https://www.youtube.com/watch?v=D2-gaMvWfQY][GopherCon 2015: Ben Johnson - Static Code Analysis Using SSA]]  
- [[https://godoc.org/golang.org/x/tools/go/ssa][Package SSA]]    
- [[https://www.youtube.com/watch?v=FnGCDLhaxKU][Understanding Compiler Optimization]]

* Exercises

Use the template as a starting point to complete the exercises. A possible solution is provided.

** Exercise 1

*Part* *A:* Declare and initialize a variable of type int with the value of 20.
Display the "address of" and "value of" the variable.

*Part* *B:* Declare and initialize a pointer variable of type int that points to
the last variable you just created. Display the "address of" , "value of" and the
"value that the pointer points to".

** Exercise 2

Declare a struct type and create a value of this type. Declare a function that
can change the value of some field in this struct type. Display the value before
and after the call to your function.

.play pointers/exercise1.go
.play pointers/answer1.go
.play pointers/exercise2.go
.play pointers/answer2.go
