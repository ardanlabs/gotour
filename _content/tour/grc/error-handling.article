Διαχείριση Σφαλμάτων 
Η διαχείριση σφαλμάτων είναι κρίσιμη για την δημιουργία αξιόπιστων προγραμμάτων, που σέβονται εκείνους που εξαρτώνται από αυτά. 

* Σχεδιασμός Διαχείρισης Σφαλμάτων 

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιήστε το Σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Η ακεραιότητα έχει σημασία και αποτελεί μεγάλο μέρος της διαδικασίας δημιουργίας.
Στην καρδιά της ακεραιότητας, βρίσκεται η διαχείριση σφαλμάτων. Στην Go, η διαχείριση 
σφαλμάτων δεν είναι μια εξαίρεση, που πρέπει να διαχειριστεί κανείς αργότερα ή κάπου
αλλού στον κώδικα. Είναι ένα κύριο κομμάτι της διαδικασίας και πρέπει να παραμείνει 
στο επίκεντρο. 

Οι developer έχουν την ευθύνη να επιστρέφουν αρκετές πληροφορίες σχετικά με κάθε σφάλμα, 
ώστε ένας χρήστης να μπορεί να πάρει μια εμπεριστατωμένη απόφαση για το πως να προχωρήσει.
Η διαχείριση ενός σφάλματος αφορά τρία πράγματα: την καταγραφή του σφάλματος, την μη διάδοση του
σφάλματος παρακάτω και ο καθορισμός αν η ρουτίνα συνεκτέλεσης της Go/πρόγραμμα πρέπει να τερματιστεί.

Στην Go, τα σφάλματα είναι απλά τιμές, έτσι μπορεί να είναι οτιδήποτε πρέπει να είναι. Μπορούν 
να συντηρήσουν κάθε κατάσταση ή συμπεριφορά. 

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1:* Προεπιλεγμένες Τιμές Σφάλματος
- *Παράδειγμα* *2:* Μεταβλητές Σφάλματος 
- *Παράδειγμα* *3:* Ο Τύπος ως Πλαίσιο Αναφοράς
- *Παράδειγμα* *4:* Η Συμπεριφορά ως Πλαίσιο Αναφοράς    
- *Παράδειγμα* *5:* Εντοπίζοντας το Πρόβλημα
- *Παράδειγμα* *6:* Περιβάλλοντας τα Σφάλματα με την Βασική Βιβλιοθήκη 

.play error-handling/example1.go
.play error-handling/example2.go
.play error-handling/example3.go
.play error-handling/example4.go
.play error-handling/example5.go
.play error-handling/example6.go

** Θεμελιώδεις Αρχές Διαχείρισης Σφάλματος 

Η διεπαφή error είναι προεγκατεστημένη στην γλώσσα. 

    // https://golang.org/pkg/builtin/#error
    type error interface {
        Error() string
    }

Αυτός είναι ο λόγος που εμφανίζεται ως μη εξαγόμενο αναγνωριστικό. Κάθε πραγματική 
τιμή, που υλοποιεί αυτή την διεπαφή, μπορεί να χρησιμοποιηθεί ως μια τιμή error.

Μια σημαντική πτυχή της Go είναι, ότι η διαχείριση σφαλμάτων πραγματοποιείται σε 
μια αποσυνδεδεμένη κατάσταση, μέσω αυτής της διεπαφής. Ο βασικός λόγος γι' αυτό 
είναι ότι, η διαχείριση σφαλμάτων είναι μια πτυχή των εφαρμογών, η οποία είναι 
περισσότερο επιρρεπής σε αλλαγές και βελτιώσεις. Αυτή η διεπαφή είναι ο τύπος, 
που οι εφαρμογές της Go πρέπει να χρησιμοποιούν ως τον τύπο επιστροφής, σχετικά με 
την διαχείριση σφαλμάτων.

    // https://golang.org/src/pkg/errors/errors.go
    type errorString struct {
        s string
    }

    // https://golang.org/src/pkg/errors/errors.go
    func (e *errorString) Error() string {
        return e.s
    }

Πρόκειται για την πιο συχνά χρησιμοποιούμενη τιμή σφάλματος σε προγράμματα Go. Δηλώνεται
στο πακέτο errors, από την βασική βιβλιοθήκη. Αξίζει να παρατηρήσει κανείς, ότι ο τύπος 
είναι μη εξαγόμενος και ότι έχει ένα μη εξαγόμενο πεδίο, το οποίο είναι μια συμβολοσειρά. 
Επίσης, κανείς μπορεί να παρατηρήσει πως χρησιμοποιείται σημειολογία τιμής για την υλοποίηση 
της διεπαφής error. Αυτό σημαίνει ότι μόνο διευθύνσεις μνήμης σε τιμές αυτού του τύπου μπορούν 
να μοιραστούν και να αποθηκευτούν στην διεπαφή. Η μέθοδος τύπου απλά επιστρέφει την συμβολοσειρά
του σφάλματος. 

Είναι σημαντικό να θυμάται κανείς, ότι η υλοποίηση της μεθόδου τύπου Error, εξυπηρετεί τον σκοπό της
υλοποίησης της διεπαφής και τον σκοπό της καταγραφής του σφάλματος. Αν ένας χρήστης χρειάζεται να 
επεξεργαστεί την συμβολοσειρά που επιστρέφει αυτή η μέθοδος τύπου, αυτό σημαίνει, ότι δεν έχει καταστεί 
δυνατό να εφοδιαστεί με το κατάλληλο πλαίσιο αναφοράς, προκειμένου να παρει μια απόφαση.

    // https://golang.org/src/pkg/errors/errors.go
    func New(text string) error {
        return &errorString{text}
    }

Η συνάρτηση New είναι ο τρόπος με τον οποίο ένα σφάλμα μπορεί να κατασκευαστεί, όταν χρησιμοποιεί 
τον πραγματικό τύπο errorString. Αξίζει να σημειωθεί, ότι η συνάρτηση επιστρέφει το σφάλμα,
χρησιμοποιώντας την διεπαφή error. Επίσης, αξίζει ακόμα να σημειωθεί, πως χρησιμοποιείται σημειολογία 
δείκτη διεύθυνσης. 

    func main() {
        if err := webCall(); err != nil {
            fmt.Println(err)
            return
        }
        fmt.Println("Life is good")
    }

    func webCall() error {
        return New("bad request")
    }

Η ύπαρξη ενός γενικού πλαισίου σχετικά με το σφάλμα είναι σημαντικό για τα σφάλματα. 
Κάθε σφάλμα πρέπει να παρέχει αρκετές πληροφορίες, προκειμένου να επιτρέψει στον 
καλώντα να πάρει σωστές αποφάσεις, σχετικά με την κατάσταση της ρουτίνας συνεκτέλεσης της Go/εφαρμογής. 
Στο ακόλουθο παράδειγμα, η συνάρτηση webCall επιστρέφει ένα error, με το μήνυμα 
Bad Request. Στην συνάρτηση main γίνεται μια κλήση στην webCall και μετά γίνεται 
ένας έλεγχος, για να εξακριβωθεί αν έχει συμβεί σφάλμα με την κλήση.

    if err := webCall(); err != nil {
        fmt.Println(err)
        return
    }

Το κρίσιμο σημείο του ελέγχου είναι η err != nil. Αυτό που ρωτάει αυτή η συνθήκη 
είναι, αν υπάρχει μια πραγματική τιμή αποθηκευμένη εντός της τιμής διεπαφής err. 
Όταν η τιμή διεπαφής πράγματι αποθηκεύει μια πραγματική τιμή, τότε υπάρχει ένα 
σφάλμα. Σε αυτή την περίπτωση, η σχετική πληροφορία είναι, κυριολεκτικά, το γεγονός
ότι υπάρχει μια πραγματική τιμή, ενώ δεν είναι σημαντικό ποια είναι αυτή η τιμή.

Τι συμβαίνει αν είναι σημαντικό να ξέρει κανείς, τι τιμή error υπάρχει μέσα στην 
μεταβλητή διεπαφής err; Τότε, μια καλή επιλογή είναι οι μεταβλητές error.

    var (
        ErrBadRequest = errors.New("Bad Request")
        ErrPageMoved = errors.New("Page Moved")
    )

Οι μεταβλητές error παρέχουν ένα μηχανισμό, προκειμένου να εξακριβωθεί ποιό ακριβώς 
σφάλμα επιστρέφεται. Έχουν το χαρακτηριστικό ότι ξεκινάνε με το πρόθεμα Err και 
βασίζονται στον πραγματικό τύπο errorString, από το πακέτο errors.

    func webCall(b bool) error {
        if b {
            return ErrBadRequest
        }
        return ErrPageMoved
    }

Σε αυτή την καινούργια έκδοση της webCall, η συνάρτηση επιστρέφει την μια ή την άλλη μεταβλητή 
error. Αυτό, επιτρέπει στον καλώντα να προσδιορίσει, ποιό σφάλμα συνέβη. 

    func main() {
        if err := webCall(true); err != nil {
            switch err {
            case ErrBadRequest:
                fmt.Println("Bad Request Occurred")
                return

            case ErrPageMoved:
                fmt.Println("The Page moved")
                return

            default:
                fmt.Println(err)
                return
            }
        }

        fmt.Println("Life is good")
    }

Στην εφαρμογή, μετά την κλήση στην webCall, μπορεί να πραγματοποιηθεί ένας έλεγχος,
προκειμένου να διαπιστωθεί, αν υπάρχει μια πραγματική τιμή στην μεταβλητή διεπαφής
err. Αν υπάρχει, τότε χρησιμοποιείται μια δήλωση switch, προκειμένου να προσδιοριστεί 
ποια τιμή error ήταν, συγκρίνοντας την err με τις διαφορετικές μεταβλητές error.

Σε αυτή την περίπτωση, το πλαίσιο αναφοράς του σφάλματος βασίζεται σε ποια μεταβλητη 
error επιστράφηκε. Τι συμβαίνει όμως αν μια μεταβλητή error δεν αποτελεί ένα επαρκές πλαίσιο 
αναφοράς; Αν πρέπει να ελεγχθεί κάποια ειδική κατάσταση, όπως συμβαίνει με τα σφάλματα
δικτύου; Σε αυτές τις περιπτώσεις, η απάντηση είναι ένας εξειδικευμένος πραγματικός τύπος
error.

    type UnmarshalTypeError struct {
        Value string
        Type  reflect.Type
    }

    func (e *UnmarshalTypeError) Error() string {
        return "json: cannot unmarshal " + e.Value +
            " into Go value of type " + e.Type.String()
    }

Ο παραπάνω πραγματικός τύπος error υλοποιείται στο πακέτο json. Αξίζει να 
παρατηρήσει κανείς, ότι το όνομα έχει την κατάληξη Error στην ονομασία του
τύπου. Επίσης, αξίζει να παρατηρήσει κανείς, την χρήση σημειολογίας δείκτη 
διεύθυνσης της διεπαφής error. Πρέπει να τονιστεί, ότι η υλοποίηση γίνεται 
για την καταγραφή του σφάλματος και πρέπει να παρουσιάζει πληροφορίες 
σχετικά με όλα τα πεδία που περιγράφονται.

    type InvalidUnmarshalError struct {
        Type reflect.Type
    }

    func (e *InvalidUnmarshalError) Error() string {
        if e.Type == nil {
            return "json: Unmarshal(nil)"
        }
        if e.Type.Kind() != reflect.Ptr {
            return "json: Unmarshal(non-pointer " + e.Type.String() + ")"
        }
        return "json: Unmarshal(nil " + e.Type.String() + ")"
    }

Ο παραπάνω δεύτερος πραγματικός τύπος error βρίσκεται πάλι στο πακέτο json. Η 
υλοποίηση της μεθόδου τύπου Error είναι λίγο πιο περίπλοκη, αλλά και πάλι ο 
σκοπός της είναι η καταγραφή, ενώ και πάλι χρησιμοποιείται σημειολογία δεικτη
διεύθυνσης.

    func Unmarshal(data []byte, v interface{}) error {
        rv := reflect.ValueOf(v)
        if rv.Kind() != reflect.Ptr || rv.IsNil() {
            return &InvalidUnmarshalError{reflect.TypeOf(v)}
        }
        return &UnmarshalTypeError{"string", reflect.TypeOf(v)}
    }

Εδώ είναι ένα μέρος της συνάρτησης Unmarshal. Αξίζει να παρατηρήσει κανείς, πως αυτή κατασκευάζει 
τις πραγματικές τιμές error στην επιστροφή, περνώντας τες πίσω στον καλώντα, μέσω της
διεπαφής error. Χρησιμοποιείται σημειολογία δείκτη διεύθυνσης στην κατασκευή, επειδή 
η σημειολογία δείκτη διεύθυνσης έχει χρησιμοποιηθεί στην δήλωση της μεθόδου τύπου 
Error.

Το πλαίσιο αναφοράς του σφάλματος εδώ, αφορά περισσότερο τον τύπο error, που είναι αποθηκευμένος 
στην διεπαφή error. Πρέπει να υπάρχει ένας τρόπος να διαπιστωθεί αυτός. 

    func main() {
        var u user
        err := Unmarshal([]byte(`{"name":"bill"}`), u)
        if err != nil {
            switch e := err.(type) {
            case *UnmarshalTypeError:
                fmt.Printf("UnmarshalTypeError: Value[%s] Type[%v]\n",
                    e.Value, e.Type)
            case *InvalidUnmarshalError:
                fmt.Printf("InvalidUnmarshalError: Type[%v]\n", e.Type)
            default:
                fmt.Println(err)
            }
            return
        }
        fmt.Println("Name:", u.Name)
    }

Μια γενική διαβεβαίωση τύπου, εντός της εμβέλειας της δήλωσης switch, είναι ο τρόπος
με τον οποίο μπορεί κανείς, να γράψει κώδικα για να ελέγξει, τι τύπου τιμή είναι 
αποθηκευμένη στην τιμή διεπαφής err. Ο ίδιος τύπος είναι το πλαίσιο αναφοράς εδώ, ενώ
τώρα, μπορεί κανείς να ελέγξει και να ενεργήσει, έχοντας πρόσβαση σε όλες τις καταστάσεις 
του σφάλματος.

Όμως κάτι τέτοιο αποτελεί ένα πρόβλημα. Δεν υφίσταται πλέον αποσύνδεση από την πραγματική 
τιμή error. Αυτό σημαίνει ότι αν η πραγματική τιμή error αλλάξει, τότε ο κώδικας μπορεί
να χαλάσει. Το ωραίο κομμάτι της χρήσης μιας διεπαφής, για την διαχείριση σφαλμάτων είναι 
η αποσύνδεση από αλλαγές, που μπορούν να προκαλέσουν πρόβλημα.

Αν η πραγματική τιμή error έχει ένα σύνολο μεθόδων τύπου, τότε είναι δυνατόν να χρησιμοποιήσει
κανείς μια διεπαφή, προκειμένου να γίνει ο έλεγχος τύπου. Σαν ένα παράδειγμα, το πακέτο net έχει 
πολλούς πραγματικούς τύπους σφάλματος, που υλοποιούν διαφορετικές μεθόδους τύπου. Μια κοινή 
μέθοδος τύπου ονομάζεται Temporary. Αυτή η μέθοδος τύπου επιτρέπει στον χρήστη να ελέγξει αν 
το σφάλμα δικτύου είναι κρίσιμο ή πρόκειται απλά για κάτι που μπορεί να επιδιορθωθεί από μόνο
του. 

    type temporary interface {
        Temporary() bool
    }

    func (c *client) BehaviorAsContext() {
        for {
            line, err := c.reader.ReadString('\n')
            if err != nil {
                switch e := err.(type) {
                case temporary:
                    if !e.Temporary() {
                        log.Println("Temporary: Client leaving chat")
                        return
                    }
                default:
                    if err == io.EOF {
                        log.Println("EOF: Client leaving chat")
                        return
                    }
                    log.Println("read-routine", err)
                }
            }
            fmt.Println(line)
        }
    }

Στον παρακάτω κώδικα, η κλήση στην ReadString μπορεί να αποτύχει με ένα error από 
το πακέτο net. Σε αυτή την περίπτωση, δηλώνεται μια διεπαφή, που αντιπροσωπεύει την 
κοινή συμπεριφορά, που θα μπορούσε να υλοποιήσει μια πραγματική τιμή error. Στην
συνέχεια, με μια γενική διαβεβαίωση τύπου κανείς, μπορεί να ελέγξει αν αυτή η συμπεριφορά
υπάρχει και να την χρησιμοποιήσει, αν θέλει. Το καλύτερο μέρος είναι, ότι μένει κανείς σε
μια αποσυνδεδεμένη κατάσταση με την διαχείριση σφαλμάτων.

** Πάντα να Γίνεται Χρήση της Διεπαφής Error

Ένα λάθος που κάνουν οι developer της Go, είναι όταν χρησιμοποιούν τον πραγματικό τύπο 
error αντί την διεπαφή error ως τύπο επιστροφής, για την διαχείριση σφαλμάτων. Αν κανείς 
το κάνει αυτό, μπορούν να συμβούν κακά πράγματα. 

    type customError struct{}

    func (c *customError) Error() string {
        return "Find the bug."
    }

    func fail() ([]byte, *customError) {
        return nil, nil
    }

    func main() {
        var err error
        if _, err = fail(); err != nil {
            log.Fatal("Why did this fail?")
        }
        log.Println("No Error")
    }

Αποτέλεσμα:
    
    Why did this fail?

Γιατί αυτός ο κώδικας πιστεύει ότι υπάρχει ένα σφάλμα, όταν η συνάρτηση fail επιστρέφει 
nil για το error; Αυτό συμβαίνει γιατί η συνάρτηση fail χρησιμοποιεί τον πραγματικό 
τύπο error και όχι την διεπαφή error. Σε αυτή την περίπτωση, υπάρχει ένας δείκτης 
διεύθυνσης nil τύπου customError, που είναι αποθηκευμένος στην μεταβλητή err. Αυτό 
δεν είναι το ίδιο, με το να έχει κανείς μια τιμή διεπαφής nil, τύπου error.

** Διαχείριση Σφαλμάτων 

Η διαχείριση σφαλμάτων είναι περισσότερο μια μακροσκοπική συζήτηση μηχανικής. Εκεί,
η διαχείριση σφαλμάτων σημαίνει ότι, το σφάλμα σταματάει να υπάρχει, μαζί με την 
συνάρτηση που διαχειρίζεται το σφάλμα, το σφάλμα καταγράφεται με πλήρες πλαίσιο αναφοράς 
και το σφάλμα ελέγχεται για την σοβαρότητα του. Με βάση τη σοβαρότητα του και την 
ικανότητα επαναφοράς στην φυσιολογική λειτουργία, παίρνεται μια απόφαση επαναφοράς,
συνέχειας ή διακοπής.

Ένα πρόβλημα είναι ότι, δεν είναι δυνατόν όλες οι συναρτησεις να χειριστούν ένα σφάλμα. 
Ένας λόγος θα μπορούσε να είναι επειδή όλες οι συναρτήσεις δεν επιτρέπεται να πραγματοποιούν 
καταγραφές σφαλμάτων. Τι συμβαίνει όταν ένα σφάλμα περνάει πίσω στην στοίβα κλήσεων και 
δεν μπορεί να το διαχειριστεί η συνάρτηση που το δέχεται; Ένα σφάλμα χρειάζεται να περιβληθεί  
(στμ. wrapped) ώστε η συνάρτηση που τελικά θα το διαχειριστεί, να μπορεί να το πραγματοποιήσει 
αυτό, κατάλληλα. 

    package main

    import (
        "errors"
        "fmt"
    )

    type AppError struct {
        State int
    }

    func (ae *AppError) Error() string {
        return fmt.Sprintf("App Error, State: %d", ae.State)
    }

    func IsAppError(err error) bool {
        var ae *AppError
        return errors.As(err, &ae)
    }

    func GetAppError(err error) *AppError {
        var ae *AppError
        if !errors.As(err, &ae) {
            return nil
        }
        return ae
    }

    func main() {
        if err := firstCall(10); err != nil {

            // Έλεγχος αν ο error είναι ένας AppError.
            if IsAppError(err) {
                ae := GetAppError(err)
                fmt.Printf("Is AppError, State: %d\n", ae.State)
            }

            fmt.Print("\n********************************\n\n")

            // Παρουσίαση του error χρησιμοποιώντας την υλοποίηση 
            // της διεπαφής error.
            fmt.Printf("%v\n", err)
        }
    }

    func firstCall(i int) error {
        if err := secondCall(i); err != nil {
            return fmt.Errorf("secondCall(%d) : %w", i, err)
        }
        return nil
    }

    func secondCall(i int) error {
        return &AppError{99}
    }

Αποτέλεσμα:

    Is AppError, State: 99

    ********************************

    secondCall(10) : App Error, State: 99

** Σημειώσεις

- Να γίνεται χρήση της προεγκατεστημένης τιμής error για στατικά και μορφοποιημένα, με απλό τρόπο, μηνύματα.
- Δημιουργία και επιστροφή μεταβλητών error, προκειμένου να βοηθηθεί ο καλώντας, να εξακριβώσει συγκεκριμένα σφάλματα.
- Δημιουργία εξειδικευμένων τύπων error, όταν το πλαίσιο αναφοράς του σφάλματος είναι περίπλοκο.
- Οι τιμές σφαλματος στην Go δεν είναι ξεχωριστές, πρόκειται απλά για τιμές όπως όλες οι άλλες και γι' αυτό έχουν ολόκληρη την γλώσσα στην διάθεσή τους.

** Παραθέσεις

"Τα συστήματα δεν μπορούν να αναπτυχθούν υποθέτοντας ότι οι άνθρωποι θα μπορούν πάντα να γράφουν εκατομμύρια 
γραμμές κώδικα χωρίς να κάνουν λάθη και η αποσφαλμάτωση από μόνη της δεν είναι ένας αποτελεσματικός τρόπος
ανάπτυξης αξιόπιστων συστημάτων." - Al Aho (δημιουργός AWK)

** Πρόσθετα Αναγνώσματα

- [[https://go.dev/blog/error-handling-and-go][Διαχείριση Σφαλμάτων στην Go]]
- [[https://go.dev/blog/go1.13-errors][Δουλεύοντας με Σφάλματα στην Go 1.13]]
- [[https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html][Διαχείριση Σφαλμάτων στην Go, Μέρος Ι]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html][Διαχείριση Σφαλμάτων στην Go, Μέρος ΙΙ]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html][Φιλοσοφία Σχεδιασμού Σχετικά με την Καταγραφή]] - William Kennedy    
- [[https://clipperhouse.com/bugs-are-a-failure-of-prediction/][Τα προβλήματα κώδικα αποτελούν αποτυχία πρόβλεψης]] - Matt Sherman    
- [[https://dave.cheney.net/2014/12/24/inspecting-errors][Επιθεωρώντας σφάλματα]] - Dave Cheney    
- [[https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully][Μην ελέγχετε απλά τα σφάλματα, διαχειριστείτε με κομψότητα]] - Dave Cheney    
- [[https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package][Ίχνη Στοίβας και το πακέτο errors]] - Dave Cheney    
- [[https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html][Διαχείριση Σφαλμάτων στο Upspin]] - Rob Pike    
- [[https://rauljordan.com/why-go-error-handling-is-awesome/][Γιατί η Διαχείριση Σφαλμάτων στην Go είναι Φανταστική]] - Raul Jordan
   
* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

Δημιουργείστε δύο μεταβλητές error, μια με το όνομα ErrInvalidValue και την άλλη 
με το όνομα ErrAmountTooLarge. Παρέχετε το στατικό μήνυμα για κάθε μεταβλητή. 
Στην συνέχεια, γράψτε μια συνάρτηση, που ονομάζεται checkAmount, που αποδέχεται μια
τιμή τύπου float64 και επιστρέφει μια τιμή error. Ελέγξτε την τιμή και αν είναι 
ίση με το μηδέν, επιστρέψτε το ErrInvalidValue. Ελέγξτε αν η τιμή είναι μεγαλύτερη 
από $1.000 και αν είναι, επιστρέψτε το ErrAmountTooLarge. Γράψτε μια συνάρτηση main 
για να καλέσετε την συνάρτηση checkAmount και ελέγξτε την τιμή error που επιστρέφεται. 
Παρουσιάστε ένα κατάλληλο μήνυμα στην οθόνη. 

.play error-handling/exercise1.go
.play error-handling/answer1.go

** Άσκηση 2

Δημιουργείστε έναν εξειδικευμένο τύπο error, με το όνομα appError, που περιέχει τρία πεδία
err error, message string και code int. Υλοποιήστε την διεπαφή error, παρέχοντας το δικό 
σας μήνυμα, χρησιμοποιώντας αυτά τα τρία πεδία. Υλοποιήστε μια δεύτερη μέθοδο με το όνομα 
temporary, που επιστρέφει false όταν η τιμή του πεδίου code είναι 9. Γράψτε μια συνάρτηση
με το όνομα checkFlag που αποδέχεται μια τιμή bool. Αν η τιμή είναι false, επιστρέψτε έναν
δείκτη διεύθυνσης του εξειδικευμένου τύπου error, με αρχική τιμή όπως επιθυμείτε. Αν η τιμή 
είναι true, επιστρέψτε το βασικό error. Γράψτε μια συνάρτηση main και καλέστε την συνάρτηση 
checkFlag και ελέγξτε το σφάλμα, χρησιμοποιώντας την διεπαφή temporary.

.play error-handling/exercise2.go
.play error-handling/answer2.go
