Σταθερές
Ένα από τα περισσότερο μοναδικά χαρακτηριστικά της Go είναι ο τρόπος με τον οποίο η γλώσσα υλοποιεί τις σταθερές.

* Σταθερές 

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθείστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιείστε το σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Ένα από τα πιο μοναδικά χαρακτηριστικά της Go είναι ο τρόπος με τον οποίο η γλώσσα υλοποιεί τις σταθερές.
Οι κανόνες για τις σταθερές στο έγγραφο προδιαγραφών της γλώσσας είναι μοναδικοί στην Go. Παρέχουν 
την ευελιξία που χρειάζεται η Go προκειμένου να κάνει τον κώδικα που γράφει κάποιος αναγνώσιμο και εύληπτο ενώ ταυτόχρονα
να διατηρείται η ασφάλεια που παρέχουν οι τύποι.

Οι σταθερές μπορούν να έχουν τύπο ή να μην έχουν. Όταν μια σταθερά δεν έχει τύπο, θεωρείται ότι 
είναι ενός είδους. Σταθερές ενός είδους μπορούν να μετατραπούν σιωπηρά από τον μεταγλωττιστή. Όλα 
αυτά συμβαίνουν στο στάδιο της μεταγλώττισης και όχι στο στάδιο της εκτέλεσης.

** Ανασκόπιση Κώδικα

- *Παράδειγμα* *1:* Δηλώσεις και εκώριση αρχικών τιμών σε σταθερές		
- *Παράδειγμα* *2:* Παράλληλο σύστημα τύπων (Είδη) (δεν υπάρχει)
- *Παράδειγμα* *3:* iota			
- *Παράδειγμα* *4:* Σιωπηρή μετατροπή

.play constants/example1.go
.play constants/example2.go
.play constants/example3.go
.play constants/example4.go

    const ui = 12345     // είδος: ακέραιος
    const uf = 3.141592  // είδος: κινητής υποδιαστολής

Οι αριθμητικές σταθερές χωρίς τύπο έχουν ακρίβεια 256 bit, όπως αναφέρεται στις προδιαγραφές.
Βασίζονται σε ένα είδος.

    const ti int     = 12345     // type: int
    const tf float64 = 3.141592  // type: float64

Οι σταθερές με τύπο χρησιμοποιούν και αυτές το σύστημα τύπων των σταθερών, όμως η ακρίβειά τους είναι περιορισμένη.

    const myUint8 uint8 = 1000 // Σφάλμα Μεταγλωττιστή: η σταθερά 1000 υπερχειλίζει έναν uint8
Αυτό δεν λειτουργεί επειδή ο αριθμός 1000 είναι πολύ μεγάλος προκειμένου να αποθηκευτεί σε έναν uint8.

    var answer = 3 * 0.333  // float64 = KindFloat(3) * KindFloat(0.333)

Η αριθμητική σταθερών υποστηρίζει την χρήση διαφορετικών ειδών σταθερών. Η προαγωγή ενός είδους σε άλλο
χρησιμοποιείται προκειμένου να γίνει η διαχείριση αυτών των διαφορετικών σεναρίων. Όλα αυτά συμβαίνουν σιωπηρά. Η μεταβλητη
answer σε αυτό το παράδειγμα θα είναι τύπου float64 και θα αναπαριστά την τιμή 0.999 με ακρίβεια 
64 bit.

    const third = 1 / 3.0  // KindFloat = KindFloat(1) / KindFloat(3.0)

Η σταθερά third θα είναι είδους float και θα αναπαριστά την τιμή 1/3 με ακρίβεια 256 bit.

    const zero = 1 / 3  // KindInt = KindInt(1) / KindInt(3)

Η σταθερά zero θα είναι είδους ακεραίου και θα ισούται με 0 καθώς η ακέραια διαίρεση δεν
έχει υπόλοιπο.

    const one int8 = 1
    const two = 2 * one  // int8(2) * int8(1)

Αυτό είναι ένα παράδειγμα αριθμητικής μεταξύ σταθερών για σταθερές με και χωρίς τύπο.
Σε αυτή την περίπτωση, μια σταθερά ενός τύπου προάγεται αντί μιας σταθεράς είδους. Η σταθερά
two θα έχει τύπο int8 και τιμή ίση με 2.

    const maxInt = 9223372036854775807

Αυτή είναι η μέγιστη ακέραια τιμή για έναν ακέραιο 64 bit.

    const bigger = 9223372036854775808543522345

Η σταθερά bigger είναι μια πολύ μεγαλύτερη τιμή από έναν ακέραιο 64 bit, όμως μπορεί να 
αποθηκευτεί σε μια σταθερά είδους int καθώς οι σταθερές είδους int δεν περιορίζονται σε
ακρίβεια 64 bit.

    const bigger int64 = 9223372036854775808543522345

Σφάλμα μεταγλωττιστή:

    constant 9223372036854775808543522345 overflows int64

Όμως, αν η σταθερά bigger ήταν μια στεθερά τύπου int64, αυτό δεν θα μεταγλωττιζόταν.

** IOTA

Το IOTA προσφέρει υποστήριξη για τον ορισμό διαδοχικών ακέραιων σταθερών. Είναι πιθανόν το
όνομα να προέρχεται από την ακέραια συνάρτηση ⍳ από την γλώσσα προγραμματισμού APL. Στην APL,
η συνάρτηση ⍳ (η οποία αντιπροσωπεύεται από το ένατο γράμμα του Ελληνικού αλφάβητου, το γιώτα) 
χρησιμοποιείται προκειμένου να δημιουργήσει κανείς έναν πίνακα με βάση το μηδέν, διαδοχικών αυξόντων ακεραίων 
συγκεκριμένου μήκους.

    const (
        A1 = iota  // 0 : Ξεκινάει από το 0
        B1 = iota  // 1 : Αυξάνει κατά 1
        C1 = iota  // 2 : Αυξάνει κατά 1
    )
    fmt.Println(A1, B1, C1)

Αποτέλεσμα:

    0 1 2

Η λέξη-κλειδί iota λειτουργεί εντός μιας ενότητας σταθερών και ξεκινάει με την τιμή 0. Μετά,
για κάθε διαδοχική σταθερά που ορίζεται στην ενότητα, το iota αυξάνει κατά 1.

    const (
        A2 = iota  // 0 : Ξεκινάει από το 0
        B2         // 1 : Αυξάνει κατά 1
        C2         // 2 : Αυξάνει κατά 1
    )
    fmt.Println(A2, B2, C2)

Αποτέλεσμα:

    0 1 2

Δεν χρειάζεται να επαναλαμβάνει κανείς την χρήση της λέξης-κλειδί iota. Η διαδοχική φύση των
ακέραιων σταθερών εννοείται απο την στιγμή που γίνεται η χρήση της.

    const (
        A3 = iota + 1  // 1 : 0 + 1
        B3             // 2 : 1 + 1
        C3             // 3 : 2 + 1
    )
    fmt.Println(A3, B3, C3)

Αποτέλεσμα:

    1 2 3

Αν κανείς δεν θέλει να εφαρμόσει κάποιο μαθηματικό μοτίβο, είναι δυνατόν να πραγματοποιήσει κάποιες πράξεις και 
οι πράξεις επαναεφαρμόζονται με μια αυξανόμενη τιμή του iota.

    const (
        Ldate= 1 << iota  //  1 : Μετατόπισε το 1 αριστερά 0 φορές.  0000 0001
        Ltime             //  2 : Μετατόπισε το 1 αριστερά 1 φορά.   0000 0010
        Lmicroseconds     //  4 : Μετατόπισε το 1 αριστερά 2 φορές.  0000 0100
        Llongfile         //  8 : Μετατόπισε το 1 αριστερά 3 φορές.  0000 1000
        Lshortfile        // 16 : Μετατόπισε το 1 αριστερά 4 φορές.  0001 0000
        LUTC              // 32 : Μετατόπισε το 1 αριστερά 5 φορές.  0010 0000
    )

    fmt.Println(Ldate, Ltime, Lmicroseconds, Llongfile, Lshortfile, LUTC)

Αποτέλεσμα:

    1 2 4 8 16 32

Μπορεί κανείς να χρησιμποιήσει αυτό το χαρακτηριστικό, ακριβώς όπως το πακέτο Log το χρησιμοποιεί, προκειμένου να ορίζει επισημάνσεις (flags). 
Σε αυτή την περίπτωση, πράξεις με bit χρησιμοποιούνται με αυξανόμενες τιμές του iota προκειμένου να υπολογιστούν οι τιμές των επισημάνσεων.

** Σημειώσεις

- Οι σταθερές δεν είναι μεταβλητές.
- Υπάρχουν μόνο κατά την μεταγλώττιση.
- Σταθερές χωρίς τύπο μπορούν να μετατραπούν σιωπηρά ενώ οι σταθερές με τύπο και οι μεταβλητές, δεν μπορούν.
- Κανείς μπορεί να σκεφτεί τις σταθερές σαν να έχουν Είδος και όχι Τύπο.
- Χρειάζεται να γνωρίζει κανείς σχετικά με ρητές και σιωπηρές μετατροπές.
- Η ισχύς των σταθερών και η χρήση τους στη προεγκατεστημένη βιβλιοθήκη είναι εμφανής.

** Πρόσθετα Αναγνώσματα

- [[https://golang.org/ref/spec#Constants][Προδιαγραφές Σταθερών]]    
- [[https://blog.golang.org/constants][Σταθερές]] - Rob Pike    
- [[https://www.ardanlabs.com/blog/2014/04/introduction-to-numeric-constants-in-go.html][Εισαγωγή στις Αριθμητικές Σταθερές στην Go]] - William Kennedy    
		
* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

*Μέρος* *Α:* Δηλώστε μια σταθερά χωρίς τύπο και μια με τύπο και παρουσιάστε τις τιμές τους.

*Μέρος* *Β:* Διαιρέστε δύο ρητές σταθερές σε μια μεταβλητή με τύπο και παρουσιάστε τη τιμή.

.play constants/exercise1.go
.play constants/answer1.go
