Ομαδοποίηση με Τύπους 
Είναι σημαντικό να θυμάται κανείς ότι στην Go, οι έννοιες της δημιουργίας υπό-τύπων ή η δημιουργία υπό-κλάσεων, πραγματικά, δεν υπάρχουν και αυτά τα σχεδιαστικά πρότυπα θα πρέπει να αποφεύγονται.

* Ομαδοποίηση με Τύπους 

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιήστε το Σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Είναι σημαντικό να θυμάται κανείς ότι στην Go, οι έννοιες της δημιουργίας υπό-τύπων ή η 
δημιουργία υπό-κλάσεων, πραγματικά, δεν υπάρχουν και αυτά τα σχεδιαστικά πρότυπα θα πρέπει 
να αποφεύγονται.

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1:* Ομαδοποίηση με Βάση την Κατάσταση
- *Παράδειγμα* *2:* Ομαδοποίηση με Βάση την Συμπεριφορά

.play composition/grouping/example1.go
.play composition/grouping/example2.go

** Ομαδοποίηση Διαφορετικών Τύπων Δεδομένων 

Είναι σημαντικό να θυμάται κανείς ότι στην Go, οι έννοιες της δημιουργίας υπό-τύπων ή η 
δημιουργία υπό-κλάσεων, πραγματικά, δεν υπάρχουν και αυτά τα σχεδιαστικά πρότυπα θα πρέπει 
να αποφεύγονται.

Το ακόλουθο είναι ένα πρότυπο, που δεν θα πρέπει κανείς να ακολουθήσει ή να υλοποιήσει:

    type Animal struct {
        Name string
        IsMammal bool
    }

Ο τύπος Animal δηλώνεται ως ένας τύπος βάσης, που προσπαθεί να ορίσει δεδομένα κοινά σε όλα 
τα ζώα. Θα προσπαθήσει κανείς να παρέχει κάποια κοινή συμπεριφορά σε ένα ζώο, επίσης.

    func (a *Animal) Speak() {
        fmt.Println("UGH!",
        "My name is", a.Name, ", it is", a.IsMammal, "I am a mammal")
    }

Τα περισσότερα ζώα έχουν την δυνατότητα να μιλάνε, με κάποιο τρόπο. Όμως η 
προσπάθεια να εφαρμόσει κανείς αυτή την κοινή συμπεριφορά, μονάχα σε ένα ζώο, 
δεν έχει νόημα. Σε αυτό το σημείο κανείς, δεν γνωρίζει πως ακούγεται αυτό το
ζώο, επομένως γράφει κανείς, απλά UGH.

    type Dog struct {
        Animal
        PackFactor int
    }

Τώρα αρχίζει το πραγματικό πρόβλημα. Γίνεται προσπάθεια να χρησιμοποιηθεί η ενσωμάτωση, 
προκειμένου να γίνει ένας Dog, οτιδήποτε είναι ένας Animal και κάτι περισσότερο. 
Στην επιφάνεια, αυτό φαίνεται να λειτουργεί, όμως υπάρχουν προβλήματα. Με αυτά, ένας Dog 
πράγματι έχει ένα συγκεκριμένο τρόπο ομιλίας.

    func (d *Dog) Speak() {
        fmt.Println("Woof!",
            "My name is", d.Name,
            ", it is", d.IsMammal,
            "I am a mammal with a pack factor of", d.PackFactor)
    }

Στην υλοποίηση της μεθόδου τύπου Speak, μπορεί κανείς να αλλάξει το UGH, με το Woof. Αυτό 
το τελευταίο ειδικά είναι πως μιλάει ένας σκύλος.

    type Cat struct {
        Animal
        ClimbFactor int
    }

Αν θα υπάρχει ένας Dog, να αντιπροσωπευει τον Animal, τότε σίγουρα πρέπει να υπάρχει και 
ένας Cat. Χρησιμοποιώντας την ενσωμάτωση, ένας Cat είναι ό,τι είναι ένας Animal και κάτι
ακόμα.

    func (c *Cat) Speak() {
        fmt.Println("Meow!",
            "My name is", c.Name,
            ", it is", c.IsMammal,
            "I am a mammal with a climb factor of", c.ClimbFactor)
    }

Στην υλοποίηση της μεθόδου τύπου Speak, μπορεί να γίνει η αλλαγή του UGH, με το Meow. Κάτι 
τέτοιο, θα ήταν εξειδικευμένο στον τρόπο, με τον οποίο μιλάει μια γάτα.

Φαίνεται ότι όλα πάνε καλά και ότι η ενσωμάτωση τύπου παρέχει την ίδια λειτουργικότητα, που
παρέχει η κληρονομικότητα σε άλλες γλώσσες. Στην συνέχεια, κανείς προσπαθεί να ομαδοποιήσει 
τα σκυλιά και τις γάτες με βάση το γεγονός ότι, έχουν κοινό DNA ως Animal.

    animals := []Animal{
        Dog{
            Animal: Animal{
                Name: "Fido",
                IsMammal: true,
            },
            PackFactor: 5,
        },
    
        Cat{
            Animal: Animal{
                Name: "Milo",
                IsMammal: true,
            },
            ClimbFactor: 4,
        },
    }

    for _, animal := range animals {
        animal.Speak()
    }

Στην προσπάθεια να γίνει αυτό, ο μεταγλωττιστής διαμαρτύρεται ότι ένας τύπος Dog 
και ένας τύπος Cat δεν είναι τύπου Animal και αυτό είναι αληθές. Η ενσωμάτωση 
τύπου δεν είναι το ίδιο πράγμα με την κληρονομικότητα και αυτό είναι το πρότυπο 
που χρειάζεται κανείς να αποφύγει να υλοποιήσει. Ένας τύπος Dog είναι ένας Dog, 
ένας τύπος Cat είναι ένας Cat και ένας τύπος Animal είναι ένας Animal. Δεν είναι 
δυνατόν να περνάει κανείς γύρω στο πρόγραμμα Dog και Cat σαν να είναι Animals, 
διότι δεν είναι.

Επίσης, ο μηχανισμός αυτός δεν είναι πολύ ευέλικτος. Απαιτεί ρυθμίσεις από τον 
developer και εκτός και αν έχει πρόσβαση στον κώδικα, δεν είναι δυνατόν να κάνει 
αλλαγές των ρυθμίσεων στο πέρασμα του χρόνου.

Εάν επομένως αυτός δεν είναι ο τρόπος δημιουργίας μιας συλλογής από Dog και Cat,
τότε πως γίνεται κάτι τέτοιο στην Go; Δεν έχει να κάνει με την ομαδοποίηση 
με βάση το κοινό DNA, αλλά έχει να κάνει με την ομαδοποίηση, με βάση την κοινή
συμπεριφορά. Η συμπεριφορά, είναι το κλειδί.

    type Speaker interface {
        Speak()
    }

Χρησιμοποιώντας μια διεπαφή, είναι δυνατόν να οριστεί το κοινό σύνολο μεθόδων 
τύπου συμπεριφοράς, που χρειάζεται προκειμένου να ομαδοποιηθούν διαφορετικοί τύποι 
δεδομένων μαζί.

    speakers := []Speaker{
        &Dog{
            Animal: Animal{
                Name: "Fido",
                IsMammal: true,
            },
            PackFactor: 5,
        },
        &Cat{
            Animal: Animal{
                Name: "Milo",
                IsMammal: true,
            },
            ClimbFactor: 4,
        },
    }

    for _, speaker := range speakers {
        speaker.Speak()
    }

Στον καινούργιο κώδικα, μπορεί κανείς να ομαδοποιήσει τους Dog και Cat μαζί, με βάση 
το σύνολο των κοινών συμπεριφορών τους, που είναι το γεγονός ότι οι Dog και Cat μπορούν
να μιλανε.

Μάλιστα, ο τύπος Animal, πρόκειται ουσιαστικά για επιμόλυνση τύπου, επειδή η δήλωση ενός τύπου
μόνο για να μοιραστεί ένα κοινό σύνολο καταστάσεων, υποδηλώνει ότι κάτι δεν πάει καλά και θα
πρέπει κάτι τέτοιο να αποφεύγεται.

    type Dog struct {
        Name string
        IsMammal bool
        PackFactor int
    }
    
    type Cat struct {
        Name string
        IsMammal bool
        ClimbFactor int
    }

Στην συγκεκριμένη περίπτωση, θα ήταν προτιμότερο να απομακρυνθεί ο τύπος Animal και τα
πεδία του να αντιγραφούν και να επικολληθούν στους τύπους Dog και Cat. Αργότερα, θα γίνουν
διαθέσιμες σημειώσεις για καλύτερα πρότυπα κώδικα, που δεν επιτρέπουν τέτοια σενάρια όπως
παραπάνω να συμβούν.

Παρακάτω, είναι οι ενδείξεις από τον αρχικό κώδικα, ότι κάτι δεν πάει καλά:

- Ο τύπος Animal παρέχει ένα επίπεδο αφαίρεσης επαναχρησιμοποιούμενης κατάστασης.
- Το πρόγραμμα δεν χρειάζεται ποτέ να δημιουργήσει ή να χρησιμοποιήσει μόνη της μια τιμή τύπου Animal.
- Η υλοποίηση της μεθόδου τύπου Speak, για τον τύπο Animal, γενικεύεται.
- Η μέθοδος τύπου Speak για τον τύπο Animal, δεν πρόκειται να κληθεί ποτέ.

Οδηγίες σχετικά με τον ορισμό τύπων:

- Οι τύποι πρέπει να δηλώνονται, όταν αντιπροσωπεύουν κάτι καινούργιο ή μοναδικό.
- Δεν πρέπει να δημιουργούνται ψευδώνυμα τύπων (στμ. aliases), μονάχα για λόγους ευκολίας ανάγνωσης του κώδικα.
- Χρειάζεται να επιβεβαιωθεί ότι η τιμή του όποιου τύπου δημιουργείται ή χρησιμοποιείται από μόνη της.
- Η ενσωμάτωση τύπων γίνεται επειδή χρειάζεται η συμπεριφορά, όχι επειδή χρειάζεται η κατάσταση.
- Αν δεν σκέφτεται κανείς σχετικά με την συμπεριφορά, δεσμεύεται σε ένα σχεδιασμό ο οποίος δεν μπορεί να μεταβληθεί στο μέλλον, χωρίς την ανάγκη για αλληλοσυνδεόμενες αλλαγές κώδικα.
- Κανείς θα πρέπει να αμφιβάλλει για τύπους, που είναι ψευδώνυμα ή αφαιρέσεις ενός υπάρχοντος τύπου.
- Κανείς θα πρέπει να αμφιβάλλει για τύπους, των οποίων ο μόνος σκοπός είναι, να μοιραστούν ένα κοινό σύνολο καταστάσεων.

** Δεν Πρέπει να Σχεδιάζει Κανείς με Διεπαφές

Δυστυχώς, πολλοί developers προσπαθούν να λύσουν προβλήματα πρώτα με αφηρημένο τρόπο.
Επικεντρώνονται σε διεπαφές αμέσως και αυτό οδηγεί σε επιμόλυνση των διεπαφών. Ως developer, 
κανείς βρίσκεται σε έναν από δύο τρόπους λειτουργίας: λειτουργεί ως προγραμματιστής και 
λειτουργεί ως μηχανικός.

Όταν κανείς προγραμματίζει, προσπαθεί να κάνει ένα κομμάτι κώδικα να λειτουργήσει. 
Προσπαθεί να λύσει το πρόβλημα και να ρίξει τοίχους. Προσπαθεί να αποδείξει ότι η 
αρχική ιδέα δουλεύει. Αυτό, είναι το μόνο που έχει σημασία. Αυτού του είδους ο 
προγραμματισμός, πρέπει μονάχα να γίνεται επί του συγκεκριμένου και το αποτέλεσμα 
του δεν είναι ποτέ έτοιμο για την παραγωγή.

Όταν υπάρχει ένα πρωτότυπο κώδικα που λύνει το πρόβλημα, κανείς πρέπει να αλλάξει 
τον τρόπο λειτουργίας, σε σε αυτόν του μηχανικού. Πρέπει να επικεντρωθεί στο πως να 
γράψει τον κώδικα σε μικρo-επίπεδο, με βάση την σημειολογία των δεδομένων και την 
αναγνωσιμότητα και στην συνέχεια σε μακρο-επίπεδο, με βάση τα νοητικά πρότυπα και 
την ικανότητα συντήρησης. Πρέπει επίσης, να επικεντρωθεί σε σφάλματα και καταστάσεις 
αποτυχίας. 

Αυτή η εργασία γίνεται σε ένα κύκλο επαναδημιουργίας (στμ. refactoring) κώδικα. Η επαναδημιουργία 
γίνεται για την αναγνωσιμότητα, την αποτελεσματικότητα, την αφαίρεση και την δυνατότητα διεξαγωγής 
ελέγχων. Η αφαίρεση είναι μόνο μια από τις μερικές διαδικασίες επαναδημιουργίας κώδικα, 
που πρέπει να πραγματοποιηθούν. Κάτι τέτοιο δουλεύει καλύτερα, όταν κανείς ξεκινάει με ένα τμήμα
συγκεκριμένου κώδικα και στην συνέχεια ΑΝΑΚΑΛΥΠΤΕΙ τις διεπαφές που χρειάζονται. Δεν πρέπει
κανείς να εφαρμόζει αφαιρέσεις, εκτός και αν είναι απολύτως απαραίτητο.

Κάθε πρόβλημα που λύνεται με κώδικα, είναι ένα πρόβλημα δεδομένων που απαιτεί την συγγραφή 
μετασχηματισμών των δεδομένων. Αν κανείς δεν κατανοεί τα δεδομένα, δεν κατανοεί ούτε το πρόβλημα.
Αν δεν κατανοεί το πρόβλημα, δεν είναι δυνατόν αν γράψει τον όποιο κώδικα. Είναι κρίσιμο να ξεκινάει
κανείς με μια συγκεκριμένη λύση, που βασίζεται σε συγκεκριμένες δομές δεδομένων. Όπως έχει πει 
ο Rob Pike,

"Τα δεδομένα κυριαρχούν. Αν κανείς επιλέξει τις σωστές δομές δεδομένων και έχει οργανώσει τα πράγματα 
καλά, τότε οι αλγόριθμοι θα είναι σχεδόν πάντα αυταπόδεικτοι". - Rob Pike

Πότε χρειάζεται η αφαίρεση; Όταν κανείς εντοπίζει μια θέση στον κώδικα, όπου τα δεδομένα 
μπορούν να αλλάξουν και κανείς θέλει να ελαχιστοποιήσει τα αλληλοσυνδεόμενα αποτελέσματα 
στον κώδικα που κάτι τέτοιο θα δημιουργήσει. Είναι πιθανόν να χρησιμοποιήσει κανείς την 
αφαίρεση, προκειμένου να καταστήσει τον κώδικα ελέγξιμο, όμως κανείς θα πρέπει να αποφεύγει 
κάτι τέτοιο, αν είναι δυνατόν. Οι καλύτερες ελέγξιμες συναρτήσεις, είναι οι συναρτήσεις που 
λαμβάνουν ανεπεξέργαστα δεδομένα και αποστέλλουν ανεπεξέργαστα δεδομένα. Δεν θα πρέπει να 
έχει σημασία, από που προέρχονται ή πηγαίνουν τα δεδομένα.

Τελικά, κανείς πρέπει να ξεκινά με μια συγκεκριμένη λύση, σε κάθε πρόβλημα. Ακόμα και αν το 
μεγαλύτερο μέρος κάτι τέτοιου, είναι απλά προγραμματισμός. Στην συνέχεια, πρέπει κανείς να 
ανακαλύπτει τις διεπαφές, που είναι απολύτως απαραίτητες για τον κώδικα, την δεδομένη στιγμή.

"Δεν πρέπει κανείς να σχεδιάζει με διεπαφές, αλλά οφείλει να τις ανακαλύπτει". - Rob Pike
