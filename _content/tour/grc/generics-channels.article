Κανάλια Επικοινωνίας
Εξερεύνηση του τρόπου με τον οποίο η ομάδα της Go θα μπορούσε να προσθέσει ένα πακέτο με πρότυπα ταυτόχρονης εκτέλεσης, στην βασική βιβλιοθήκη, εξαιτίας της δυνατότητας γενικού προγραμματισμού.

* Γενικός Προγραμματισμός - Κανάλια Επικοινωνίας

Εξερεύνηση του τρόπου με τον οποίο η ομάδα της Go θα μπορούσε να προσθέσει ένα πακέτο με πρότυπα ταυτόχρονης εκτέλεσης, στην βασική βιβλιοθήκη, εξαιτίας της δυνατότητας γενικού προγραμματισμού.

** Video

Κανείς, μπορεί να παρακολουθήσει την ομιλία του Bill Kennedy, σχετικά με τον Γενικό Προγραμματισμό,
που παρουσιάζει λεπτομερώς όλα τα παραδείγματα αυτής της ενότητας της Επισκόπησης.

.html generics-video.html

** Επισκόπηση Κώδικα 

- *Παράδειγμα* *1*: Συνάρτηση Εργασίας
- *Παράδειγμα* *2*: Συγκέντρωση Πόρων για Εργασίες

.play generics/channels/example1.go
.play generics/channels/example2.go

** Επεξηγήσεις

Κάτι τέτοιο, θα απαιτούσε την δήλωση καναλιών επικοινωνίας και συναρτήσεις, που χρησιμοποιούν 
τύπους γενικού προγραμματισμού.

    type workFn[Result any] func(context.Context) Result

Σε αυτό το παράδειγμα, δηλώνεται ένας τύπος, που αντιπροσωπεύει μια συνάρτηση, η οποία
δέχεται έναν Context και επιστρέφει μια τιμή του τύπου γενικού προγραμματισμού Result. 
Αυτή η δήλωση συνάρτησης, περιγράφει μια συνάρτηση, η οποία υλοποιεί την εργασία ταυτόχρονης
εκτέλεσης, που θα πραγματοποιηθεί, καθώς και το αποτέλεσμα αυτής της εργασίας. 

    func doWork[Result any](ctx context.Context, work workFn[Result]) chan Result {
        ch := make(chan Result, 1)
        
        go func() {
            ch <- work(ctx)
            fmt.Println("doWork : work complete")
        }()
        
        return ch
    }

Στην συνέχεια, ακολουθεί η συγγραφή μια συνάρτησης με το όνομα doWork, η οποία εκτελεί
ταυτόχρονα την συγκεκριμένη συνάρτηση work και επιστρέφει ένα κανάλι επικοινωνίας, 
ώστε ο καλών να μπορεί να παραλάβει το αποτέλεσμα της εργασίας, που πραγματοποιήθηκε 
από την συνάρτηση work. Δηλώνεται επίσης ένας τύπος γενικού προγραμματισμού με το 
όνομα Result, προκειμένου να αντιπροσωπεύσει τον τύπο επιστροφής της συνάρτησης work 
καθώς και τον τύπο του καναλιού επικοινωνίας.

Στην υλοποίηση της συνάρτησης doWork, δημιουργείται ένα κανάλι επικοινωνίας, με ενδιάμεση 
μνήμη μεγέθους ένα και τύπο γενικού προγραμματισμού Result. Πρόκειται για το κανάλι που
επιστρέφεται στον καλώντα, προκειμένου να παραλάβει το αποτέλεσμα της εργασίας, που εκτελείται
ταυτόχρονα. Στην μέση αυτής της συνάρτησης δημιουργείται μια goroutine, προκειμένου να 
εκτλέσει την συνάρτηση work, ταυτόχρονα. Όταν αυτή η συνάρτηση work επιστρέφει, το όρισμα 
επιστροφής αποστέλλεται πίσω στον καλώντα, μέσω του καναλιού επικοινωνίας.

Προκειμένου να ελεγχθεί η χρήση της συνάρτησης doWork, δημιουργείται το ακόλουθο, μικρό 
πρόγραμμα. 

    func main() {
        duration := 100 * time.Millisecond
        
        ctx, cancel := context.WithTimeout(context.Background(), duration)
        defer cancel()
        
        dwf := func(ctx context.Context) string {
            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
            return "work complete"
        }

        result := doWork(ctx, dwf)
        
        select {
            case v := <-result:
                fmt.Println("main:", v)
            case <-ctx.Done():
                fmt.Println("main: timeout")
        }
    }

Αποτέλεσμα:

    doWork : work complete
    main: work complete

Το πρόγραμμα ξεκινάει δηλώνοντας μια Context, η οποία έχει χρόνο timeout 100 millisecond,
μετά το πέρας του οποίου, λήγει. Στην συνέχεια, δηλώνεται μια συνάρτηση εργασίας, η οποία
περιμένει μέχρι και 200 millisecond, πρωτού επιστρέψει την συμβολοσειρά "work complete". 
Έχοντας κανείς την μεταβλητή τύπου Context και την συνάρτηση εργασίας, μπορεί να πραγματοποιηθεί 
μια κλήση στην doWork και στην συνέχεια επιστρέφεται ένα κανάλι τύπου συμβολοσειράς, που εκχωρείται
στην μεταβλητή result.

Ο μεταγλωττιστής είναι ικανός να προσδιορίσει τον πραγματικό τύπο, που πρέπει να χρησιμοποιήσει 
για τον τύπο γενικού προγραμματισμού Result, επιθεωρώντας τον τύπο επιστροφής της ρητής συνάρτησης 
εργασίας, που περνάει στην συνάρτηση doWork. Αυτό, είναι εξαιρετικό, επειδή σημαίνει ότι, δεν χρειαζόταν 
να περάσει ο τύπος, στην κλήση της doWork.

Έχοντας πραγματοποιηθεί η εκχώρηση στην μεταβλήτη result του καναλιού επικοινωνίας 
τύπου συμβολοσειράς, στην συνέχεια χρησιμοποιείται μια δήλωση select επιλογής περιπτώσεων, 
προκειμένου να πραγματοποιηθεί αναμονή, ώστε να επιστραφεί το αποτέλεσμα στην result εγκάιρως ή 
να συμπληρωθεί ο χρόνος για το timeout. Η συνάρτηση doWork μπορεί να χρησιμοποιηθεί, προκειμένου 
να πραγματοποιήσει την εργασία με ταυτόχρονη εκτέλεση, για κάθε πραγματικό τύπο, για τον οποίο 
απιτείται κάτι τέτοιο. 

Η ίδια ιδέα θα μπορούσε να εφαρμοστεί σε ένα διαθέσιμο αριθμό από goroutine, οι οποίες θα μπορούσαν 
να εκτελέσουν εργασίες σε είσοδο γενικού προγραμματισμού και να επιστρέψουν ένα αποτέλεσμα γενικού 
προγραμματισμού.

type workFn[Input any, Result any] func(input Input) Result

Σε αυτό το παράδειγμα, γίνεται αλλαγή στον τύπο της συνάρτησης, προκειμένου να δέχεται μια είσοδο
γενικού προγραμματισμού και να επιστρέφει ένα αποτέλεσμα γενικού προγραμματισμού.

    func poolWork[Input any, Result any](size int, work workFn[Input, Result]) (chan Input, func()) {
        var wg sync.WaitGroup
        wg.Add(size)
        
        ch := make(chan Input)
        
        for i := 0; i < size; i++ {
            go func() {
                defer wg.Done()
                for input := range ch {
                    result := work(input)
                    fmt.Println("pollWork :", result)
                }
            }()
        }
        
        cancel := func() {
            close(ch)
            wg.Wait()
        }

        return ch, cancel
    }

Στην συνάρτηση poolWork, δηλώνονται οι δύο ίδιοι τύποι γενικού προγραμματισμού, 
προκειμένου να αντιπροσωπεύσουν τον τύπο εισόδου αλλά και τον τύπο επιστροφής 
της συνάρτησης εργασίας. Επίσης, δημιουργείται μια μεταβλητή τύπου WaitGroup, 
προκειμένου να διαχειριστεί τον κλυκλο ζωής των Goroutine, που είναι διαθέσιμες.
Τέλος, δημιουργείται ένα κανάλι επικοινωνίας του τύπου γενικού προγραμματισμού 
Input. Αυτό το κανάλι επικοινωνίας χρησιμοποιείται από τις διαθέσιμες Goroutine 
προεκειμένου να παραδίδει τα δεδομένα εισόδου για την κάθε συνάρτηση εργασίας.

Στην συνέχεια δημιουργείται ο κατάλληλος αριθμός Goroutine, με κάθε μια από τις 
διαθέσιμες Goroutine, κάνοντας χρήση της επανάληψης for-range στο κανάλι επικοινωνίας,
να περιμένει σε μια λειτουργία παραλαβής. Τέλος, δημιουργείται μια συνάρτηση 
cancel, προκειμένου να επιτρέψει στον καλώντα να τερματίσει τις διαθέσιμες Goroutine 
και να περιμένει, έως ότου όλες σηματοδοτήσουν ότι, έχουν τερματίσει την λειτουργία
τους.

Προεκειμένου να ελεγχθεί η συνάρτηση poolWork, κατασκευάζεται το ακόλουθο μικρό 
πρόγραμμα. 

    func main() {
        size := runtime.GOMAXPROCS(0)
        
        pwf := func(input int) string {
            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
            return fmt.Sprintf("%d : received", input)
        }

        ch, cancel := poolWork(size, pwf)
        defer cancel()
        
        for i := 0; i < 4; i++ {
            ch <- i
        }
    }

Αποτέλεσμα:

    pollWork : 3 : received
    pollWork : 2 : received
    pollWork : 1 : received
    pollWork : 0 : received

Το πλήθος των διαθέσιμων Goroutine, υπολογίζεται με βάση τον αριθμό Goroutine, που μπορεί
να εκτελεστούν ταυτόχρονα. Στην συνέχεια, δημιουργείται μια συνάρτηση εργασίας, προκειμένου 
να αναμένει, για ένα τυχαίο χρονικό διάστημα και στην συνέχεια να επιστρέψει μια συμβολοσειρά 
που αντιπροσωπεύει την είσοδο.

Έχοντας κάτι τέτοιο διαθέσιμο, η συνάρτηση poolWork εκτελείται και επιστρέφονται, το κανάλι 
επικοινωνίας, καθώς και η συνάρτηση cancel. Η συνάρτηση cancel καλείται, προκειμένου να εκτελεστεί 
με καθυστέρηση (defer) και δημιουργείται μια επαναληπτική προσπέλαση, προκειμένου να αποσταλούν 4
τιμές στις διαθέσιμες Goroutines. Το αποτέλεσμα θα είναι διαφορετικό κάθε φορά που εκτελείται το 
πρόγραμμα καθώς οι εργασίες πραγματοποιούνται με ταυτόχρονη εκτέλεση.

Αυτά τα μικρά παραδείγματα παρέχουν μια μικρή εικόνα, για τον τρόπο με τον οποίο, ένα πακέτο ταυτόχρονης
εκτέλεσης θα μπορούσε να υλοποιηθεί.
