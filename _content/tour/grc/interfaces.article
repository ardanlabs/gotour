Διεπαφές 
Οι διεπαφές δίνουν δομή στα προγράμματα και ενθαρρύνουν τον σχεδιασμό, με βάση την σύνθεση. 

* Διεπαφές

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιήστε το Σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Οι διεπαφές δίνουν δομή στα προγράμματα και ενθαρρύνουν τον σχεδιασμό, με βάση την 
σύνθεση. Επιτρέπουν και επιβάλλουν καθαρές διαχωριστικές γραμμές 
μεταξύ των συστατικών. Η τυποποίηση των διεπαφών μπορεί να ορίσει καθαρές και 
συνεπείς προσδοκίες. Η αποσύνδεση (στμ. decoupling) σημαίνει μείωση των εξαρτήσεων 
μεταξύ των συστατικών και των τύπων που χρησιμοποιούν. Κάτι τέτοιο 
οδηγεί σε ορθότητα, ποιότητα και δυνατότητα συντήρησης του κώδικα.

** Επισκόπηση Κώδικα

- *Example* *1:* Επαναλαμβανόμενος Κώδικας Που Απαιτεί Πολυμορφισμό
- *Example* *2:* Πολυμορφισμός 
- *Example* *3:* Σύνολα Μεθόδων Τύπων
- *Example* *4:* Διεύθυνση Τιμής 
- *Example* *5:* Αποθήκευση Ως Τιμή 
- *Example* *6:* Επιβεβαιώσεις Τύπων
- *Example* *7:* Επιβεβαιώσεις Τύπων Υπό Συνθήκη
- *Example* *8:* Η Άδεια Διεπαφή και Εναλλαγές Τύπων
- *Example* *9:* Αποθήκευση Τιμών

.play interfaces/example1.go
.play interfaces/example2.go
.play interfaces/example3.go
.play interfaces/example4.go
.play interfaces/example5.go
.play interfaces/example6.go
.play interfaces/example7.go
.play interfaces/example8.go
.play interfaces/example9.go

** Σημειολογία Διεπαφών

Οι διεπαφές επιτρέπουν την συλλογή συναφών δεδομένων, με βάση το τι μπορούν να κάνουν. 
Αφορούν την επικέντρωση στο τι μπορούν να κάνουν τα δεδομένα και όχι στο τι είναι αυτά
τα δεδομένα. Οι διεπαφές επίσης βοηθούν τον κώδικα να αποσυνδεθεί από την όποια αλλαγή, 
ζητώντας πραγματικά δεδομένα με βάση το τι μπορούν να κάνουν. Δεν περιορίζονται σε ένα τύπο
δεδομένων.

Κανείς πρέπει να βάλει τα δυνατά του, προκειμένου να κατανοήσει τι αλλαγές έρχονται στα 
δεδομένα και να χρησιμοποιήσει τις διεπαφές, για την αποσύνδεση του προγράμματος, από αυτές τις 
αλλαγές. Οι διεπαφές θα πρέπει να περιγράφουν συμπεριφορές και όχι κατάσταση. Πρέπει να 
ερμηνεύονται ως ρήματα και όχι ως ουσιαστικά.

Οι γενικές διεπαφές, που επικεντρώνονται στην συμπεριφορά, είναι οι καλύτερες. Οι διεπαφές 
με περισσότερες από μια μεθόδους τύπων έχουν περισσότερους από ένα λόγους να αλλάξουν.
Οι διεπαφές που βασίζονται σε ουσιαστικά, τείνουν να είναι λιγότερο επαναχρησιμοποιήσιμες, 
περισσότερο επιδεκτικές στην αλλαγή, και καταλήγουν να μην εξυπηρετούν τον σκοπό της διεπαφής.
Η αβεβαιότητα σχετικά με την αλλαγή, δεν αποτελεί άδεια για υποθέσεις, αλλά πρόκειται για προτροπή
να πραγματοποιήσει κανείς μια σύντομη διακοπή, προκειμένου να ενημερωθεί σχετικά, καλύτερα. Οφείλει κανείς 
να μάθει να ξεχωρίζει, εκείνο τον κώδικα που αμύνεται απέναντι στην εξαπάτηση, αντί του κώδικα που 
προστατεύει από ατυχήματα.

Ενδείκνυται η χρήση διεπαφής όταν:

- Οι χρήστες του API χρειάζεται να παρέχουν κάποια λεπτομέρεια στην υλοποίηση.
- Τα API έχουν πολλαπλές υλοποιήσεις, τις οποίες πρέπει κανείς να συντηρεί εσωτερικά.
- Υπάρχουν μέρη του API που έχουν διαπιστωθεί ως κάποια που πρόκειται να αλλάξουν και απαιτείται αποσύνδεση.

Δεν ενδείκνυται η χρήση διεπαφής όταν:
    
- Γίνεται, μόνο και μόνο, για την χρήση μιας διεπαφής.
- Γίνεται απόπειρα γενίκευσης ενός αλγόριθμου.
- Είναι δυνατόν οι χρήστες να δηλώσουν τις δικές τους διεπαφές.
- Δεν είναι εμφανές πως η διεπαφή καθιστά τον κώδικα καλύτερο.

** Οι Διεπαφές Δεν Έχουν Τιμές

Το πρώτο σημαντικό πράγμα, που οφείλει να κατανοήσει κανείς είναι, ότι ένας τύπος διεπαφής 
δηλώνει έναν τύπο χωρίς τιμή.

    type reader interface {
        read(b []byte) (int, error)
    }

Ο τύπος reader δεν είναι ένας τύπος struct, αλλά είναι ένας τύπος διεπαφής. Η δήλωση του,
δεν βασίζεται στην κατάσταση, αλλά στην συμπεριφορά. Οι τύποι διεπαφών δηλώνουν ένα σύνολο 
μεθόδων τύπου, που περιγράφουν συμπεριφορά, την οποία πραγματικά δεδομένα πρέπει να επιδεικνύουν, 
προκειμένου να ικανοποιούν την διεπαφή. Επειδή δεν υπάρχει τίποτα συγκεκριμένο/πραγματικό στις 
διεπαφές, θεωρούνται ότι δεν έχουν τιμές.

    var r reader

Επειδή δεν έχουν τιμές, η κατασκευή μιας μεταβλητής (όπως η r) είναι περίεργη, διότι στο
παρόν προγραμματιστικό υπόδειγμα, η r δεν υπάρχει, δεν έχει τιμή. Δεν υπάρχει τίποτα 
σχετικά με το r το ίδιο, που μπορεί κανείς να χειριστεί ή να μετατρέψει. Αυτό, είναι μια 
κρίσιμη έννοια, προς κατανόηση. Δεν δουλεύει κανείς με τιμές διεπαφών, μόνο με συγκεκριμένες 
τιμές. Μια διεπαφή έχει μια αναπαράσταση μεταγλωττιστή (εσωτερικός τύπος), όμως από την 
οπτική του τρέχοντος προγραμματιστικού υποδείγματος, οι διεπαφές δεν έχουν τιμές.

** Υλοποίηση Διεπαφών

Η Go είναι μια γλώσσα, που βασίζεται στην λογική των συμβάσεων, αντί της λογικής των ρυθμίσεων. 
Δεν υπάρχει εξαίρεση σε αυτό, ακόμα και όταν γίνεται λόγος για ένα πραγματικό τύπο, που
υλοποιεί μια διεπαφή. 

    type reader interface {
        read(b []byte) (int, error)
    }

    type file struct {
        name string
    }

    func (file) read(b []byte) (int, error) {
        s := "<rss><channel><title>Going Go</title></channel></rss>"
        copy(b, s)
        return len(s), nil
    }

Ο παραπάνω κώδικας δηλώνει ένα τύπο με το όνομα file και στην συνέχεια δηλώνει μια μέθοδο τύπου 
με το όνομα read. Εξαιτίας αυτών των δύο δηλώσεων, μπορεί κανείς να ισχυριστεί τα ακόλουθα:

"Ο πραγματικός τύπος file τώρα υλοποιεί την διεπαφή reader, κάνοντας χρήση σημειολογίας τιμής"

Κάθε λέξη που χρησιμοποιείται παραπάνω, είναι σημαντική. Στην Go, κανείς απλά χρειάζεται να 
δηλώσει το πλήρες σύνολο των μεθόδων τύπων της συμπεριφοράς που ορίζει αυτή η διεπαφή, προκειμένου 
να ικανοποιεί αυτή την διεπαφή. Σε αυτή την περίπτωση, αυτό έχει συμβεί καθώς η διεπαφή reader 
δηλώνει μονάχα μια συμπεριφορά, που ονομάζεται read.

    type reader interface {
        read(b []byte) (int, error)
    }

    type pipe struct {
        name string
    }

    func (pipe) read(b []byte) (int, error) {
        s := `{name: "Bill", title: "developer"}`
        copy(b, s)
        return len(s), nil
    }

Ο παραπάνω κώδικας δηλώνει έναν τύπο με το όνομα pipe και στην συνέχεια δηλώνει μια μέθοδο 
με το όνομα read. Εξαιτίας αυτών των δύο δηλώσεων μπορεί κανείς να ισχυριστεί τα ακόλουθα:

"Ο πραγματικός τύπος pipe τώρα υλοποιεί την διεπαφή reader, κάνοντας χρήση σημειολογία τιμής"

Σε αυτό το σημείο, υπάρχουν δύο πραγματικοί τύποι που υλοποιούν την διεπαφή reader. Ο κάθε 
ένας από αυτούς τους δύο πραγματικούς τύπους, έχει την δική του υλοποίηση. Ο ένας τύπος διαβάζει
συστήματα αρχείων και ο άλλος δίκτυα.

** Πολυμορφισμός

Η έννοια του πολυμορφισμού σημαίνει, ότι ένα τμήμα κώδικα αλλάζει την συμπεριφορά του, ανάλογα με 
τα πραγματικά δεδομένα επί των οποίων λειτουργεί. Αυτό ειπώθηκε από τον Tom Kurtz, ο οποίος είναι 
ο δημιουργός της BASIC. Σε ό,τι ακολουθεί, θα γίνει χρήση αυτού του ορισμού.

    // Η retrieve μπορεί να διαβάσει κάθε συσκευή και να επεξεργαστεί τα δεδομένα.
    func retrieve(r reader) error {
        data := make([]byte, 100)

        len, err := r.read(data)
        if err != nil {
            return err
        }

        fmt.Println(string(data[:len]))
        return nil
    }

Αξίζει κανείς να παρατηρήσει τον τύπο των δεδομένων, που δέχεται η παραπάνω συνάρτηση.
Δέχεται, λοιπόν, μια τιμή τύπου reader. Κάτι τέτοιο, όμως, είναι αδύνατο καθώς ο τύπος reader 
είναι μια διεπαφή και οι διεπαφές είναι τύποι χωρίς τιμές. Δεν είναι δυνατόν να ζητάει μια
τιμή reader, καθώς τέτοιες τιμές δεν υπάρχουν.

Αν, όμως, η συνάρτηση δεν ζητάει μια τιμή reader, τότε τι ακριβώς ζητάει; Αυτό που ζητάει, είναι
το μόνο που μπορεί να ζητήσει, δηλαδή πραγματικά δεδομένα. 

Η συνάρτηση retrieve είναι μια πολυμορφική συνάρτηση επειδή ζητάει πραγματικά δεδομένα, όχι 
βασιζόμενη στο τι είναι τα δεδομένα (πραγματικός τύπος), αλλά βασιζόμενη στο τι μπορούν να 
κάνουν τα δεδομένα (τύπος διεπαφής).

    f := file{"data.json"}
    p := pipe{"cfg_service"}

    retrieve(f)
    retrieve(p)

Είναι δυνατόν κανείς να δημιουργήσει δύο πραγματικές τιμές, μια τύπου file και μια τύπου pipe. 
Στην συνέχεια, μπορεί κανείς να περάσει ένα αντίγραφο της κάθε τιμής στην πολυμορφική συνάρτηση.
Αυτό συμβαίνει επειδή κάθε μια από αυτές τις τιμές, υλοποιεί το πλήρες σύνολο των μεθόδων τύπου 
της συμπεριφοράς, που ορίζεται από την διεπαφή reader.

Όταν περνάει στην retrieve η πραγματική τιμή file, τότε η τιμή αποθηκεύεται σε εσωτερικό τύπο που 
αποτελείται από δύο λέξεις, ο οποίος αντιπροσωπεύει την τιμή της διεπαφής.

.image /tour/grc/static/img/i1.png

Η δεύτερη λέξη της τιμής της διεπαφής, δείχνει προς την τιμή που αποθηκεύει. Σε αυτή την περίπτωση, 
πρόκειται για ένα αντίγραφο της τιμής file, καθώς χρησιμοποιείται σημειολογία τιμής. Η πρώτη λέξη 
δείχνει προς μια ειδική δομή δεδομένων, που αποκαλείται iTable.

Η iTable εξυπηρετεί 2 σκοπούς:

- Περιγράφει τον τύπο της τιμής, που αποθηκεύεται. Στην προκειμένη περίπτωση, πρόκειται για μια τιμή file.
- Παρέχει δείκτες διεύθυνσης τύπου συνάρτησης, στις πραγματικές υλοποιήσεις του συνόλου των μεθόδων τύπων, 
  που αντιστοιχούν στον τύπο της τιμής που αποθηκεύεται.

Όταν γίνεται η κλήση της read με την τιμή της διεπαφής, πραγματοποιείται μια αναζήτηση 
στην iTable, προκειμένου να εντοπιστεί η πραγματική υλοποίηση της μεθόδου read, που σχετίζεται με 
τον τύπο. Στην συνέχεια, γίνεται η κλήση της μεθόδου τύπου, με την τιμή που είναι αποθηκευμένη στην δεύτερη λέξη.

Μπορεί κανείς να ισχυριστεί, ότι η retrieve είναι μια πολυμορφική συνάρτηση, επειδή 
η πραγματική τιμή pipe μπορεί να περάσει στην retrieve και στην συνέχεια η κλήση 
της read, με την τιμή της διεπαφής, αλλάζει την συμπεριφορά της. Αυτή την φορά, 
η κλήση στην read διαβάζει ένα δίκτυο αντί ενός αρχείου.

** Κανόνες Συνόλου Μεθόδων Τύπου

Η υλοποίηση μιας διεπαφής με σημειολογία δείκτη διεύθυνσης επιβάλλει κάποιους περιορισμούς στην δυνατότητα 
συμμόρφωσης με την διεπαφή. 

    type notifier interface {
        notify()
    }

    type user struct {
        name  string
        email string
    }

    func (u *user) notify() {
        fmt.Printf("Sending User Email To %s<%s>\n", u.name, u.email)
    }

    func sendNotification(n notifier) {
        n.notify()
    }

    func main() {
        u := user{"Bill", "bill@email.com"}
        sendNotification(u)
    }

Η διεπαφή notifier υλοποιείται από τον τύπο user, χρησιμοποιώντας σημειολογία δείκτη 
διεύθυνσης. Όταν γίνεται χρήση σημειολογίας τιμής προκειμένου να γίνει η κλήση στην 
πολυμορφική συνάρτηση, παράγεται το ακόλουθο μήνυμα μεταγλωττιστή: 

    "δεν είναι δυνατόν να χρησιμοποιηθεί η u (τύπου user) σαν τύπος notifier σε όρισμα της sendNotification:
    ο user δεν υλοποιεί την notifier (η μέθοδος τύπου notify έχει δέκτη μεθόδου δείκτη διεύθυνσης)"

Αυτό συμβαίνει διότι, υπάρχει ένα ειδικό σύνολο κανόνων, στις προδιαγραφές (στμ. της γλώσσας) σχετικά με 
τα σύνολα των μεθόδων τύπων. Αυτοί οι κανόνες ορίζουν ποιες μέθοδοι τύπων προσκολλώνται
σε τιμές και δείκτες διεύθυνσης ενός τύπου. Έχουν οριστεί, προκειμένου να διατηρήσουν το
υψηλότερο επίπεδο συνοχής, στα προγράμματα. 

Οι ακόλουθοι κανόνες ορίζονται στις προδιαγραφές:

- Για κάθε τιμή τύπου T, μόνο εκείνες οι μέθοδοι τύπου που έχουν υλοποιηθεί με δέκτη μεθόδου τιμής, για αυτόν 
  τον τύπο, ανήκουν στο σύνολο μεθόδων τύπου, αυτής της τιμής.
- Για κάθε διεύθυνση μνήμης τύπου T, όλες οι μέθοδοι τύπου που υλοποιούνται γι' αυτόν τον τύπο, ανήκουν στο 
  σύνολο μεθόδων τύπου, αυτής της τιμής.
      
Με άλλα λόγια, όταν κανείς δουλεύει με μια διεύθυνση μνήμης (δείκτης διεύθυνσης), 
όλες οι μέθοδοι τύπου που είναι υλοποιημένες, έχουν προσκολληθεί και είναι διαθέσιμες 
προς κλήση. Όταν όμως, κανείς δουλεύει με μια τιμή, μόνο εκείνες οι μέθοδοι τύπου 
που έχουν υλοποιηθεί με δέκτες μεθόδου τιμής, έχουν προσκολληθεί και είναι διαθέσιμες 
προς κλήση.

Στο προηγούμενο μάθημα σχετικά με τις μεθόδους τύπων, ήταν δυνατόν να καλέσει κανείς 
μια μέθοδο τύπου από ένα πραγματικό στοιχείο δεδομένου, ανεξάρτητα από την σημειολογία 
δεδομένων που είχε δηλωθεί από τον λήπτη μεθόδου. Αυτό συνέβαινε διότι, ο μεταγλωττιστής
μπορεί να προσαρμοστεί, προκειμένου να πραγματοποιήσει την κλήση. Σε αυτή την περίπτωση, 
μια τιμή αποθηκεύεται εντός της διεπαφής και η μέθοδος τύπου πρέπει να υπάρχει. Δεν είναι
δυνατόν, να γίνει καμία προσαρμογή.

Επομένως, τώρα το ερώτημα διατυπώνεται ως εξής: Γιατί δεν είναι δυνατόν να προσκολληθούν 
μέθοδοι τύπων, που έχουν υλοποιηθεί με δέκτες μεθόδου δείκτες διευθύνσεων, σε τιμές τύπου T;
Ποιό ακριβώς είναι το ζήτημα συνοχής, στην παρούσα περίπτωση;

Ένας λόγος είναι, επειδή κανείς δεν μπορεί να εγγυηθεί, ότι κάθε τιμή τύπου T μπορεί να 
αποδώσει την διεύθυνση της. Αν μια τιμή δεν έχει διεύθυνση, αυτή δεν μπορεί να μοιραστεί.

    type duration int

    func (d *duration) notify() {
            fmt.Println("Sending Notification in", *d)
    }

    func main() {
        duration(42).notify()
    }

Σφάλμα Μεταγλωττιστή:

    δεν είναι δυνατόν να κληθεί η μέθοδος τύπου δείκτη διεύθυνσης στην duration(42)
    δεν είναι δυνατόν να πάρει κανείς την διεύθυνση της duration(42)

Στο παράδειγμα παραπάνω, η τιμή 42 είναι μια σταθερά είδους int. Μολονότι η τιμή 
μετατρέπεται σε τιμή τύπου duration, εντούτοις δεν αποθηκεύεται σε μια μεταβλητή.
Αυτό σημαίνει ότι, η τιμή δεν βρίσκεται ποτέ στην στοίβα ή στον σωρό. Δεν υπάρχει 
διεύθυνση μνήμης. Οι σταθερές υπάρχουν μονάχα κατά το στάδιο μεταγλώττισης.

Ο δεύτερος λόγος είναι και ο σημαντικότερος. Ο μεταγλωττιστής ενημερώνει ότι  
δεν επιτρέπεται κανείς να χρησιμοποιήσει σημειολογία τιμής, αν έχει ήδη επιλεγεί σημειολογία
δείκτη διεύθυνσης. Με άλλα λόγια, επιβάλλεται η κοινή χρήση της τιμής με την διεπαφή, 
επειδή δεν είναι ασφαλές να γίνει αντίγραφο μιας τιμής, στην οποία δείχνει ένας δείκτης
διεύθυνσης. Αν επιλέγει κανείς να υλοποιήσει την μέθοδο τύπου με σημειολογία δείκτη 
διεύθυνσης, τότε ουσιαστικά δηλώνει ότι η τιμή αυτού του τύπου δεν είναι ασφαλές να 
αντιγραφεί. 

    func main() {
        u := user{"Bill", "bill@email.com"}
        sendNotification(&u)
    }

Προκειμένου να διορθωθεί το μήνυμα του μεταγλωττιστή, πρέπει κανείς να χρησιμοποιήσει 
σημειολογία δείκτη διεύθυνσης στην κλήση της πολυμορφικής συνάρτησης και να μοιραστεί
την u. Η απάντηση δεν είναι η αλλαγή της μεθόδου τύπου, προκειμένου να χρησιμοποιεί 
σημειολογία τιμής.

** Φέτα Διεπαφών 

Όταν κανείς δηλώνει μια φέτα ενός τύπου διεπαφής, είναι δυνατόν να ομαδοποιήσει 
διαφορετικές πραγματικές τιμές με βάση το τι μπορούν να κάνουν. Γι' αυτό τον λόγο 
η Go, δεν χρειάζεται την έννοια του ορισμού υπο-τύπων (στμ. sub-typing). Δεν έχει να κάνει με κάποιο 
κοινό DNA, αλλά με κοινή συμπεριφορά. 

    type printer interface {
        print()
    }

    type canon struct {
        name string
    }

    func (c canon) print() {
        fmt.Printf("Printer Name: %s\n", c.name)
    }

    type epson struct {
        name string
    }

    func (e *epson) print() {
        fmt.Printf("Printer Name: %s\n", e.name)
    }

    func main() {
        c := canon{"PIXMA TR4520"}
        e := epson{"WorkForce Pro WF-3720"}

        printers := []printer{
            c,
            &e,
        }
        c.name = "PROGRAF PRO-1000"
        e.name = "Home XP-4100"

        for _, p := range printers {
            p.print()
        }
    }

Αποτέλεσμα:

    Printer Name: PIXMA TR4520
    Printer Name: Home XP-4100

Ο παραπάνω κώδικας παρουσιάζει πως μια φέτα τύπου διεπαφής printer, επιτρέπει την 
δημιουργία μιας συλλογής διαφορετικών πραγματικών τύπων printer. Διατρέχει 
διαδοχικά την συλλογή και εκμεταλλεύεται τον πολυμορφισμό, εφόσον η κλήση 
στην p.print μεταβάλλει την συμπεριφορά της, ανάλογα με την πραγματική τιμή που 
χρησιμοποιεί, την δεδομένη στιγμή, ο κώδικας. 

Το παράδειγμα, επίσης, δείχνει πως η επιλογή της σημειολογίας δεδομένων μεταβάλλει 
την συμπεριφορά του προγράμματος. Όταν αποθηκεύονται δεδομένα με χρήση σημειολογίας 
τιμής, η αλλαγή στην αρχική τιμή δεν είναι ορατή. Αυτό συμβαίνει, επειδή ένα αντίγραφο 
αποθηκεύεται εντός της διεπαφής. Όταν χρησιμοποιείται σημειολογία δείκτη διεύθυνσης,
οι όποιες αλλαγές στην αρχική τιμή γίνονται ορατές. 

** Σημειώσεις

- Το σύνολο μεθόδων τύπου για μια τιμή, συμπεριλαμβάνει μόνο μεθόδους που υλοποιούνται με δέκτη μεθόδου τιμής.
- Το σύνολο μεθόδων ενός δείκτη διεύθυνσης, συμπεριλαμβάνει μεθόδους που έχουν υλοποιηθεί με δέκτες μεθόδου 
  τόσο δείκτη διεύθυνσης όσο και τιμής.
- Οι μέθοδοι τύπων που έχουν δηλωθεί με δέκτη μεθόδου δείκτη διεύθυνσης, υλοποιούν την διεπαφή μόνο με τιμές 
  δείκτη διεύθυνσης.
- Οι μέθοδοι που έχουν δηλωθεί με δέκτη μεθόδου τιμής, υλοποιούν την διεπαφή με δέκτη μεθόδου τόσο τιμής όσο 
  και δείκτη διεύθυνσης.
- Οι κανόνες των συνόλων μεθόδων εφαρμόζονται σε τύπους διεπαφών.
- Οι διεπαφές είναι τύποι αναφοράς, δεν πρέπει να μοιράζονται με την χρήση δείκτη διεύθυνσης.
- Με αυτό τον τρόπο δημιουργείται πολυμορφική συμπεριφορά στην Go.

** Παραθέσεις

"Ο πολυμορφισμός σημαίνει, ότι γράφει κανείς ένα πρόγραμμα και αυτό συμπεριφέρεται διαφορετικά, ανάλογα με τα 
 δεδομένα επί των οποίων λειτουργεί" - Tom Kurtz (δημιουργός της BASIC)

"Η άδεια διεπαφή den λέει απολύτως τίποτα." - Rob Pike

"Το design είναι η τέχνη της διάρθρωσης κώδικα ο οποίος θα λειτουργεί σήμερα και θα είναι ευμετάβλητος 
 για πάντα." - Sandi Metz

"Μια κατάλληλη αφαίρεση αποσυνδέει τον κώδικα ώστε, κάθε αλλαγή να μην αντανακλάται στο σύνολο του 
 κώδικα." - Ronna Steinburg

** Πρόσθετα Αναγνώσματα

- [[https://golang.org/doc/effective_go.html#interfaces][Διεπαφές]]    
- [[https://blog.golang.org/laws-of-reflection][Οι Κανόνες Της Αντανάκλασης]] - Rob Pike    
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Μέθοδοι Τύπων, Διεπαφές και Ένθετοι Τύποι στην Go]] - William Kennedy    
- [[https://rakyll.org/interface-pollution/][Επιμόλυνση Διεπαφών]] - JBD    
- [[https://bravenewgeek.com/abstraction-considered-harmful/][Επικίνδυνη Αφαίρεση]] - Tyler Treat    
- [[https://www.ardanlabs.com/blog/2018/03/interface-values-are-valueless.html][Οι Τιμές Διεπαφών Είναι Χωρίς Τιμή]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2017/07/interface-semantics.html][Σημειολογία Διεπαφών]] - William Kennedy    
- [[https://www.hyrumslaw.com/][Ο Νόμος του Hyrum]] - Hyrum  
- [[https://www.youtube.com/watch?v=Pjz9WrXeOW0][Μηχανολογική Καινοτομία - Γιατί οι Περιορισμοί είναι Κρίσιμοι]] - André Eriksson (ΠΡΕΠΕΙ ΚΑΝΕΙΣ ΝΑ ΤΟ ΔΕΙ)

* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

*Μέρος* *Α:* Δηλώστε μια διεπαφή με το όνομα speaker με μια μέθοδο τύπου speak. Δηλώστε 
ένα struct με το όνομα english, που αντιπροσωπεύει ένα πρόσωπο, που μιλάει αγγλικά και 
δηλώστε ένα struct με το όνομα chinese, για κάποιον ο οποίος μιλάει κινέζικα. Υλοποιήστε 
την διεπαφή speaker για κάθε struct, χρησιμοποιώντας δέκτη μεθόδου τιμής και τις ακόλουθες 
ρητές συμβολοσειρές "Hello World" και "你好世界".
Δηλώστε μια μεταβλητή τύπου speaker και εκχωρείστε την διεύθυνση μνήμης μιας τιμής τύπου 
english και καλέστε την μέθοδο τύπου. Κάντε το ίδιο, για μια τιμή τύπου chinese.

*Μέρος* *Β:* Προσθέστε μια νέα συνάρτηση με το όνομα sayHello που αποδέχεται μια τιμή τύπου 
speaker. Υλοποιήστε αυτή την συνάρτηση ώστε, να καλέσει την μέθοδο speak στην τιμή διεπαφής. 
Στην συνέχεια, δημιουργείστε νέες τιμές για κάθε τύπο και χρησιμοποιήστε την συνάρτηση. 

.play interfaces/exercise1.go
.play interfaces/answer1.go
