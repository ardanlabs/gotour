Τύποι Μεταβλητών Struct
Οι τύποι μεταβλητών struct προσφέρουν ένα τρόπο δημιουργίας σύνθετων τύπων οι οποίοι ομαδοποιούν πεδία δεδομένων σε ένα ενιαίο σύνολο.

* Τύποι Μεταβλητών Struct

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιείστε το σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Οι τύποι μεταβλητών struct προσφέρουν ένα τρόπο δημιουργίας σύνθετων τύπων οι οποίοι ομαδοποιούν πεδία δεδομένων σε ένα ενιαίο σύνολο.
Αποτελούν ένα υπέροχο μέσο οργάνωσης και διαμοιρασμού διαφορετικών πτυχών των δεδομένων που 
καταναλώνουν τα προγράμματά μας.

Η δυνατή απόδοση που μπορεί να επιτύχει ο αρχιτεκτονικός σχεδιασμός ενός υπολογιστή εξαρτάται σχεδόν εξ ολοκλήρου από το
μήκος της λέξης (ο αριθμός των bit που είναι δυνατόν να επεξεργαστεί ανά πρόσβαση) και ακόμα πιο σημαντικά, από το 
μέγεθος της μνήμης ή αλλιώς, από το πλήθος των λέξεων στο οποίο μπορεί να έχει πρόσβαση.

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1:* Δήλωση, δημιουργία και ανάθεση αρχικής τιμής σε τύπους μεταβλητών struct.
- *Παράδειγμα* *2:* Ανώνυμοι τύποι struct.
- *Παράδειγμα* *3:* Επώνυμοι αντί Ανώνυμων τύπων. 
- *Παράδειγμα* *4:* Ευθυγραμμίσεις τύπων struct

.play struct-types/example1.go
.play struct-types/example2.go
.play struct-types/example3.go
.play struct-types/example4.go

** Τύποι struct και Μηχανισμοί Κατασκευής τους 

Ο παρακάτω ορισμός αποτελεί έναν συμπαγή (concrete) τύπο μεταβλητής που έχει οριστεί από τον χρήστη σαν ένα ενιαίο σύνολο από
διαφορετικά πεδία και τύπους.

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

Εδώ, γίνεται ο ορισμός μιας μεταβλητής τύπου example και η μεταβλητή λαμβάνει ως αρχική τιμή την κατάσταση μηδενικής τιμής.

    var e1 example

    fmt.Printf("%+v\n", e1)

Αποτέλεσμα:
    
    {flag:false counter:0 pi:0}

Εδώ, ορίζεται μια μεταβλητή τύπου example χωρίς να λαμβάνει την κατάσταση μηδενικής τιμής κάνοντας χρήση του συντακτικού κανόνα
της κατασκευής με ρητό τρόπο.

    e2 := example{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e2.flag)
    fmt.Println("Counter", e2.counter)
    fmt.Println("Pi", e2.pi)

Αποτέλεσμα:

    Flag true
    Counter 10
    Pi 3.141592

Εδώ, ορίζεται μια μεταβλητή ενός ανώνυμου ρητού τύπου και η μεταβλητή λαμβάνει μια τιμή διαφορετική από την κατάσταση μηδενικής τιμής
κάνοντας χρήση του συντακτικού κανόνα της κατασκευής με ρητό τρόπο.

    e3 := struct {
        flag    bool
        counter int16
        pi      float32
    }{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e3.flag)
    fmt.Println("Counter", e3.counter)
    fmt.Println("Pi", e3.pi)

Αποτέλεσμα:

    Flag true
    Counter 10
    Pi 3.141592

Η ιδέα πίσω από την δημιουργία ρητών τύπων είναι ακριβώς αυτό που αναφέρει η περιγραφή τους, δηλαδή η δημιουργία τύπων με ρητό τρόπο
χωρίς την χρήση κάποιου ονόματος για τον τύπο.

Κανείς θα πρέπει να χρησιμοποιεί την var για τον ορισμό μεταβλητών με την μηδενική τιμή και τον τελεστή σύντομης δήλωσης μαζί με 
τον συντακτικό κανόνα { } για τον ορισμό μεταβλητών με μη μηδενική τιμή. 

** Πλήρωση και Ευθυγράμμιση

Πόση μνήμη δεσμεύεται για μια τιμή τύπου example?

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

Μια μεταβλητή bool είναι 1 byte, αυτή του int16 είναι 2 byte και μια float32 μεταβλητή είναι 4 byte. Προσθέτοντας τα μεγέθη τους 
παίρνει κανείς αποτέλεσμα 7 byte. Όμως η πραγματική απάντηση είναι 8 byte. Γιατί; Επειδή επάρχει 
τοποθετημένο ένα byte πλήρωσης (padding) ανάμεσα στα πεδία flag και counter για λόγους ευθυγράμμισης του τύπου.

.image /tour/grc/static/img/f1.png

Η ιδέα πίσω από την έννοια της ευθγράμμισης είναι να επιτραπεί στον υλικό η ανάγνωση της μνήμης περισσότερο αποτελεσματικά
τοποθετώντας την χρησιμοποιούμενη μνήμη εντός συγκεκριμένων ορίων ευθυγράμμισης. Ο μεταγλωτιστής αναλαμβάνει να τακτοποιήσει τον μηχανισμό των ορίων ευθυγράμμισης ώστε να μην χρειάζεται να το κάνει ο χρήστης.

Ανάλογα με το μέγεθος του συγκεκριμένου πεδίου και την θέση που καταλαμβάνει στο struct, η Go
προσδιορίζει το αναγκαίο μέγεθος πλήρωσης.

    type example2 struct {
        flag    bool
        counter int16
        flag2   bool
        pi      float32
    }

Σε αυτό το παράδειγμα, προστέθηκε ένα νέο πεδίο με όνομα `flag2` ανάμεσα στα πεδία counter και pi. 
Κάτι τέτοιο προκαλεί περισσότερη πλήρωση εντός του struct.

    type example2 struct {
        flag    bool     // 0xc000100020 <- Αρχική Διεύθυνση 
                byte     // 0xc000100021 <- 1 byte πλήρωσης
        counter int16    // 0xc000100022 <- 2 byte ευθυγράμμισης 
        flag2   bool     // 0xc000100024 <- 1 byte ευθυγράμμισης
                byte     // 0xc000100025 <- 1 byte πλήρωσης
                byte     // 0xc000100026 <- 1 byte πλήρωσης
                byte     // 0xc000100027 <- 1 byte πλήρωσης
        pi      float32  // 0xc000100028 <- 4 byte ευθυγράμμισης
    }

Έτσι ακριβώς η ευθυγράμμιση και η πλήρωση διατάσσονται αν μια τιμή τύπου example2 ξεκινά
στην διεύθυνση μνήμης 0xc000100020. Το πεδίο flag αποτελεί την αρχική διεύθυνση και έχει 
μέγεθος μόνο 1 byte. Καθώς το πεδίο counter χρειάζεται 2 byte δεσμευμένης μνήμης, πρέπει 
να τοποθετηθεί στην μνήμη σε ευθυγράμμιση 2-byte, κάτι που οσυιαστικά σημαίνει ότι πρέπει να βρίσκεται σε
μια διεύθυνση μνήμης πολλαπλάσιο του 2. Κάτι τέτοιο απαιτεί το πεδίο counter να ξεκινάει στην διεύθυνση μνήμης 
0xc000100022. Με την σειρά του, αυτό δημιουργεί ένα κενό 1-byte ανάμεσα στα πεδία flag και counter.

.image /tour/grc/static/img/f2.png

Το πεδίο `flag2` είναι ένας bool και μπορεί να τοποθετηθεί στην επόμενη θέση μνήμης 0xc000100024. Το
τελευταίο πεδίο είναι το pi το οποίο απιτεί 4 byte δεσμευμένης μνήμης, συνεπώς χρειάζεται να βρίσκεται σε 
ευθυγράμμιση 4-byte. Η επόμενη διεύθυνση μνήμης για μια τιμή μεγέθους 4 byte είναι στην θέση 0xc000100028. Αυτό
σημαίνει ότι χρειάζονται 3 ακόμα byte πλήρωσης προκειμένου να διατηρηθεί η ορθή ευθυγράμμιση. Αυτό έχει σαν αποτέλεσμα 
μια τιμή τύπου type example2 να χρειάζεται 12 byte δεσμευμένης μνήμης συνολικά.

Το μεγαλύτερο πεδίο σε έναν struct αποτελεί το όριο ευθυγράμμισης για το σύνολο του 
struct. Σε αυτή την περίπτωση, το μεγαλύτερο πεδίο είναι 4 byte κατά συνέπεια η αρχική διεύθυνση για αυτή την
τιμή struct πρέπει να είναι πολλαπλάσιο του 4. Κανείς μπορεί να διαπιστώσει ότι η διεύθυνση μνήμης 0xc000100020 είναι
πράγματι πολλαπλάσιο του 4.

Αν χρειάζεται κανείς να ελαχιστοποιήσει το πλήθος των byte πλήρωσης, τότε πρέπει να τοποθετήσει τα πεδία ανάλογα 
με το μέγεθος της μνήμης που απαιτούν ξεκινώντας από αυτό με το μεγαλύτερο μέγεθος. Με αυτό τον τρόπο, τα όποια απαραίτητα byte πλήρωσης 
θα οδηγηθούν προς το τέλος του struct μειώνοντας κατ' αυτόν τον τρόπο το σύνολο των απαραίτητων byte πλήρωσης.

    type example struct {
        pi      float32  // 0xc000100020 <- Αχική Διεύθυνση 
        counter int16    // 0xc000100024 <- 2 byte ευθυγράμμισης
        flag    bool     // 0xc000100026 <- 1 byte ευθυγράμμισης
        flag2   bool     // 0xc000100027 <- 1 byte ευθυγράμμισης
    }

Ύστερα από την αναδιοργάνωση των πεδίων, η τιμή του struct χρειάζεται μόνο 8 byte 
δεσμευμένης μνήμης και όχι 12 byte. Καθώς όλα τα πεδία επιτρέπουν στην τιμή του struct να 
ευθυγραμμιστεί με ευθγράμμιση 4-byte, δεν χρειάζεται να χρησιμοποιηθούν επιπλέον byte πλήρωσης.

.image /tour/grc/static/img/f3.png

** Ορισμός Τιμών 

Ακόμα και αν κανείς έχει δύο τύπους με διαφορετικά ονόματα οι οποίοι είναι όμως πανομοιότυποι από την άποψη της δομής τους, πάλι δεν μπορεί κανείς να δώσει
την τιμής του ενός σε τιμή του άλλου.

Για παράδειγμα, έστω ότι οι τύποι example1 και example2 έχουν οριστεί με τον ίδιο ακριβώς 
ορισμό και δημιουργούμε δύο μεταβλητές τους οι οποίες λαμβάνουν ως αρχική τιμή την κατάσταση μηδενικής τιμής.

    var ex1 example1
    var ex2 example2

Κανείς, δεν μπορεί να δώσει την τιμή της μιας μεταβλητής στην άλλη καθώς είναι ορισμένες με διαφορετικούς επώνυμους
τύπους. Το γεγονός ότι, οι τύποι τους είναι, ουσιαστικά, ίδιοι δομικά, δεν έχει καμία εφαρμογή εδώ. 

    ex1 = ex2  // Ανεπίπτρεπτο, σφάλμα μεταγλωτιστή 

Προκειμένου να πραγματοποιηθεί η παραπάνω ανάθεση τιμής, κανείς θα έπρεπε να χρησιμοποιήσει τον συντακτικό κανόνα της μετατροπής τύπου και καθώς 
είναι δομικά απαράλλαχτοι, ο μεταγλωτιστής θα επιτρέψει κάτι τέτοιο.

    ex1 = example1(ex2)  // Επιτρέπεται, ΚΑΝΕΝΑ σφάλμα μεταγλωτιστή

Όμως, αν κανείς άλλαζε τον ορισμό της ex2 και έδινε τον ορισμό του τύπου της ως ένα ανώνυμο τύπο, με την ίδια ακριβή 
δήλωση όπως στον τύπο της ex1, δεν θα απαιτούνταν κανένας συντακτικός κανόνας μετατροπής τύπων.

    var ex2 struct {
        flag    bool
        counter int16
        pi      float32
    }

    ex1 = ex2  // Επιτρέπεται, ΚΑΜΙΑ ανάγκη για συντακτικό κανόνα μετατροπής τύπων 

Ο μεταγλωτιστής θα επιτρέψει αυτή την ανάθεση χωρίς την ανάγκη μετατροπής.

** Σημειώσεις 

- Κανείς μπορεί να χρησιμοποιήσει την ρητή μορφή ενός struct προκειμένου να αποδώσει αρχική τιμή σε μια μετάβλητή τύπου struct.
- Ο τελεστής τελεία (.) επιτρέπει την πρόσβαση στις τιμές των μεμονωμένων πεδίων.
- Είναι δυνατόν να ορίσει κανείς ανώνυμα struct.

** Παραθέσεις

"Η άρρητη μετατροπή τύπων είναι ο εφιάλτης της συγγραφής κώδικα. Οποιοσδήποτε το σκέφτηκε
αξίζει την προσωπική του κόλαση." - Martin Thompson

** Πρόσθετα Αναγνώσματα

- [[https://www.ardanlabs.com/blog/2013/07/understanding-type-in-go.html][Κατανοώντας τους Τύπους στην Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/07/object-oriented-programming-in-go.html][Αντικειμενοστραφής Προγραμματισμός στην Go]] - William Kennedy    
- [[https://dave.cheney.net/2015/10/09/padding-is-hard][Η Πλήρωση είναι Δύσκολη]] - Dave Cheney    
- [[https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/][Ευθυγράμμιση Μελών Δομών, Πλήρωση και Μετατροπή Δεδομένων σε Πακέτα]]    
- [[http://www.catb.org/esr/structure-packing][Η Χαμένη Τέχνη της Μετατροπής Δομών σε Πακέτα]] - Eric S. Raymond    

* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

*Μέρος* *Α:* Δηλώστε ένα τύπο struct προκειμένου να διατηρήσετε πληροφορίες σχετικά με ένα χρήστη (όνομα, 
email και ηλικία). Δημιουργήστε μια τιμή αυτού του τύπου, δώστε αρχικές τιμές και παρουσιάστε την τιμή 
κάθε πεδίου.

*Μέρος* *Β:* Δηλώστε και δώστε αρχική τιμή σε ένα ανώνυμο τύπο struct με τα ίδια τρια 
πεδία. Παρουσιάστε την τιμή του.

.play struct-types/exercise1.go
.play struct-types/answer1.go
