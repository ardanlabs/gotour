Τύποι Μεταβλητών Struct
Οι τύποι μεταβλητών struct, προσφέρουν ένα τρόπο δημιουργίας σύνθετων τύπων, οι οποίοι ομαδοποιούν πεδία δεδομένων, σε ένα ενιαίο σύνολο.

* Τύποι Μεταβλητών Struct

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιήστε το Σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Οι τύποι μεταβλητών struct, προσφέρουν ένα τρόπο δημιουργίας σύνθετων τύπων, οι οποίοι ομαδοποιούν πεδία δεδομένων, σε ένα ενιαίο σύνολο.
Αποτελούν ένα υπέροχο μέσο οργάνωσης και διαμοιρασμού διαφορετικών πτυχών των δεδομένων, που 
καταναλώνουν τα προγράμματά μας.

Η δυνατή απόδοση που μπορεί να επιτύχει ο αρχιτεκτονικός σχεδιασμός ενός υπολογιστή, εξαρτάται σχεδόν εξ ολοκλήρου, από το
μήκος της λέξης (ο αριθμός των bit που είναι δυνατόν να επεξεργαστεί ανά πρόσβαση) και αυτό που είναι ακόμα πιο σημαντικό, από το 
μέγεθος της μνήμης ή αλλιώς, από το πλήθος των λέξεων, στο οποίο μπορεί να έχει πρόσβαση.

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1:* Δήλωση, δημιουργία και ανάθεση αρχικής τιμής σε τύπους μεταβλητών struct.
- *Παράδειγμα* *2:* Ανώνυμοι τύποι struct.
- *Παράδειγμα* *3:* Επώνυμοι αντί Ανώνυμων τύπων. 
- *Παράδειγμα* *4:* Ευθυγραμμίσεις τύπων struct

.play struct-types/example1.go
.play struct-types/example2.go
.play struct-types/example3.go
.play struct-types/example4.go

** Τύποι struct και Μηχανισμοί Κατασκευής τους 

Ο παρακάτω ορισμός αποτελεί έναν συμπαγή (concrete) τύπο μεταβλητής, που έχει οριστεί από τον χρήστη, σαν ένα ενιαίο σύνολο από
διαφορετικά πεδία και τύπους.

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

Εδώ, γίνεται ο ορισμός μιας μεταβλητής τύπου example και η μεταβλητή λαμβάνει ως αρχική τιμή, την κατάσταση μηδενικής τιμής.

    var e1 example

    fmt.Printf("%+v\n", e1)

Αποτέλεσμα:
    
    {flag:false counter:0 pi:0}

Εδώ, ορίζεται μια μεταβλητή τύπου example χωρίς να λαμβάνει την κατάσταση μηδενικής τιμής κάνοντας χρήση του συντακτικού κανόνα
της κατασκευής μεταβλητών με ρητό τρόπο.

    e2 := example{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e2.flag)
    fmt.Println("Counter", e2.counter)
    fmt.Println("Pi", e2.pi)

Αποτέλεσμα:

    Flag true
    Counter 10
    Pi 3.141592

Εδώ, ορίζεται μια μεταβλητή ενός ανώνυμου ρητού τύπου και η μεταβλητή λαμβάνει μια τιμή διαφορετική από την κατάσταση μηδενικής τιμής,
κάνοντας χρήση του συντακτικού κανόνα της κατασκευής με ρητό τρόπο.

    e3 := struct {
        flag    bool
        counter int16
        pi      float32
    }{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e3.flag)
    fmt.Println("Counter", e3.counter)
    fmt.Println("Pi", e3.pi)

Αποτέλεσμα:

    Flag true
    Counter 10
    Pi 3.141592

Η ιδέα πίσω από την δημιουργία ρητών τύπων είναι ακριβώς αυτό που αναφέρει η περιγραφή τους, δηλαδή, η δημιουργία τύπων με ρητό τρόπο
χωρίς την χρήση κάποιου ονόματος για τον τύπο.

Θα πρέπει κανείς, να χρησιμοποιεί την var για τον ορισμό μεταβλητών με την μηδενική τιμή και τον τελεστή σύντομης δήλωσης μαζί με 
τον συντακτικό κανόνα { }, για τον ορισμό μεταβλητών με μη-μηδενική τιμή. 

** Πλήρωση και Ευθυγράμμιση

Πόση μνήμη δεσμεύεται για μια τιμή τύπου example?

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

Μια μεταβλητή bool είναι 1 byte, μια μεταβλητή int16 είναι 2 byte και μια float32 μεταβλητή είναι 4 byte. Προσθέτοντας τα μεγέθη τους, 
κανείς παίρνει αποτέλεσμα 7 byte. Όμως, η πραγματική απάντηση είναι 8 byte. Γιατί; Επειδή υπάρχει 
τοποθετημένο ένα byte πλήρωσης (padding) ανάμεσα στα πεδία flag και counter, για λόγους ευθυγράμμισης του τύπου.

.image /tour/grc/static/img/f1.png

Η ιδέα πίσω από την έννοια της ευθυγράμμισης, είναι να επιτραπεί στον υλικό η ανάγνωση της μνήμης περισσότερο αποτελεσματικά,
τοποθετώντας την χρησιμοποιούμενη μνήμη, εντός συγκεκριμένων ορίων ευθυγράμμισης. Ο μεταγλωττιστής αναλαμβάνει να τακτοποιήσει τον μηχανισμό των ορίων ευθυγράμμισης, ώστε να μην χρειάζεται να το κάνει ο χρήστης.

Ανάλογα με το μέγεθος του συγκεκριμένου πεδίου και την θέση που καταλαμβάνει στον struct, η Go
προσδιορίζει το αναγκαίο μέγεθος πλήρωσης.

    type example2 struct {
        flag    bool
        counter int16
        flag2   bool
        pi      float32
    }

Σε αυτό το παράδειγμα, προστέθηκε ένα νέο πεδίο με όνομα `flag2`, ανάμεσα στα πεδία counter και pi. 
Κάτι τέτοιο, προκαλεί περισσότερη πλήρωση εντός του struct.

    type example2 struct {
        flag    bool     // 0xc000100020 <- Αρχική Διεύθυνση 
                byte     // 0xc000100021 <- 1 byte πλήρωσης
        counter int16    // 0xc000100022 <- 2 byte ευθυγράμμισης 
        flag2   bool     // 0xc000100024 <- 1 byte ευθυγράμμισης
                byte     // 0xc000100025 <- 1 byte πλήρωσης
                byte     // 0xc000100026 <- 1 byte πλήρωσης
                byte     // 0xc000100027 <- 1 byte πλήρωσης
        pi      float32  // 0xc000100028 <- 4 byte ευθυγράμμισης
    }

Έτσι ακριβώς διατάσσονται η ευθυγράμμιση και η πλήρωση, αν μια τιμή τύπου example2 ξεκινά
στην διεύθυνση μνήμης 0xc000100020. Το πεδίο flag αποτελεί την αρχική διεύθυνση και έχει 
μέγεθος μόνο 1 byte. Καθώς το πεδίο counter χρειάζεται να δεσμεύσει 2 byte μνήμης, πρέπει 
να τοποθετηθεί στην μνήμη σε ευθυγράμμιση 2-byte, κάτι που ουσιαστικά σημαίνει ότι, πρέπει να βρίσκεται σε
μια διεύθυνση μνήμης που είναι πολλαπλάσιο του 2. Κάτι τέτοιο απαιτεί το πεδίο counter να ξεκινάει στην διεύθυνση μνήμης 
0xc000100022. Με την σειρά του, αυτό δημιουργεί ένα κενό 1-byte, ανάμεσα στα πεδία flag και counter.

.image /tour/grc/static/img/f2.png

Το πεδίο `flag2` είναι ένας bool και μπορεί να τοποθετηθεί στην επόμενη θέση μνήμης 0xc000100024. Το
τελευταίο πεδίο είναι το pi, το οποίο απαιτεί δέσμευση 4 byte μνήμης, συνεπώς χρειάζεται να βρίσκεται σε 
ευθυγράμμιση 4-byte. Η επόμενη διεύθυνση μνήμης για μια τιμή μεγέθους 4 byte, είναι στην θέση 0xc000100028. Αυτό
σημαίνει ότι χρειάζονται ακόμα 3 byte πλήρωσης, προκειμένου να διατηρηθεί η ορθή ευθυγράμμιση. Αυτό έχει σαν αποτέλεσμα, 
μια τιμή τύπου type example2, να χρειάζεται 12 byte δεσμευμένης μνήμης, συνολικά.

Το μεγαλύτερο πεδίο σε έναν struct, αποτελεί το όριο ευθυγράμμισης για το σύνολο του 
struct. Σε αυτή την περίπτωση, το μεγαλύτερο πεδίο είναι 4 byte, κατά συνέπεια η αρχική διεύθυνση για αυτή την
τιμή struct πρέπει να είναι πολλαπλάσιο του 4. Μπορεί κανείς να διαπιστώσει ότι, η διεύθυνση μνήμης 0xc000100020 είναι
πράγματι πολλαπλάσιο του 4.

Αν χρειάζεται κανείς να ελαχιστοποιήσει το πλήθος των byte πλήρωσης, τότε πρέπει να τοποθετήσει τα πεδία ανάλογα 
με το μέγεθος της μνήμης που απαιτούν, ξεκινώντας από αυτό με το μεγαλύτερο μέγεθος. Με αυτό τον τρόπο, τα όποια απαραίτητα byte πλήρωσης, 
θα οδηγηθούν προς το τέλος του struct μειώνοντας κατ' αυτόν τον τρόπο το σύνολο των απαραίτητων byte πλήρωσης.

    type example struct {
        pi      float32  // 0xc000100020 <- Αχική Διεύθυνση 
        counter int16    // 0xc000100024 <- 2 byte ευθυγράμμισης
        flag    bool     // 0xc000100026 <- 1 byte ευθυγράμμισης
        flag2   bool     // 0xc000100027 <- 1 byte ευθυγράμμισης
    }

Ύστερα από την αναδιοργάνωση των πεδίων, η τιμή του struct χρειάζεται μόνο 8 byte 
δεσμευμένης μνήμης και όχι 12 byte. Καθώς όλα τα πεδία επιτρέπουν στην τιμή του struct να 
ευθυγραμμιστεί με ευθυγράμμιση 4-byte, δεν χρειάζεται να χρησιμοποιηθούν επιπλέον byte πλήρωσης.

.image /tour/grc/static/img/f3.png

** Ορισμός Τιμών 

Ακόμα και αν κανείς έχει δύο τύπους με διαφορετικά ονόματα, οι οποίοι όμως είναι πανομοιότυποι από την άποψη της δομής τους, ούτε σε αυτή την περίπτωση δεν μπορεί κανείς να δώσει
την τιμής του ενός σε τιμή του άλλου.

Για παράδειγμα, έστω ότι οι τύποι example1 και example2 έχουν οριστεί με τον ίδιο ακριβώς 
ορισμό και έστω ότι δημιουργούμε δύο μεταβλητές τους, οι οποίες λαμβάνουν ως αρχική τιμή την κατάσταση μηδενικής τιμής.

    var ex1 example1
    var ex2 example2

Δεν μπορεί κανείς να δώσει την τιμή της μιας μεταβλητής στην άλλη, καθώς είναι ορισμένες με διαφορετικούς επώνυμους
τύπους. Το γεγονός ότι, οι τύποι τους είναι ουσιαστικά ίδιοι δομικά, δεν έχει καμία εφαρμογή εδώ. 

    ex1 = ex2  // Ανεπίτρεπτο, σφάλμα μεταγλωττιστή 

Προκειμένου να πραγματοποιηθεί η παραπάνω ανάθεση τιμής, θα έπρεπε κανείς να χρησιμοποιήσει τον συντακτικό κανόνα της μετατροπής τύπου και καθώς 
είναι δομικά απαράλλαχτοι, ο μεταγλωττιστής θα επιτρέψει κάτι τέτοιο.

    ex1 = example1(ex2)  // Επιτρέπεται, ΚΑΝΕΝΑ σφάλμα μεταγλωττιστή

Όμως, αν κανείς άλλαζε τον ορισμό της ex2 και έδινε τον ορισμό του τύπου της ως ένα ανώνυμο τύπο, με την ίδια ακριβή 
δήλωση όπως στον τύπο της ex1, δεν θα απαιτούνταν κανένας συντακτικός κανόνας μετατροπής τύπων.

    var ex2 struct {
        flag    bool
        counter int16
        pi      float32
    }

    ex1 = ex2  // Επιτρέπεται, ΚΑΜΙΑ ανάγκη για συντακτικό κανόνα μετατροπής τύπων 

Ο μεταγλωττιστής θα επιτρέψει αυτή την ανάθεση, χωρίς την ανάγκη μετατροπής.

** Σημειώσεις 

- Κανείς μπορεί να χρησιμοποιήσει την ρητή μορφή ενός struct, προκειμένου να αποδώσει αρχική τιμή σε μια μεταβλητή τύπου struct.
- Ο τελεστής τελεία (.) επιτρέπει την πρόσβαση στις τιμές των μεμονωμένων πεδίων.
- Είναι δυνατόν να ορίσει κανείς ανώνυμα struct.

** Παραθέσεις

"Η άρρητη μετατροπή τύπων είναι ο εφιάλτης της συγγραφής κώδικα. Οποιοσδήποτε το σκέφτηκε
αξίζει την προσωπική του κόλαση." - Martin Thompson

** Πρόσθετα Αναγνώσματα

- [[https://www.ardanlabs.com/blog/2013/07/understanding-type-in-go.html][Κατανοώντας τους Τύπους στην Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/07/object-oriented-programming-in-go.html][Αντικειμενοστραφής Προγραμματισμός στην Go]] - William Kennedy    
- [[https://dave.cheney.net/2015/10/09/padding-is-hard][Η Πλήρωση είναι Δύσκολη]] - Dave Cheney    
- [[https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/][Ευθυγράμμιση Μελών Δομών, Πλήρωση και Μετατροπή Δεδομένων σε Πακέτα]]    
- [[http://www.catb.org/esr/structure-packing][Η Χαμένη Τέχνη της Μετατροπής Δομών σε Πακέτα]] - Eric S. Raymond    

* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

*Μέρος* *Α:* Δηλώστε ένα τύπο struct προκειμένου να διατηρήσετε πληροφορίες σχετικά με ένα χρήστη (όνομα, 
email και ηλικία). Δημιουργήστε μια τιμή αυτού του τύπου, δώστε αρχικές τιμές και παρουσιάστε την τιμή 
κάθε πεδίου.

*Μέρος* *Β:* Δηλώστε και δώστε αρχική τιμή σε ένα ανώνυμο τύπο struct με τα ίδια τρια 
πεδία. Παρουσιάστε την τιμή του.

.play struct-types/exercise1.go
.play struct-types/answer1.go
