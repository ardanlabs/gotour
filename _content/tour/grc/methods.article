Μέθοδοι Τύπων
Μια συνάρτηση αποκαλείται μέθοδος, όταν αυτή η συνάρτηση έχει ορισμένο δέκτη μεθόδου.

* Μέθοδοι Τύπων

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιήστε το Σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Μια συνάρτηση αποκαλείται ως μια μέθοδος, όταν αυτή η συνάρτηση έχει ορισμένο δέκτη μεθόδου. 
Ο δέκτης μεθόδου είναι εκείνη η παράμετρος, που δηλώνεται ανάμεσα στην λέξη-κλειδί func και
το όνομα της συνάρτησης.

** Ανασκόπηση Κώδικα

- *Παράδειγμα* *1:* Δήλωση και συμπεριφορά δέκτη μεθόδου
- *Παράδειγμα* *2:* Επώνυμες μέθοδοι με τύπο
- *Παράδειγμα* *3:* Μεταβλητές Συναρτήσεων/Μεθόδων
- *Παράδειγμα* *4:* Τύποι Συναρτήσεων
- *Παράδειγμα* *5:* Σημειολογία Τιμής και Δείκτη Διεύθυνσης

.play methods/example1.go
.play methods/example2.go
.play methods/example3.go
.play methods/example4.go
.play methods/example5.go

** Δηλώσεις Μεθόδων 

Ύπάρχουν δύο είδη δεκτών μεθόδου, δέκτες μεθόδου τιμής που υλοποιούν σημειολογία τιμής
και δέκτες μεθόδου δείκτη διεύθυνσης για την υλοποίηση σημειολογία δείκτη διεύθυνσης.

    type user struct {
        name  string
        email string
    }

    func (u user) notify() {
        fmt.Printf("Sending User Email To %s<%s>\n", u.name, u.email)
    }

    func (u *user) changeEmail(email string) {
        u.email = email
        fmt.Printf("Changed User Email To %s\n", email)
    }

Η συνάρτηση notify υλοποιείται με δέκτη μεθόδου τιμής. Αυτό σημαίνει, ότι η μέθοδος
λειτουργεί με σημειολογία τιμής και θα επιδρά στο δικό της αντίγραφο της τιμής, 
που χρησιμοποιείται για να γίνει η κλήση μεθόδου.

Η συνάρτηση changeEmail υλοποιείται με δέκτη μεθόδου δείκτη διεύθυνσης. Αυτό σημαίνει, 
ότι η μέθοδος λειτουργεί με σημειολογία δείκτη διεύθυνσης και θα ενεργεί, έχοντας κοινή
πρόσβαση στην τιμή, που πραγματοποιεί την κλήση μεθόδου.

Εκτός από μερικές εξαιρέσεις, το σύνολο μεθόδων για ένα τύπο, δεν πρέπει να περιέχει ένα 
μείγμα δεκτών μεθόδων τιμών και δεικτών διεύθυνσης. Η σημειολογική συνέπεια των δεδομένων 
είναι κρίσιμα σημαντική και κάτι τέτοιο συμπεριλαμβάνει και την δήλωση μεθόδων.

** Κλήσεις Μεθόδων 

Όταν γίνεται μια κλήση μεθόδου, ο μεταγλωττιστής δεν ενδιαφέρεται αν η τιμή που χρησιμοποιείται 
για να γίνει η κλήση, ταιριάζει ακριβώς με την σημειολογία δεδομένων του δέκτη μεθόδου. Ο 
μεταγλωττιστής, απλά θέλει μια τιμή ή έναν δείκτη διεύθυνσης, κατάλληλου τύπου.

    bill := user{"Bill", "bill@email.com"}
    bill.notify()
    bill.changeEmail("bill@hotmail.com")

Είναι εμφανές, ότι μια τιμή τύπου user δημιουργείται και εκχωρείται στην μεταβλητή bill. 
Στην περίπτωση της κλήσης της notify, η μεταβλητή bill ταιριάζει στον τύπο του δέκτη μεθόδου,
που είναι δέκτης μεθόδου τιμής. Στην περίπτωση της κλήσης στην changeEmail, η μεταβλητή 
bill δεν ταιριάζει στον τύπο δέκτη μεθόδου, που είναι δέκτης μεθόδου δείκτη διεύθυνσης.
Όμως, ο μεταγλωττιστής δέχεται την κλήση της μεθόδου και μοιράζεται την μεταβλητή bill με την
μέθοδο. Η Go προσαρμόζεται, για να γίνει η κλήση.

Αυτό λειτουργεί παρόμοια όταν η μεταβλητή, που χρησιμοποιείται για να γίνει η κλήση, είναι μια 
μεταβλητή δείκτη διεύθυνσης.

    bill := &user{"Bill", "bill@email.com"}
    bill.notify()
    bill.changeEmail("bill@hotmail.com")

Σε αυτή την περίπτωση, η μεταβλητή bill είναι μια μεταβλητή δείκτη διεύθυνσης σε μια τιμή τύπου user.
Ξανά, η Go προσαρμόζεται για να κάνει την κλήση της μεθόδου, όταν καλείται η μέθοδος notify.

Αν η Go δεν προσαρμοζόταν, τότε τα παρακάτω είναι αυτά που θα έπρεπε να γίνουν, προκειμένου να γίνουν
οι ίδιες κλήσεις μεθόδων. 

    bill := user{"Bill", "bill@email.com"}
    (&bill).changeEmail("bill@hotmail.com")

    bill := &user{"Bill", "bill@email.com"}
    (*bill).notify()

Είναι ευτυχές, που δεν χρειάζεται να συμβεί αυτό, προκειμένου να καλέσει κανείς μεθόδους, στην Go.

** Οδηγίες Σημειολογίας Δεδομένων για Τύπους Ορισμένους Εσωτερικά

Σαν μια γενική κατεύθυνση, αν τα δεδομένα με τα οποία δουλεύει κανείς είναι κάποιος εσωτερικός τύπος (φέτα (στμ. slice), 
σχεσιακός πίνακας (στμ. map), κανάλι επικοινωνίας (στμ. channel), συνάρτηση (στμ. function), διεπαφή (στμ. interface)), τότε 
ενδείκνυται η χρήση σημειολογίας τιμής για την μετακίνηση δεδομένων γύρω στο πρόγραμμα. Αυτό περιλαμβάνει την 
δήλωση πεδίων, σε κάποιο τύπο. Όμως, όταν γίνεται ανάγνωση και εγγραφή πρέπει κανείς να θυμάται, ότι ενδείκνυται
η χρήση σημειολογίας δείκτη διευθύνσεων.

    type IP []byte
    type IPMask []byte

Οι παραπάνω τύποι δηλώνονται στο πακέτο net, που είναι μέρος της προεγκατεστημένης βιβλιοθήκης.
Δηλώνονται με υποκείμενο τύπο, μια φέτα από byte. Εξαιτίας αυτού του γεγονότος, αυτοί οι τύποι 
ακολουθούν τις οδηγίες για τους εσωτερικούς τύπους.

    func (ip IP) Mask(mask IPMask) IP {
        if len(mask) == IPv6len && len(ip) == IPv4len && allFF(mask[:12]) {
            mask = mask[12:]
        }
        if len(mask) == IPv4len && len(ip) == IPv6len &&
            bytesEqual(ip[:12], v4InV6Prefix) {
            ip = ip[12:]
        }
        n := len(ip)
        if n != len(mask) {
            return nil
        }
        out := make(IP, n)
        for i := 0; i < n; i++ {
            out[i] = ip[i] & mask[i]
        }
        return out
    }

Με την μέθοδο Mask, χρησιμοποιείται σημειολογία τιμής, τόσο για τον δέκτη μεθόδου, 
όσο και για την παράμετρο και για το το όρισμα επιστροφής. Αυτή η μέθοδος λαμβάνει το 
δικό της αντίγραφο της τιμής μιας Mask, μετατρέπει αυτή την τιμή και στην συνέχεια 
επιστρέφει ένα αντίγραφο της μετατροπής. Αυτή η μέθοδος χρησιμοποιεί μετατροπή 
σημειολογίας τιμής. Δεν πρόκειται για ατύχημα ή τυχαίο γεγονός.

Μια συνάρτηση μπορεί να αποφασίσει τι είδους είσοδο και έξοδο χρειάζεται. Αυτό που δεν 
μπορεί να αποφασίσει είναι η σημειολογία των δεδομένων, για τον τρόπο με τον οποίο τα 
δεδομένα ρέουν εντός και εκτός αυτής. Την απόφαση αυτή την επιβάλλουν τα δεδομένα και η συνάρτηση
οφείλει να συμμορφωθεί. Γι' αυτό η Mask υλοποιεί api μετατροπής, με σημειολογία τιμής. Οφείλει
να σεβαστεί, τον τρόπο με το τον οποίο έχει σχεδιαστεί μια φέτα, ώστε να μετακινείται γύρω στο πρόγραμμα.

    func ipEmptyString(ip IP) string {
        if len(ip) == 0 {
            return ""
        }
        return ip.String()
    }

Η συνάρτηση `ipEmptyString` χρησιμοποιεί, επίσης, σημειολογία τιμής για την είσοδο 
και την έξοδο. Η συνάρτηση δέχεται το δικό της αντίγραφο μιας τιμής IP και επιστρέφει 
μια τιμή συμβολοσειράς. Δεν υπάρχει χρήση σημειολογίας δείκτη διεύθυνσης, επειδή τα 
δεδομένα υποδεικνύουν την σημειολογία δεδομένων και όχι η συνάρτηση.

Μια εξαίρεση στην χρήση σημειολογίας τιμής είναι όταν κανείς χρειάζεται να μοιραστεί μια
φέτα ή έναν σχεσιακό πίνακα με μια συνάρτηση, που πραγματοποιεί αποσειριοποίηση 
(στμ. unmarshaling) ή αποκωδικοποίηση.

** Οδηγίες Σημειολογίας Δεδομένων για Τύπους Struct

Σαν γενική κατεύθυνση, αν τα δεδομένα με τα οποία δουλεύει κανείς είναι τύπου struct, τότε
κανείς οφείλει να αναλογιστεί τι αναπαριστούν τα δεδομένα, προκειμένου να παρθεί μια απόφαση.
Ένας καλός γενικός κανόνας είναι να αναλογιστεί κανείς, αν το struct αναπαριστά δεδομένα ή 
κάποιο API. Αν το struct αναπαριστά δεδομένα, τότε ενδείκνυται η χρήση σημειολογίας τιμής. 
Αν το struct αναπαριστά ένα API, τότε ενδείκνυται η χρήση σημειολογίας δείκτη διεύθυνσης.

    type Time struct {
        sec  int64
        nsec int32
        loc  *Location
    }

Παραπάνω, παρουσιάζεται το struct Time, από το πακέτο time. Αν θεωρήσει κανείς ότι η Time 
αναπαριστά δεδομένα, τότε πρέπει να να γίνει χρήση σημειολογίας τιμής, για αυτό το struct.

Όταν κανείς κάνει επισκόπηση σε ένα υπάρχον σύνολο κώδικα και προσπαθεί να κατανοήσει, τι
είδους σημειολογία δεδομένων έχει επιλεγεί, είναι χρήσιμο να αναζητήσει, αν υπάρχει κάποια 
συνάρτηση παραγωγής (στμ. factory function). Ο τύπος επιστροφής της συνάρτησης παραγωγής πρέπει 
να υποδεικνύει την σημειολογία των δεδομένων, που έχει επιλεγεί από τον developer.

    func Now() Time {
        sec, nsec := now()
        return Time{sec + unixToInternal, nsec, Local}
    }

Η Now είναι η συνάρτηση παραγωγής για την δημιουργία τιμών Time. Κοιτώντας στην 
επιστροφή της, κανείς βλέπει ότι χρησιμοποιείται σημειολογία τιμής. Αυτό 
υποδεικνύει ότι κανείς θα πρέπει να χρησιμοποιήσει σημειολογία τιμής για τιμές
Time, πράγμα που σημαίνει ότι κάθε συνάρτηση θα λαμβάνει το δικό της αντίγραφο 
μιας τιμής Time, ενώ πεδία σε κάποιο struct θα πρέπει να δηλώνονται ως τιμές τύπου
Time.

    func (t Time) Add(d Duration) Time {
        t.sec += int64(d / 1e9)
        nsec := int32(t.nsec) + int32(d%1e9)
        if nsec >= 1e9 {
            t.sec++
            nsec -= 1e9
        } else if nsec < 0 {
            t.sec--
            nsec += 1e9
        }
        t.nsec = nsec
        return t
    }

Η Add είναι μια μέθοδος που πρέπει να πραγματοποιήσει μια λειτουργία μετατροπής. 
Αν κανείς κοιτάξει προσεκτικά, είναι δυνατόν να παρατηρήσει, ότι η συνάρτηση 
χρησιμοποιεί μετατροπή, με σημειολογία τιμής. Η μέθοδος Add λαμβάνει το δικό της 
αντίγραφο της τιμής Time, που χρησιμοποιείται για να γίνει η κλήση, μετατρέπει 
το δικό της αντίγραφο, στην συνέχεια επιστρέφει ένα αντίγραφο στον καλώντα. Ξανά, 
αυτός είναι ο ασφαλέστερος τρόπος να πραγματοποιηθεί μια λειτουργία μετατροπής.

    func div(t Time, d Duration) (qmod2 int, r Duration) {}

Παραπάνω, είναι ένα ακόμα παράδειγμα, όπου η συνάρτηση div δέχεται μια τιμή τύπου Time 
και μια τύπου Duration (int64), στην συνέχεια επιστρέφει τιμές τύπων int και Duration. 
Παρατηρεί κανείς την σημειολογία τιμής για τον τύπο Time και για όλους τους 
προεγκατεστημένους τύπους. Ο τύπος Duration έχει ένα υποκείμενο τύπο int64.

    func (t *Time) UnmarshalBinary(data []byte) error {}
    func (t *Time) GobDecode(data []byte) error {}
    func (t *Time) UnmarshalJSON(data []byte) error {}
    func (t *Time) UnmarshalText(data []byte) error {}

Οι τέσσερεις παραπάνω μέθοδοι, από το πακέτο Time, φαίνεται ότι δεν ακολουθούν τους 
κανόνες, σχετικά με την συνέπεια της σημειολογίας δεδομένων. Αντίθετα, χρησιμοποιούν 
σημειολογία δείκτη διεύθυνσης. Το ερώτημα είναι, γιατί συμβαίνει αυτό; Η απάντηση 
είναι, διότι οι μέθοδοι αυτοί υλοποιούν μια διεπαφή μεθόδων, όπου η υπογραφή των μεθόδων 
είναι ήδη δοσμένη. Καθώς η υλοποίηση απαιτεί μια λειτουργία μετατροπής, η χρήση 
σημειολογίας δείκτη διεύθυνσης φαίνεται να είναι η μόνη επιλογή.

Ορισμένες κατευθυντήριες γραμμές είναι τα εξής: Αν χρησιμοποιείται σημειολογία τιμής,
κανείς μπορεί να αλλάξει σε σημειολογία δείκτη διεύθυνσης για κάποιες συναρτήσεις, εφόσον
δεν επιτραπεί στα δεδομένα, στην υπολειπόμενη αλυσίδα κλήσεων, να επιστρέψει σε σημειολογία
τιμής. Όταν γίνει η αλλαγή σε σημειολογία δείκτη διεύθυνσης, όλες οι μελλοντικές κλήσεις
από αυτό το σημείο και μετά, πρέπει να επιμείνουν σε σημειολογία δείκτη διεύθυνσης. Κανείς, δεν 
πρέπει να οδηγηθεί από σημειολογία δείκτη διεύθυνσης, σε σημειολογία τιμής. Δεν είναι ποτέ 
ασφαλές να γίνει αντίγραφο μιας τιμής, στην οποία δείχνει ένας δείκτης διεύθυνσης.

    func Open(name string) (file *File, err error) {
        return OpenFile(name, O_RDONLY, 0)
    }

Η συνάρτηση Open από το πακέτο os δείχνει ότι όταν κανείς κάνει χρήση μιας τιμής τύπου File,
γίνεται χρήση σημειολογία δείκτη διεύθυνσης. Οι τιμές τύπου File πρέπει να μοιράζονται και 
δεν πρέπει ποτέ να αντιγράφονται.

    func (f *File) Chdir() error {
        if f == nil {
            return ErrInvalid
        }
        if e := syscall.Fchdir(f.fd); e != nil {
            return &PathError{"chdir", f.name, e}
        }
        return nil
    }

Η μέθοδος Chdir χρησιμοποιεί έναν δέκτη μεθόδου δείκτη διεύθυνσης, παρόλο που αυτή η μέθοδος 
δεν μετατρέπει την τιμή File. Αυτό συμβαίνει διότι οι τιμές File πρέπει να μοιράζονται και 
δεν πρέπει να αντιγράφονται.

    func epipecheck(file *File, e error) {
        if e == syscall.EPIPE {
            if atomic.AddInt32(&file.nepipe, 1) >= 10 {
                sigpipe()
            }
        } else {
            atomic.StoreInt32(&file.nepipe, 0)
        }
    }

Η συνάρτηση epipecheck επίσης, δέχεται τιμές File κάνοντας χρήση σημειολογία δείκτη διεύθυνσης.

** Οι Μέθοδοι Είναι Απλά Συναρτήσεις 

Οι μέθοδοι είναι στην πραγματικότητα απλά συναρτήσεις, που χρησιμοποιούν συντακτικές διευκολύνσεις
για να παρέχουν την δυνατότητα σε δεδομένα να επιδείξουν συμπεριφορές.

    type data struct {
        name string
        age  int
    }

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

Παραπάνω, δηλώνονται ένας τύπος και δύο μέθοδοι τύπου. Η μέθοδος τύπου displayName 
χρησιμοποιεί σημειολογία τιμής και η setAge χρησιμοποιεί σημειολογία δείκτών διεύθυνσης.

Σημείωση: Δεν πρέπει κανείς να υλοποιεί (στμ. συναρτήσεις/μεθόδους) ορισμού κατάστασης 
(στμ. setters) και λήψης κατάστασης (στμ. getters) στην Go. Αυτά δεν είναι api με κάποιο συγκεκριμένο 
σκοπό και σε αυτές τις περιπτώσεις, είναι προτιμότερο να καθιστά κανείς τα σχετικά πεδία 
του τύπου, ως εξαγόμενα.
    
    d := data{
        name: "Bill",
    }

    d.displayName()
    d.setAge(21)

Παραπάνω, δημιουργείται μια τιμή τύπου data και πραγματοποιούνται κλήσεις μεθόδων.

    data.displayName(d)
    (*data).setAge(&d, 21)

Καθώς οι μέθοδοι τύπων είναι στην πραγματικότητα, απλά συναρτήσεις με συντακτικές 
διευκολύνσεις, μια μέθοδος μπορεί να εκτελεστεί ακριβώς όπως μια συνάρτηση. 
Μπορεί κανείς να παρατηρήσει ότι ο δέκτης μεθόδου είναι στην πραγματικότητα μια 
παράμετρος, ειδικότερα πρόκειται για την πρώτη παράμετρο. Όταν γίνεται η κληση μιας 
μεθόδου, ο μεταγλωττιστής μετατρέπει αυτή την κλήση, σε μια κλήση συνάρτησης.

Σημείωση: Δεν πρέπει κανείς να εκτελεί μεθόδους τύπων, κατ' αυτόν τον τρόπο, όμως 
είναι πιθανό να παρατηρήσει κανείς αυτό το συντακτικό, σε μηνύματα εργαλείων της γλώσσας.

** Γνώση της Συμπεριφοράς του Κώδικα

Αν κανείς γνωρίζει την σημειολογία δεδομένων που ισχύει, τότε γνωρίζει και την συμπεριφορά 
του κώδικα. Αν κανείς γνωρίζει την συμπεριφορά του κώδικα, τότε γνωρίζει το κόστος του κώδικα. 
Από την στιγμή που είναι γνωστό το κόστος, κανείς λειτουργεί ως μηχανικός.

Με τον παρακάτω τύπο και το σύνολο μεθόδων του:

    type data struct {
        name string
        age  int
    }

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

Κανείς μπορεί να γράψει τον ακόλουθο κώδικα.

    func main() {
        d := data{
            name: "Bill",
        }

        f1 := d.displayName
        f1()
        d.name = "Joan"
        f1()
    }

Αποτέλεσμα:

    My Name Is Bill
    My Name Is Bill

Κανείς, ξεκινάει με την κατασκευή μιας τιμής τύπου Data εκχωρώντας την στην 
μεταβλητή d. Στην συνέχεια, παίρνει κανείς την μέθοδο τύπου displayName, η 
οποία είναι δεσμευμένη στην d και την εκχωρεί σε μεταβλητή, με την ονομασία f1. 
Αυτό δεν είναι κλήση μεθόδου αλλά μια εκχώρηση, που δημιουργεί ένα ακόμα επίπεδο 
ενδιάμεση λειτουργίας (στμ. indirection). Οι συναρτήσεις είναι τιμές στην Go και 
ανήκουν στους τύπους, οι οποίοι είναι ορισμένοι εσωτερικά.

Μετά την εκχώρηση, μπορεί κανείς να καλέσει την μέθοδο έμμεσα, κάνοντας χρήση της 
μεταβλητής f1. Αυτό παρουσιάζει το όνομα Bill. Στην συνέχεια, μπορεί κανείς να αλλάξει 
τα δεδομένα, ώστε το όνομα να είναι τώρα Joan και να καλέσει ξανά την μέθοδο τύπου, 
μέσω της μεταβλητής f1. Με αυτή την εναλλαγή όμως, δεν είναι εμφανής η αλλαγή. Το όνομα
Bill είναι πάλι το αποτέλεσμα. Γιατί συμβαίνει αυτό;

.image /tour/grc/static/img/m1.png

Το παραπάνω αποτέλεσμα συνδέεται άμεσα, με την εφαρμοζόμενη σημειολογία δεδομένων. Η 
μέθοδος τύπων displayName χρησιμοποιεί ως δέκτη μεθόδου μια τιμή, συνεπώς η ισχύουσα
σημειολογία δεδομένων είναι εκείνη των τιμών.

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

Αυτά σημαίνουν, ότι η μεταβλητή f1 διατηρεί και λειτουργεί με βάση το δικό της 
αντίγραφο της d. Επομένως, καλώντας την μέθοδο τύπου μέσω της μεταβλητής f1, θα
χρησιμοποιεί πάντα το αντίγραφο και αυτό το αντίγραφο είναι προστατευμένο από τις
μετατροπές. Αυτό είναι που επιζητά κανείς, με την σημειολογία τιμής. 

Τώρα, μπορεί κανείς να κάνει το ίδιο, με την μέθοδο τύπου setAge.

    func main() {
        d := data{
            name: "Bill",
        }

        f2 := d.setAge
        f2(45)
        d.name = "Sammy"
        f2(45)
    }

Αποτέλεσμα:

    Bill Is Age 45
    Sammy Is Age 45

Αυτή την φορά, η μέθοδος τύπου setAge εκχωρείται στην μεταβλητή f2. Ξανά, η μέθοδος
τύπου εκτελείται έμμεσα μέσω της μεταβλητής f2, που περνάει την τιμή 45 για την ηλικία
του Bill. Στην συνέχεια, το όνομα του Bill αλλάζει σε Sammy και η μεταβλητή f2 
ξαναχρησιμοποιείται για να γίνει η κλήση. Αυτή την φορά, το όνομα έχει αλλάξει.

.image /tour/grc/static/img/m2.png

Η συνάρτηση setAge χρησιμοποιεί δέκτη μεθόδου δείκτη διεύθυνσης, επομένως η setAge δεν 
λειτουργεί στο δικό της αντίγραφο της μεταβλητής d, αλλά λειτουργεί απευθείας επάνω στην
μεταβλητή d. Επομένως η f2 λειτουργεί επί κοινής πρόσβασης και μπορεί κανείς να παρατηρήσει 
την μεταβολή.

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

Χωρίς να γνωρίζει κανείς την ισχύουσα σημειολογία δεδομένων, δεν είναι δυνατόν να γνωρίζει την 
συμπεριφορά του κώδικα. Η ισχύουσα σημειολογία δεδομένων είναι πραγματική και επηρεάζει την 
συμπεριφορά. 

** Σημειώσεις

- Οι μέθοδοι τύπων είναι συναρτήσεις, που δηλώνουν μια μεταβλητή δέκτη μεθόδου.
- Οι δέκτες μεθόδου δεσμεύουν μια μέθοδο τύπου σε κάποιο τύπο και είναι δυνατόν να χρησιμοποιούν 
  σημειολογία τιμής ή δείκτη διεύθυνσης.
- Η σημειολογία τιμής σημαίνει ότι, κατά μήκος των ορίων του προγράμματος, περνάει ένα αντίγραφο της τιμής.
- Η σημειολογία δείκτη διεύθυνσης σημαίνει ότι, κατά μήκος των ορίων του προγράμματος, περνάει ένα αντίγραφο 
  της διεύθυνσης της τιμής.
- Οφείλει κανείς να επιλέγει μοναδική σημειολογία για κάποιο τύπο και να επιδεικνύει συνέπεια, με την επιλογή 
  αυτή.

** Παραθέσεις

"Οι μέθοδοι τύπων είναι εύλογοι όταν είναι πρακτικό ή λογικό για κάποιο κομμάτι δεδομένων να αποκαλύπτει κάποια δυνατότητα." - William Kennedy

** Πρόσθετα Αναγνώσματα

- [[https://golang.org/doc/effective_go.html#methods][Μέθοδοι Τύπων]]    
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Μέθοδοι Τύπων, Διεπαφές και Ένθετοι Τύποι στην Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2018/01/escape-analysis-flaws.html][Ελαττώματα της Ανάλυσης Διαφυγής]] - William Kennedy  
		 
* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

Δηλώστε ένα struct, που αντιπροσωπεύει έναν παίκτη baseball. Συμπεριλάβετε τα πεδία name, 
atBats and hits. 
Δηλώστε μια μέθοδο τύπου, που υπολογίζει την μέση τιμή των χτυπημάτων ενός παίκτη. Ο τύπος 
είναι Hits / AtBats.
Δηλώστε μια φέτα αυτού του τύπου και δώστε ως αρχική τιμή αρκετούς παίκτες. Πραγματοποιείστε 
διαδοχική επίσκεψη των στοιχείων της φέτας, παρουσιάζοντας στην συνέχεια το πεδίο name και την 
μέση τιμή χτυπημάτων του κάθε παίκτη.

.play methods/exercise1.go
.play methods/answer1.go
