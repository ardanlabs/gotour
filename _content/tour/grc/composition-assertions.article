Μετατροπές Τύπων και Διαβεβαιώσεις
Μαθαίνοντας πως λειτουργούν οι μετατροπές τύπων και οι διαβεβαιώσεις.

* Μετατροπές Τύπων και Διαβεβαιώσεις

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιείστε το σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Μια μετατροπή τύπου, επιτρέπει στα δεδομένα ενός τύπου, να μετατραπούν σε κάποιο άλλο τύπο. Μια 
διαβεβαίωση τύπου, επιτρέπει να ρωτήσει κανείς, αν υπάρχει μια τιμή ενός δοσμένου τύπου αποθηκευμένη 
εντός της διεπαφής.

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1:* Μετατροπές Διεπαφών 
- *Παράδειγμα* *2:* Διαβεβαιώσεις Τύπων Σταδίου Εκτέλεσης
- *Παράδειγμα* *3:* Αλλαγές Συμπεριφοράς 

.play composition/assertions/example1.go
.play composition/assertions/example2.go
.play composition/assertions/example3.go

** Σιωπηρές Μετατροπές Διεπαφών

Όπως φαίνεται στο τελευταίο παράδειγμα, μια τιμή διεπαφής ενός τύπου, μπορεί να περάσει
ως ένας διαφορετικός τύπος διεπαφής, αν η πραγματική τιμή που είναι αποθηκευμένη μέσα 
στην διεπαφή, υλοποιεί και τις δύο συμπεριφορές. Κάτι τέτοιο, θα μπορούσε να θεωρηθεί ως 
μια σιωπηρή μετατροπή διεπαφής, όμως είναι καλύτερο να σκέφτεται κανείς, πώς, τα πραγματικά 
δεδομένα μετακινούνται μέσω των διεπαφών, σε μια αποδεσμευμένη κατάσταση.

    type Mover interface {
        Move()
    }

    type Locker interface {
        Lock()
        Unlock()
    }

    type MoveLocker interface {
        Mover
        Locker
    }

Με βάση τις τρεις διεπαφές παραπάνω, όπου η MoveLocker είναι μια σύνθεση μιας Mover και μιας Locker:

    type bike struct{}

    func (bike) Move() {
        fmt.Println("Moving the bike")
    }

    func (bike) Lock() {
        fmt.Println("Locking the bike")
    }

    func (bike) Unlock() {
        fmt.Println("Unlocking the bike")
    }

Και με βάση τον πραγματικό τύπο bike, που υλοποιεί και τις τρεις διεπαφές, τι μπορεί να κάνει κανείς;

    var ml MoveLocker
    var m Mover

Κανείς, μπορεί να δημιουργήσει μια τιμή τύπου MoveLocker και Mover με την τιμή μηδενικής κατάστασης.
Αυτές είναι τιμές διεπαφών, οι οποίες είναι πραγματικά χωρίς τιμή. 

    ml = bike{}

Στην συνέχεια, μπορεί κανείς να δημιουργήσει μια τιμή τύπου bike με την κατάσταση 
μηδενικής τιμής και να εκχωρήσει ένα αντίγραφο στην μεταβλητή ml τύπου MoveLocker. 
Κάτι τέτοιο είναι δυνατό, επειδή μια bike υλοποιεί και τις τρεις συμπεριφορές, και 
ο μεταγλωττιστής μπορεί να δει ότι η υλοποίησει, υπάρχει.

    m = ml

Στην συνέχεια, μπορεί κανείς να εκχωρήσει την μεταβλητή ml, τύπου MoveLocker, στην 
μεταβλητή m, τύπου Mover. Αυτό είναι δυνατό, επειδή δεν γίνεται η ανάθεση της τιμής 
διεπαφής ml, αλλά της πραγματικής τιμής που είναι αποθηκευμένη εντός της ml, που είναι 
μια τιμή bike. Ο μεταγλωττιστής γνωρίζει ότι κάθε πραγματική τιμή που βρίσκεται 
αποθηκευμένη στην ml, πρέπει, επίσης, να υλοποιεί και την διεπαφή Mover.

Η ακόλουθη εκχώρηση όμως, δεν είναι έγκυρη. 

    ml = m

Αποτέλεσμα:

    δεν γίνεται να χρησιμοποιηθεί η m (τύπου Mover) ως τύπος MoveLocker στην εκχώρηση:
        Ο Mover δεν υλοποιεί την MoveLocker (λείπει η μέθοδος τύπου Lock)

Δεν γίνεται να εκχωρηθεί στην μεταβλητή m τύπου Mover, στην μεταβλητή ml τύπου MoverLocker, 
επειδή ο μεταγλωττιστής μπορεί εγγυηθεί μόνο, ότι η πραγματική τιμή, που είναι αποθηκευμένη 
εντός της m, γνωρίζει πως να υλοποιήσει την συμπεριφορά Move. Δεν είναι γνωστό στο στάδιο 
μεταγλώττισης, αν η πραγματική τιμή γνωρίζει, επίσης, πως να επιδεικνύει την συμπεριφορά Lock 
και την Unlock. 

** Μηχανισμός Διαβεβαίωσης Τύπου 

Μια διαβεβαίωση τύπου, επιτρέπει στο στάδιο εκτέλεσης να γίνει η εξής ερώτηση: αν υπάρχει μια
τιμή ενός συγκεκριμένου τύπου, αποθηκευμένη μέσα σε μια διεπαφή. Γίνεται εμφανές αυτό, με τον 
συντακτικό τύπο m.(bike). 

    b := m.(bike)
    ml = b

Σε αυτή την περίπτωση, κανείς, ρωτάει αν υπάρχει μια τιμή bike αποθηκευμένη μέσα στην m, κατά 
την στιγμή εκτέλεσης του κώδικα. Αν πράγματι υπάρχει, τότε η μεταβλητή b αποκτά ένα αντίγραφο
της αποθηκευμένης τιμής bike. Στην συνέχεια, το αντίγραφο μπορεί να αντιγραφεί εντός της 
μεταβλητής διεπαφής ml.

Αν δεν υπάρχει μια τιμή bike, αποθηκευμένη μέσα στην τιμή της διεπαφής, τότε το πρόγραμμα μπαίνει
σε κατάσταση panic. Κάτι τέτοιο, είναι ευπρόσδεκτο αν θα έπρεπε οπωσδήποτε να υπάρχει αποθηκευμένη 
μια τιμή bike. Τι θα συμβεί όμως, αν υπάρχει μια περίπτωση να μην υπάρχει αποθηκευμένη κάποια τέτοια
τιμή και αυτό να είναι έγκυρο; Σε αυτή την περίπτωση κανείς, χρειάζεται μια δεύτερη μορφή διαβεβαίωσης
τύπου.

    b, ok := m.(bike)

Στην παραπάνω μορφή, αν η ok είναι αληθής, τότε υπάρχει μια τιμή bike αποθηκευμένη στην διεπαφή. 
Αν η ok είναι εσφαλμένη, τότε δεν υπάρχει τέτοια τιμή και το πρόγραμμα δεν μπαίνει σε κατάσταση 
panic. Η μεταβλητή b εξακολουθεί να είναι τύπου bike, όμως λαμβάνει την τιμή μηδενικής 
κατάστασης.

    func main() {
        mvs := []fmt.Stringer{
            Car{},
            Cloud{},
        }

        for i := 0; i < 10; i++ {
            rn := rand.Intn(2)

            if v, is := mvs[rn].(Cloud); is {
                fmt.Println("Got Lucky:", v)
                continue
            }

            fmt.Println("Got Unlucky")
        }
    }

Υποθέτωντας ότι το πρόγραμμα δεν δηλώνει δύο τύπους ονομαζόμενους Car και Cloud, καθένας
απ' τους οποίους υλοποιεί την διεπαφή fmt.Stringer, είναι δυνατόν να δημιουργηθεί μια 
συλλογή, που επιτρέπει την αποθήκευση μιας τιμής τόσο Car όσο και Cloud. Στην συνέχεια για 
10 φορές, επιλέγοντας τυχαία έναν αριθμό από το 0 μέχρι το 1, και πραγματοποιώντας διαβεβαίωση
τύπου, προκειμένου να εξακριβωθεί αν η τιμή στον τυχαίο δείκτη, περιέχει μια τιμή Cloud. Καθώς
είναι δυνατόν η τιμή αυτή να μην είναι τύπου Cloud, η δεύτερη μορφή της διαβεβαίωσης τύπου, είναι
κρίσιμη, σε αυτή την περίπτωση.
