Υποκείμενοι Τύποι
Είναι δυνατόν να δηλώσει κανείς ένα γενικό τύπο, χρησιμοποιώντας έναν υποκείμενο τύπο.

* Γενικός Προγραμματισμός - Υποκείμενοι Τύποι

Είναι δυνατόν να δηλώσει κανείς ένα γενικό τύπο, χρησιμοποιώντας έναν υποκείμενο τύπο.

** Video

Μπορεί κανείς να παρακολουθήσει την ομιλία του Bill Kennedy, σχετικά με τον Γενικό Προγραμματισμό,
που παρουσιάζει λεπτομερώς όλα τα παραδείγματα αυτής της ενότητας της Επισκόπησης.

.html generics-video.html

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1*: Πραγματικός τύπος διανύσματος
- *Παράδειγμα* *2*: Τύπος διανύσματος διεπαφής
- *Παράδειγμα* *3*: Γενικός Τύπος διανύσματος

.play generics/underlying-types/example1.go
.play generics/underlying-types/example2.go
.play generics/underlying-types/example3.go

** Επεξήγηση

Τι θα συνέβαινε αν κανείς ήθελε να δηλώσει έναν γενικό τύπο, κάνοντας χρήση ενός υποκείμενου τύπου;

    type vector[T any] []T

    func (v vector[T]) last() (T, error) {
        var zero T
        
        if len(v) == 0 {
            return zero, errors.New("empty")
        }
        
        return v[len(v)-1], nil
    }

Το παράδειγμα παραπάνω παρουσιάζει έναν γενικό τύπο διανύσματος, που περιορίζει 
την κατασκευή ενός διανύσματος από ένα τύπο δεδομένων. Η χρήση των αγκυλών δηλώνει ότι 
ο τύπος T είναι ένας γενικός τύπος, που πρέπει να προσδιοριστεί κατά το στάδιο μεταγλώττισης. 
Η χρήση του περιορισμού "any" περιγράφει ότι δεν υπάρχει περιορισμός στο τι μπορεί να είναι 
ο τύπος T.

Η μέθοδος τύπου last δηλώνεται με έναν δέκτη μεθόδου τύπου vector[T], προκειμένου να
αναπαραστήσει μια τιμή τύπου vector με υποκείμενο τύπο μια φέτα τύπου T. Η μέθοδος τύπου 
επιστρέφει μια τιμή του ίδιου τύπου T.

    func main() {
        fmt.Print("vector[int] : ")

        vGenInt := vector[int]{10, -1}

        i, err := vGenInt.last()
        if err != nil {
            fmt.Print("ERROR:", err)
            return
        }

        if i < 0 {
            fmt.Print("negative integer: ")
        }

        fmt.Printf("value: %d\n", i)

        // -------------------------------------------------------------------------

        fmt.Print("vector[string] : ")

        vGenStr := vector[string]{"A", "B", string([]byte{0xff})}

        s, err := vGenStr.last()
        if err != nil {
            fmt.Print("ERROR:", err)
            return
        }

        if !utf8.ValidString(s) {
            fmt.Print("non-valid string: ")
        }

        fmt.Printf("value: %q\n", s)
    }

Αποτέλεσμα:

    vector[int] : negative integer: value: -1
    vector[string] : non-valid string: value: "\xff"

Με το τρόπο που παρουσιάζεται παρακάτω, δημιουργείται μια τιμή τύπου vector με υποκείμενο
τύπο int όταν κανείς αποδώσει τιμές στο vector, κατά την κατασκευή του. Μια σημαντική 
πτυχή αυτού του κώδικα είναι οι κλήσεις δημιουργίας.

    // Κατασκευή Μηδενικής Τιμής 
    var vGenInt vector[int]
    var vGenStr vector[string]
    
    // Κατασκευή με μη Μηδενική Τιμή
    vGenInt := vector{10, -1}
    vGenStr := vector{"A", "B", string([]byte{0xff})}

Όταν πρέπει να γίνει η κατασκευή αυτών των γενικών τύπων με την μηδενική τιμή τους,
ο μεταγλωττιστής δεν είναι δυνατόν να συμπεράνει τον τύπο. Όμως σε περιπτώσεις, 
όπου υπάρχει η ανάθεση αρχικής τιμής κατά την διάρκεια της κατασκευής, ο μεταγλωττιστής 
μπορεί να συνάγει τον τύπο.

Υπάρχει μια πτυχή των προδιαγραφών της γλώσσας, που επικεντρώνεται στην κατασκευή ενός 
γενικού τύπου, με την κατάσταση μηδενικής τιμής.

    type vector[T any] []T
    
    func (v vector[T]) last() (T, error) {
        var zero T
        
        if len(v) == 0 {
            return zero, errors.New("empty")
        }
        
        return v[len(v)-1], nil
    }

Πρέπει κανείς να δώσει έμφαση στην δήλωση μεθόδου τύπου, για την τελευταία μέθοδο τύπου 
και πως αυτή η μέθοδος τύπου επιστρέφει μια τιμή, του γενικού τύπου T. Στην πρώτη 
επιστροφή έχει κανείς μια κατάσταση, όπου πρέπει να επιστρέψει την μηδενική τιμή για τον
τύπο T. Η τρέχουσα υλοποίηση παρέχει δύο λύσεις, προκειμένου να γραφεί αυτός ο κώδικας. 
Η πρώτη λύση είναι αυτή που παρουσιάζεται παραπάνω. Δημιουργείται μια μεταβλητή με το
όνομα zero και παίρνει την κατάσταση μηδενική τιμής του τύπου T και στην συνέχεια αυτή 
η μεταβλητή χρησιμοποιείται για την επιστροφή.

Η άλλη επιλογή, είναι η χρήση της προεγκατεστημένης συνάρτησης new και στην συνέχεια να 
επιστραφεί η τιμή δείκτη διεύθυνσης που δημιούργησε η new, αφού πρώτα μετατραπεί από 
αναφορά σε τιμή (dereference).

    type vector[T any] []T
    
    func (v vector[T]) last() (T, error) {
        if len(v) == 0 {
            return *new(T), errors.New("empty")
        }
        
        return v[len(v)-1], nil
    }

Η παραπάνω εκδοχή της μεθόδου τύπου last, χρησιμοποιεί την προεγκατεστημένη συνάρτηση 
new, προκειμένου να δημιουργηθεί η μηδενική τιμή και μετατρέπει στην συνέχεια την αναφορά
δείκτη διεύθυνσης που επιστράφηκε σε τιμή, προκειμένου να ικανοποιηθεί η δήλωση επιστροφής
τύπου T.

Σημείωση: Μπορεί κανείς να σκεφτεί να χρησιμοποιήσει την ρητή κατασκευή T{} προκειμένου να δημιουργήσει 
την μηδενική τιμή. Το πρόβλημα εδώ είναι ότι αυτό το συντακτικό δεν δουλεύει με όλους τους 
τύπους, όπως είναι οι βαθμωτοί τύποι (int, string, bool). Επομένως, δεν πρόκειται για 
πραγματική επιλογή.

* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

Ορίστε ένα γενικό τύπο με το όνομα keymap που χρησιμοποιεί, ως υποκείμενο 
τύπο, έναν σχεσιακό πίνακα με κλειδί τύπου συμβολοσειράς και τιμή 
κάποιο τύπο T. Δηλώστε μια μέθοδο τύπου με το όνομα set, που αποδέχεται ένα 
κλειδί με τύπο συμβολοσειράς και μια τιμή τύπου T. Δηλώστε μια μέθοδο τύπου
με το όνομα get, που αποδέχεται ένα κλειδί τύπου συμβολοσειράς και επιστρέφει 
μια τιμή τύπου Τ καθώς και true ή false αν το κλειδί βρεθεί ή όχι. Στην συνέχεια,
γράψτε μια συνάρτηση main, που χρησιμοποιεί αυτές τις μεθόδους. 

.play generics/underlying-types/exercise1.go 
.play generics/underlying-types/answer1.go
