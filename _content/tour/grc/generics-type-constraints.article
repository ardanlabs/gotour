Τύποι ως Περιορισμοί 
Πρόκειται για μια νέα έννοια στην Go, όπου ένας περιορισμός μπορεί να βασιστεί σε ένα σύνολο πραγματικών τύπων.

* Γενικός Προγραμματισμός - Τύποι ως περιορισμός

Πρόκειται για μια νέα έννοια στην Go, όπου ένας περιορισμός μπορεί να βασιστεί σε ένα σύνολο πραγματικών τύπων.
Αυτή η πρακτική, δουλεύει μόνο στον γενικό προγραμματισμό.

** Video

Μπορεί κανείς να παρακολουθήσει την ομιλία του Bill Kennedy, σχετικά με τον Γενικό Προγραμματισμό,
που παρουσιάζει λεπτομερώς όλα τα παραδείγματα αυτής της ενότητας της Επισκόπησης.

.html generics-video.html

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1*: Περιορισμοί βασισμένοι σε τύπους 
- *Παράδειγμα* *2*: Προεγκατεστημένος περιορισμός "comparable"
- *Παράδειγμα* *3*: Μείγμα περιορισμών βασισμένοι σε τύπους και σε συμπεριφορά

.play generics/type-constraints/example1.go
.play generics/type-constraints/example2.go
.play generics/type-constraints/example3.go

** Επεξηγήσεις

Οι συναρτήσεις γενικού προγραμματισμού δημιουργούν έναν νέο τύπο περιορισμού, που δεν μπορεί να αναχθεί 
σε δηλώσεις ενός συνόλου συμπεριφορών από μεθόδους τύπου.

    func Add[T ???](v1 T, v2 T) T {
        return v1 + v2
    }

Παραπάνω, είναι μια συνάρτηση γενικού προγραμματισμού, που θέλει να δεχθεί δύο τιμές 
κάποιου τύπου T, να τις προσθέσει και στην συνέχεια να επιστρέψει το άθροισμά τους 
στον καλώντα. Κάτι τέτοιο, πρόκειται για ένα ενδιαφέρον πρόβλημα, επειδή ο μεταγλωττιστής 
πρέπει να περιορίσει την κληση στην συνάρτηση, ώστε εκείνη να δέχεται μόνο τιμές, οι οποίες
μπορούν πράγματι να χρησιμοποιηθούν σε μία λειτουργία πρόσθεσης. Προς το παρόν, δεν 
υπάρχει μηχανισμός, για να δηλωθούν περιορισμοί αυτού του είδους. 

Η απόφαση που πάρθηκε, ήταν να συνεχιστεί να χρησιμοποιείται ο μηχανισμός των διεπαφών, 
προκειμένου να γίνεται η δήλωση των περιορισμών αλλά και προκειμένου να προστεθεί και 
κάτι καινούργιο.

    type addOnly interface {
        string | int | int8 | int16 | int32 | int64 | float64
    }

Μπορεί κανείς να δηλώσει μια διεπαφή, που ορίζει ένα σύνολο τύπων, οι οποίοι αποτελούν τον 
περιορισμό. Στην συνέχεια, ο παραπάνω περιορισμός, εφαρμόζεται σε μια συνάρτηση γενικού προγραμματισμού.

    func Add[T addOnly](v1 T, v2 T) T {
        return v1 + v2
    }

Τώρα, ο μεταγλωττιστής μπορεί να επικυρώσει ότι, το σύνολο των τύπων που εμπεριέχει ο
περιορισμός, συμμορφώνεται με τις λειτουργίες που θέλει να πραγματοποιήσει η συνάρτηση, 
σε τιμές αυτών των τύπων. Όταν η διεπαφή χρησιμοποιεί προεγκατεστημένους τύπους, τότε
τέτοιες διεπαφές μπορούν να ξαναχρησιμοποιηθούν, σε άλλα πακέτα. Όταν ο κατάλογος των τύπων 
περιέχει τύπους ορισμένους από τον χρήστη στο πακέτο, πρέπει κανείς να θυμάται, ότι αυτές
οι συναρτήσεις γενικού προγραμματισμού, δεσμεύονται στους τύπους του πακέτου και τίποτα περισσότερο.

Οι διεπαφές που δηλώνονται να περιέχουν ένα σύνολο τύπων, δεν μπορούν να χρησιμοποιηθουν 
σε μια παραδοσιακά πολυμορφική συνάρτηση. Άλλωστε, κάτι τέτοιο δεν θα είχε νόημα, όμως 
πρόκειται για μια κατάσταση, που δεν δίνει την αίσθηση της Go, υπό την έννοια, ότι αυτή η 
αλλαγή στις διεπαφές και πως χρησιμοποιούνται, δεν είναι ορθογώνια. 

Μια ιδέα, είναι η ύπαρξη ή η δημιουργία προεγκατεστημένων αναγνωριστικών, προκειμένου να 
αναπαριστούν περιορισμούς, για κοινές λειτουργίες.

    func index[T comparable](list []T, find T) int {
        for i, v := range list {
            if v == find {
                return i
            }
        }
        
        return -1
    }

Ο περιορισμός comparable δηλώνεται από την γλώσσα και περιορίζει τους τύπους, σε 
εκείνους που είναι σε θέση να πάρουν μέρος σε μια δήλωση σύγκρισης. Στο παρακάτω
παράδειγμα, τόσο η v όσο και η find είναι μεταβλητές ενός τύπου T ενώ και οι δύο μπαίνουν σε 
διαδικασία σύγκρισης. Υπάρχει επίσης η ιδέα, ότι ένα πακέτο στην βασική βιβλιοθήκη 
θα μπορούσε να παρέχει ένα σύνολο συνήθων περιορισμών. 

Δεν υπάρχει κανένας περιορισμός σε μια διεπαφή, ώστε να δηλώνεται τόσο με ένα σύνολο τύπων 
όσο και με συμπεριφορές, από ένα σύνολο μεθόδων τύπων.

    type matcher[T any] interface {
        type person, food
        match(v T) bool
    }
        
    func match[T matcher[T]](list []T, find T) int {
        for i, v := range list {
            if v.match(find) {
                return i
            }
        }
        
        return -1
    }

Παραπάνω, δηλώνεται μια διεπαφή γενικού προγραμματισμού, όπου T είναι ο τύπος της τιμής 
που πρέπει να περάσει σε μια μέθοδο τύπου, με το όνομα match. Η διεπαφή, επιπλέον, περιορίζει
την χρήση της σε τιμές των τύπων person και food, οι οποίοι είναι ορισμένοι από τον χρήστη.

Όταν παρατηρήσει κανείς την συνάρτηση match θα δει, ότι δεν υπάρχει κάποιος εμφανής 
λόγος, προκειμένου να περιοριστεί η συνάρτηση μόνο σε τύπους person και food. Αν 
πράγματι είναι έτσι, τότε η συνάρτηση match θα έπρεπε να είναι μια παραδοσιακά 
πολυμορφική συνάρτηση και όχι μια συνάρτηση γενικού προγραμματισμού. Αν, από την 
άλλη, υπάρχει πραγματικός λόγος, είναι δυνατόν να χρησιμοποιηθεί μια συνάρτηση γενικού
προγραμματισμού, προκειμένου να εφαρμοστεί αυτό το είδος περιορισμού.

Παρενθετικά, δεν είναι εμφανές αν αυτή η λειτουργικότητα είναι αναγκαία ή αν πράγματι έχει
νόημα. Πρόκειται για κάτι, για το οποίο, η ίδια η κοινότητα της Go θα πρέπει να το διασαφηνίσει, 
με το πέρας του χρόνου.

* Ασκήσεις 

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

Υλοποιήστε μια συνάρτηση γενικού προγραμματισμού με το όνομα copyfy, η οποία είναι περιορισμένη στο να
κάνει μόνο αντίγραφα από φέτες τύπου συμβολοσειράς ή ακεραίων.

.play generics/type-constraints/exercise1.go 
.play generics/type-constraints/answer1.go
