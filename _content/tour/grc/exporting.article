Εξαγωγή Αναγνωριστικών
Η εξαγωγή αναγνωριστικών παρέχει την δυνατότητα να δηλώσει κανείς αν ένα αναγνωριστικό είναι προσβάσιμο σε κώδικα εκτός του πακέτου στο οποίο είναι δηλωμένο. 

* Εξαγωγή Αναγνωριστικών

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιείστε το σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Η εξαγωγή αναγνωριστικών παρέχει την δυνατότητα να δηλώσει κανείς αν ένα
αναγνωριστικό είναι προσβάσιμο σε κώδικα εκτός του πακέτου στο οποίο 
είναι δηλωμένο. 

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1:* Δηλώνοντας και αποκτώντας πρόσβαση σε εξαγόμενα αναγνωριστικά
- *Παράδειγμα* *2:* Δηλώνοντας αναγνωριστικά που δεν εξάγονται και περιορισμοί
- *Παράδειγμα* *3:* Πρόσβαση σε τιμές αναγνωριστικών που δεν εξάγονται 
- *Παράδειγμα* *4:* Πεδία τύπων struct που δεν εξάγονται
- *Παράδειγμα* *5:* Ενσωματωμένοι τύποι που δεν εξάγονται

.play exporting/example1.go
.play exporting/example2.go
.play exporting/example3.go
.play exporting/example4.go
.play exporting/example5.go

** Μηχανισμός Εξαγωγής Αναγνωριστικών

Ένα πακέτο είναι η βασική μονάδα μεταγλωττισμένου κώδικα στην Go. Αντιπροσωπεύει μια 
φυσική μεταγλωττισμένη μονάδα κώδικα, συνήθως ως μια μεταγλωττισμένη βιβλιοθήκη στο 
λειτουργικό σύστημα που τη φιλοξενεί. Η εξαγωγή αναγνωριστικών καθορίζει την πρόσβαση 
σε αναγνωριστικά κατά μήκους των ορίων των διάφορων πακέτων. 

    package counters

    type AlertCounter int

Στην παραπάνω περίπτωση, επειδή χρησιμοποιείται ένα κεφαλαίο γράμμα για την 
ονομασία του τύπου AlterCounter, ο τύπος αυτός είναι εξαγόμενος και μπορεί να 
γίνει αναφορά σε αυτόν άμεσα, από κώδικα που βρίσκεται εκτός του πακέτου 
counters.

    package counters

    type alertCounter int

Τώρα, μετά την αλλαγή του ονόματος του τύπου, ώστε να ξεκινάει με μικρό γράμμα,
ο τύπος μετατρέπεται σε μη εξαγόμενο τύπο. Αυτό σημαίνει ότι, μόνο κώδικας 
εντός του πακέτου counters μπορεί να έχει πρόσβαση σε αυτόν τον τύπο, απευθείας.

    package counters

    type alertCounter int

    func New(value int) alertCounter {
        return alertCounter(value)
    }

Μολονότι ο κώδικας παραπάνω έχει νόμιμη σύνταξη και μπορεί να μεταγλωττιστεί,
δεν υπάρχει κανένας λόγος να το κάνει κανείς αυτό. Η επιστροφή μιας τιμής ενός 
τύπου που, δεν εξάγεται, είναι δυσνόητη καθώς ο καλών (ο οποίος, κατά πάσα πιθανότητα, 
θα βρίσκεται σε ένα διαφορετικό πακέτο) δεν μπορεί να κάνει άμεση αναφορά στο όνομα 
του τύπου.

    package main

    import (
        "fmt"

        "github.com/ardanlabs/.../exporting/example3/counters"
    )

    func main() {
        counter := counters.New(10)
        fmt.Printf("Counter: %d\n", counter)
    }

Στην παραπάνω περίπτωση, η συνάρτηση main, στο πακέτο main, καλεί την συνάρτηση 
counters.New επιτυχώς και ο μεταγλωττιστής μπορεί να δηλώσει και να κατασκευάσει
μια μεταβλητή του μη εξαγόμενου τύπου. Αυτό, δεν σημαίνει ότι, πρέπει κανείς να 
το κάνει, ούτε σημαίνει ότι, λαμβάνει κανείς, κανενός είδους προστασία για κάτι 
τέτοιο. Κάτι τέτοιο θα πρέπει να αποφεύγεται και αν η New επιστρέφει μια τιμή, 
θα πρέπει να είναι ενός εξαγόμενου τύπου. 

    package users

    type User struct {
        Name string
        ID   int

        password string
    }

Σχετικά με τα πεδία σε ένα struct, το πρώτο γράμμα δηλώνει αν το πεδίο είναι
προσβάσιμο σε κώδικα εκτός του πακέτου, στο οποίο είναι δηλωμένο. Σε αυτή την 
περίπτωση, τα πεδία Name και ID είναι προσβάσιμα, όμως το πεδίο password δεν 
είναι. Είναι χαρακτηριστικό της συγγραφής κώδικα στην Go, να διαχωρίζει κανείς 
τα εξαγόμενα και τα μη εξαγόμενα πεδία κατ' αυτό τον τρόπο, αν κάτι τέτοιο είναι
εύλογο ή πρακτικό να γίνει. Κανονικά, όλα τα πεδία θα είναι είτε του ενός, είτε 
του άλλου είδους. 

    package users

    type user struct {
        Name string
        ID   int
    }

    type Manager struct {
        Title string
        user
    }

Στο παραπάνω σενάριο, μολονότι ο τύπος user είναι μη εξαγόμενος, έχει δύο εξαγόμενα 
πεδία. Αυτό σημαίνει ότι, όταν ο τύπος user ενσωματώνεται στον εξαγόμενο τύπο Manager, 
τα πεδία του user προάγονται και είναι προσβάσιμα. Είναι κάτι κοινό, να υπάρχουν τύποι
οι οποίοι δεν εξάγονται αλλά έχουν εξαγόμενα πεδία, επειδή το πακέτο αντανάκλασης μπορεί 
να λειτουργήσει μόνο σε εξαγόμενα πεδία. Σε διαφορετική περίπτωση, δεν θα ήταν δυνατόν 
να λειτουργήσουν κομμάτια κώδικα που πραγματοποιούν σειριοποίηση δεδομένων (marshallers).

Το παράδειγμα δημιουργεί μια κακή κατάσταση, όπου κώδικας εκτός του πακέτου users μπορεί 
να κατασκευάσει ένα Manager, όμως επειδή ο ενσωματωμένος τύπος user είναι μη εξαγόμενος, 
τα πεδία γι' αυτούς του τύπους, δεν μπορούν να λάβουν αρχικές τιμές. Κάτι τέτοιο δημιουργεί 
προβλήματα μερικής κατασκευής, τα οποία μπορούν να οδηγήσουν σε σφάλματα. Κανείς, οφείλει να 
είναι συνεπής με τα πεδία που εξάγονται ή που δεν εξάγονται. 

** Σημειώσεις

- Ο κώδικας στην go μεταγλωττίζεται σε πακέτα τα οποία στην συνέχεια συνδέονται μεταξύ τους. 
- Τα αναγνωριστικά εξάγονται (ή παραμένουν χωρίς να εξάγονται) με βάση του αν γίνεται χρήση κεφαλαίων ή μικρών.
- Κανείς, εισάγει πακέτα προκειμένου να έχει πρόσβαση σε εξαγόμενα αναγνωριστικά.
- Κάθε πακέτο μπορεί να χρησιμοποιεί μια τιμή ενός μη εξαγόμενου τύπου, όμως κάτι τέτοιο είναι ενοχλητικό στην χρήση.

** Πρόσθετα Αναγνώσματα

[[https://www.ardanlabs.com/blog/2014/03/exportedunexported-identifiers-in-go.html][EΕξαγόμενα/Μη Εξαγόμενα Αναγνωριστικά στην Go]] - William Kennedy    

* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

*Μέρος* *Α:* Δημιουργείστε ένα πακέτο με το όνομα toy, με ένα μοναδικό εξαγόμενο τύπο 
struct, με το όνομα Toy. Προσθέστε τα εξαγόμενα πεδία Name και Weight. Στην συνέχεια, 
προσθέστε δύο μη εξαγόμενα πεδία, με τα ονόματα onHand και sold. Δηλώστε μια συνάρτηση 
κατασκευής (factory function) με το όνομα New, προκειμένου να δημιουργεί τιμές τύπου 
toy και να αποδέχεται παραμέτρους για τα εξαγόμενα πεδία. Στην συνέχεια δηλώστε μεθόδους 
τύπου που επιστρέφουν και ανανεώνουν τις τιμές των μη εξαγόμενων πεδίων. 

*Μέρος* *Β:* Δημιουργείστε ένα πρόγραμμα που εισάγει το πακέτο toy. Χρησιμοποιείστε την
συνάρτηση New, προκειμένου να δημιουργήσετε μια τιμή τύπου toy. Στην συνέχεια, χρησιμοποιείστε 
τις μεθόδους τύπου, προκειμένου να προσδιορίσετε τις απαριθμήσεις και να παρουσιάσετε τις 
τιμές των πεδίων αυτής της τιμής toy.

.play exporting/exercise1.go
.play exporting/answer1.go
