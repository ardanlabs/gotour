Πίνακες Κατακερματισμού
Ενας πίνακας κατακερματισμού είναι ένα κλασσικό παράδειγμα ενός τύπου συλλογής, ο οποίος μπορεί να εκμεταλλευτεί την δυνατότητα γενικού προγραμματισμού.

* Γενικός Προγραμματισμός - Πίνακες Κατακερματισμού

Ενας πίνακας κατακερματισμού είναι ένα κλασσικό παράδειγμα ενός τύπου συλλογής
ο οποίος μπορεί να εκμεταλλευτεί την δυνατότητα γενικού προγραμματισμού. Η 
παρούσα υλοποίηση γράφτηκε από τον Matt Layher (@mdlayer) σε μια ανάρτηση blog,
που έκανε. Πρόκειται για ένα καλό παράδειγμα, του τι είναι δυνατό με τον
γενικό προγραμματισμό.

** Video

Μπορεί κανείς να παρακολουθήσει την ομιλία του Bill Kennedy, σχετικά με τον Γενικό Προγραμματισμό,
που παρουσιάζει λεπτομερώς όλα τα παραδείγματα αυτής της ενότητας της Επισκόπησης.

.html generics-video.html

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1*: Πίνακας Κατακερματισμού

.play generics/hash-table/example1.go

** Επεξηγήσεις

Αυτός ο κώδικας είναι λίγο πιο περίπλοκος απ' ότι έχει παρουσιαστεί, έως τώρα. 
Πρόκειται για ένα παράδειγμα, του τι πρέπει κανείς να περιμένει να δει, σε 
υλοποιήσεις, στον πραγματικό κόσμο. Σε όλη την παρούσα ενότητα, θα παρουσιαστούν 
δύο εκδοχές του κώδικα. Μια πριν και μια μετά από την εφαρμογή του νέου συντακτικού 
γενικού προγραμματισμού.

    type hashFunc func(key K, buckets int) int

Ο παραπάνω τύπος δηλώνει την υπογραφή μιας συνάρτησης κατακερματισμού, που θα χρησιμοποιηθεί 
από τον πίνακα κατακερματισμού, προκειμένου να υπολογιστεί μια θέση για αποθήκευση και ανάσυρση 
δεδομένων (στμ. bucket). Ο χρήστης πρέπει να υλοποιήσει και να παρέχει αυτή την συνάρτηση, όταν 
κατασκευάζεται ένας πίνακας κατακερματισμού. Η συνάρτηση αποδέχεται ένα κλειδί και τον αριθμό
των θέσεων αποθήκευσης, απο τις οποίες μπορεί να κάνει μια επιλογή. Καθώς ο σκοπός είναι αυτό 
το σύστημα να είναι γενικού προγραμματισμού, σε όρους των τύπων που χρησιμοποιούνται για τα κλειδιά αλλά και
για τις τιμές, δηλώνεται μια παράμετρος τύπου με περιορισμό τύπου, το μοναδικό κεφαλαίο γράμμα K.

Στην συνέχεια, κανείς μπορεί να εφαρμόσει το συντακτικό του γενικού προγραμματισμού, προκειμένου 
να μετατρέψει τον K σε ένα αληθινό τύπο γενικού προγραμματισμού.

    type hashFunc[K comparable] func(key K, buckets int) int <-- ΑΛΛΑΞΕ

Μετά από το όνομα του τύπου, προστίθενται αγκύλες με τον τύπο γενικού προγραμματισμού 
K και τον περιορισμό τύπου comparable, καθώς οι τιμές του τύπου κλειδιού πρέπει να 
χρησιμοποιηθούν σε λειτουργίες σύγκρισης. Η καταγραφή αυτού του χαρακτηριστικού, την 
δεδομένη στιγμή, έχει νόημα, ακόμα και αν η υλοποίηση της συνάρτησης κατακερματισμού, 
δεν το απαιτεί. Η συνέπεια είναι τα πάντα για την ευκολία ανάγνωσης, την κατανόηση και 
την δυνατότητα συντήρησης του κώδικα, με το πέρας του χρόνου.

Ο ακόλουθος τύπος αντιπροσωπεύει ένα ζεύγος δεδομένων κλειδιού/τιμής τα οποία θα αποθηκευτούν 
στον πίνακα κατακερματισμού.

    type keyValuePair struct {
        Key K
        Value V
    }

Η δουλειά αυτού του τύπου είναι να αποθηκεύσει τα πραγματικά δεδομένα, στο αντίστοιχο κλειδί. 
Στην συνέχεια, ο κώδικας δηλώνει ένα πεδίο κλειδιού τύπου K καθώς και ένα πεδίο τιμής τύπου V.

Τώρα είναι δυνατόν κανείς, να εφαρμόσει το συντακτικό γενικού προγραμματισμού, προκειμένου να 
μετατρέψει τους K και V σε έναν πραγματικό γενικό τύπο. 

    type keyValuePair[K comparable, V any] struct { <-- ΑΛΛΑΞΕ
        Key K
        Value V
    }

Μετά το όνομα του τύπου, προστίθενται οι αγκύλες με τους τύπους γενικού προγραμματισμού 
K και V. Σε αυτή την δήλωση, ο K αντιπροσωπεύει το κλειδί, όπως και πριν, ενώ ο V αντιπροσωπεύει 
μια τιμή, η οποία μπορεί να είναι οτιδήποτε.

Ο τύπος παρακάτω, αντιπροσωπεύει έναν πίνακα κατακερματισμού, που διαχειρίζεται τόσο μια συνάρτηση
κατακερματισμού, όσο και ένα σύνολο θέσεων για αποθήκευση δεδομένων με την μορφή κλειδί/τιμή.

    type Table struct {
        hashFunc hashFunc
        buckets int
        data [][]keyValuePair
    }

Ο πίνακας έχει τρια πεδία, μια συνάρτηση κατακερματισμού, τον αριθμό των θέσεων δεδομένων
καθώς και τα δεδομένα, που αναπαρίστανται ως μια φέτα φέτας ζευγών κλειδιού/τιμής. Η 
εξωτερική φέτα αντιπροσωπεύει τις θέσεις αποθήκευσης των δεδομένων, ενώ η εσωτερική φέτα
αντιπροσωπεύει ζεύγη κλειδιού/τιμής, που αποθηκεύονται σε θέσεις δεδομένων.

Στην συνέχεια, εφαρμόζεται το συντακτικό του γενικού προγραμματισμού, προκειμένου να δηλωθούν
οι γενικού τύποι του κλειδιού και της τιμής και να εφαρμοστούν στις δηλώσεις των πεδίων.

    type Table[K comparable, V any] struct { <-- ΑΛΛΑΞΕ
        hashFunc hashFunc[K] <-- ΑΛΛΑΞΕ
        buckets int
        data [][]keyValuePair[K, V] <-- ΑΛΛΑΞΕ
    }

Μετά το όνομα του τύπου, προστίθενται οι αγκύλες με τους τύπους γενικού προγραμματισμού 
K και V. Η δήλωση του τύπου hashFunc απαιτεί πληροφορίες για τον πραγματικό τύπο, που θα
χρησιμοποιηθεί για το κλειδί. Η δήλωση τύπου keyValuePair απαιτεί πληροφορίες για τον
πραγματικό τύπο, τόσο του κλειδιού, όσο και της τιμής.

Παρακάτω, παρουσιάζεται μια συνάρτηση παραγωγής (στμ. factory) η οποία είναι σε θέση να δημιουργήσει
έναν Table, έτοιμο προς χρήση.

    func New(
        buckets int,
        hf hashFunc
    ) *Table {
        
        return &Table{
            hashFunc: hf,
            buckets: buckets,
            data: make([][]keyValuePair, buckets),
        }
    }

Η συνάρτηση παραγωγής αποδέχεται το πλήθος των θέσεων δεδομένων, που πρέπει να διαχειριστεί
καθώς και μια συνάρτηση κατακερματισμού, προκειμένου να επιλέγεται η κατάλληλη θέση, για την 
αποθήκευση δεδομένων καθώς και για τις αναζητήσεις. Όταν δημιουργείται μια τιμή Table, το 
πλήθος των διαθέσιμων θέσεων δεδομένων χρησιμοποιείται, προκειμένου να κατασκευαστεί η φέτα,
θέτοντας το μήκος της εξωτερικής φέτας ίσο με το πλήθος των θέσεων που πρόκειται να χρησιμοποιηθούν.

Παρακάτω, εφαρμόζεται το συντακτικό γενικού προγραμματισμού, προκειμένου να δηλωθούν οι τύποι
γενικού προγραμματισμού για το κλειδί και την τιμή και να εφαρμοστούν στους τύπους που πρέπει
να κατασκευαστούν.

    func New[K comparable, V any]( <-- ΑΛΛΑΞΕ
        buckets int,
        hf hashFunc[K],            <-- ΑΛΛΑΞΕ
    ) *Table[K, V] {               <-- ΑΛΛΑΞΕ
        
        return &Table[K, V]{       <-- ΑΛΛΑΞΕ
            hashFunc: hf,
            buckets: buckets,
            data: make([][]keyValuePair[K, V], buckets), <-- ΑΛΛΑΞΕ
        }
    }

Μετά από το όνομα του τύπου, προστίθενται αγκύλες και οι τύποι γενικού προγραμματισμού
K και V. Στην συνέχεια, ο τύπος K εφαρμόζεται στην παράμετρο εισόδου hf, προκειμένου
να ολοκληρωθεί η δήλωση τύπου hashFunc. Οι τύποι K και V εφαρμόζονται στον τύπο Table, 
που είναι προς κατασκευή και πρόκειται να επιστραφεί. Τέλος, η ανάθεση τιμής στο πεδίο 
δεδομένων, απαιτεί τόσο τον K όσο και τον V να εφαρμοστούν στο συντακτικό δημιουργίας 
για τον τύπο keyValuePair.

Παρακάτω, παρουσιάζεται μια μέθοδος με την οποία μπορεί κανείς να προσθέσει τιμές στον 
πίνακα κατακερματισμού, με βάση συγκεκριμένο κλειδί.

    type Table[K comparable, V any] struct {
        hashFunc hashFunc[K]
        buckets int
        table [][]keyValuePair[K, V]
    }

    func (t *Table) Insert(key K, value V) {
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.table[bucket] {
            if key == kvp.Key {
                t.table[bucket][idx].Value = value
                return
            }
        }

        kvp := keyValuePair{
            Key: key,
            Value: value,
        }
        t.table[bucket] = append(t.table[bucket], kvp)
    }

Η μέθοδος τύπου Insert δηλώνεται, ώστε να να δέχεται ένα κλειδί και μια τιμή, με τους 
ίδιους τύπους γενικού προγραμματισμού, που δηλώθηκαν μαζί με τον τύπο του Table. Το
πρώτο βήμα στην διαδικασία της εισαγωγής είναι ο προσδιορισμός της κατάλληλης θέσης, 
που θα χρησιμοποιηθεί για αποθήκευση. Αυτό πραγματοποιείται με την κλήση της συνάρτησης 
κατακερματισμού, με το συγκεκριμένο κλειδί. Η συνάρτηση κατακερματισμού επιστρέφει μια 
ακέραια τιμή, που αντιπροσωπεύει ποια θα είναι η θέση δεδομένων προς χρήση.

Στην συνέχεια, η συνάρτηση ελέγχει αν το συγκεκριμένο κλειδί έχει ήδη χρησιμοποιηθεί, 
προκειμένου να αποθηκευτεί μια τιμή στην επιλεγμένη θέση δεδομένων. Αυτός ο έλεγχος
πραγματοποιείται διατρέχοντας τα διαθέσιμα ζεύγη κλειδιού/τιμής, στην δεδομένη θέση
αποθήκευσης. Αν το κλειδί υπάρχει ήδη, τότε η τιμή του ζεύγους, που αντιστοιχεί στο
δεδομένο κλειδί, ανανεώνεται με την τρέχουσα. Αν το κλειδί δεν βρεθεί κατά την αναζήτηση, τότε 
δημιουργείται ένα καινούργιο ζεύγος κλειδιού/τιμής, λαμβάνει αρχική τιμή και προστίθεται
στην φέτα, στην επιλεγμένη θέση αποθήκευσης. 

Παρακάτω, εφαρμόζεται το συντακτικό γενικού προγραμματισμού, προκειμένου να δηλωθούν οι τύποι 
γενικού προγραμματισμού για το κλειδί και την τιμή, ενώ στην συνέχεια, εφαρμόζονται στους τύπους
που πρέπει να κατασκευαστούν.

    func (t *Table[K, V]) Insert(key K, value V) { <-- ΑΛΛΑΞΕ
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.table[bucket] {
            if key == kvp.Key {
                t.table[bucket][idx].Value = value
                return
            }
        }
    
        kvp := keyValuePair[K, V]{                 <-- ΑΛΛΑΞΕ
            Key: key,
            Value: value,
        }
        t.table[bucket] = append(t.table[bucket], kvp)
    }

Μετά το όνομα τύπου στον λήπτη μεθόδου κανείς, πρέπει να προσθέσει αγκύλες καθώς και 
τους τύπους γενικού προγραμματισμού K και V. Η μόνη άλλη αλλαγή που πρέπει να γίνει, είναι
η εφαρμογή των K και V στην σύνταξη κατασκευής του τύπου keyValuePair.

Παρακάτω, παρουσιάζεται μια μέθοδος τύπου, η οποία μπορεί να ανακτήσει τιμές από τον πίνακα
κατακερματισμού, κάνοντας χρήση συγκεκριμένου κλειδιού. 

    func (t *Table) Retrieve(key K) (V, bool) {
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.data[bucket] {
            if key == kvp.Key {
                return t.data[bucket][idx].Value, true
            }
        }
    
        var zero V
        return zero, false
    }

Η μέθοδος Retrieve δηλώνεται έτσι ώστε να δέχεται ένα κλειδί και να επιστρέφει ένα 
αντίγραφο της αποθηκευμένης τιμής, που αντιστοιχεί σε αυτό το κλειδί. Το πρώτο βήμα 
προκειμένου να γίνει η ανάκτηση, είναι ο προσδιορισμός τη θέση αποθήκευσης, η οποία έχει
χρησιμοποιηθεί. Αυτό πραγματοποιείται με μια κλήση στην συνάρτηση κατακερματισμού,
με το συγκεκριμένο κλειδί. Η συνάρτηση κατακερματισμού επιστρέφει μια ακέραια τιμή, 
η οποία αντιστοιχεί στην θέση αποθήκευσης που πρέπει να κοιτάξει κανείς.

Στην συνέχεια, η συνάρτηση διατρέχει την συλλογή από ζεύγη κλειδιών/τιμών, που διατηρεί 
στο εσωτερικό της θέσης αποθήκευσης ένα προς ένα, αναζητώντας το συγκεκριμένο κλειδί. 
Αν το κλειδί βρεθεί κατά την αναζήτηση, επιστρέφεται ένα αντίγραφο της τιμής, καθώς και 
η τιμή true στον καλώντα. Αν το κλειδί δεν βρεθεί, επιστρέφεται η μηδενική τιμή, καθώς και
false στον καλώντα.

Στην συνέχεια, εφαρμόζεται η σύνταξη γενικού προγραμματισμού, προκειμένου να δηλωθούν οι τύποι
γενικού προγραμματισμού για τα κλειδιά και τις τιμές και εφαρμόζονται στους τύπους, που πρέπει
να κατασκευαστούν.

    func (t *Table[K, V]) Get(key K) (V, bool) { <-- ΑΛΛΑΞΕ
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.data[bucket] {
            if key == kvp.Key {
                return t.data[bucket][idx].Value, true
            }
        }
    
        var zero V
        return zero, false
    }

Μετά το όνομα του τύπου στον δέκτη μεθόδου, προστίθενται αγκύλες και οι τύποι γενικού προγραμματισμού
K και V. Δεν απαιτούνται άλλες αλλαγές στον κώδικα. 

Παρακάτω, ακολουθεί ένα μικρό πρόγραμμα, που ελέγχει την υλοποίηση του πίνακα κατακερματισμού. 

    func main() {
        const buckets = 8
        . . .
    }

Ξεκινάει κανείς με μια σταθερά, η οποία ορίζει το πλήθος των θέσεων αποθήκευσης προς χρήση στον
πίνακα κατακερματισμού.

    import (
        "hash/fnv"
    )
    
    func main() {
        . . .
        
        hashFunc1 := func(key string, buckets int) int {
            h := fnv.New32()
            h.Write([]byte(key))
            return int(h.Sum32()) % buckets
        }

        . . .
    }

Στην συνέχεια, δηλώνεται η συνάρτηση κατακερματισμού, η οποία δηλώνει, με την σειρά 
της, μια συμβολοσειρά ως κλειδί. Η υλοποίηση χρησιμοποιεί το πακέτο fnv, από την 
βασική βιβλιοθήκη, το οποίο υλοποιεί τις μη κρυπτογραφικές συναρτήσεις FNV-1 και FNV-1a, 
που δημιουργήθηκαν από τον Glenn Fowler, τον Landon Curt Noll, και τον Phong Vo. Το 
FNV σημαίνει συνάρτηση κατακερματισμού των Fowler-Noll-Vo.

Εφαρμόζοντας τον τελεστή ακέραιου υπολοίπου (στμ. modulus) στην τιμή της θέσης αποθήκευσης, αναγκάζεται
έτσι η τελική τιμή να βρίσκεται εντός του εύρους των διαθέσιμων θέσεων αποθήκευσης.

    import (
        "hash/fnv"
    )
    
    func main() {
        . . .
        
        table1 := New[/*key*/ string, /*value*/ int](buckets, hashFunc1)
        
        . . .
    }

Στην συνέχεια, δημιουργείται ένας πίνακας κατακερματισμού, δηλώνοντας ρητά ότι το 
κλειδί θα είναι τύπου συμβολοσειράς και η τιμή τύπου ακεραίου. Δεν υπάρχει τίποτα 
στις παραμέτρους εισόδου, που να διευκολύνει τον μεταγλωττιστή, να συνάγει αυτές τις
πληροφορίες.

Προκειμένου να παρουσιαστεί η φύση γενικού προγραμματισμού του πίνακα κατακερματισμού, 
παρακάτω ορίζεται μια δεύτερη συνάρτηση και ένας δεύτερος πίνακας κατακερματισμού.

    import (
        "hash/fnv"
    )
    
    func main() {
        . . .
    
        hashFunc2 := func(key int, buckets int) int {
            return key % buckets
        }

        table2 := New[/*key*/ int, /*value*/ string](buckets, hashFunc2)
    
        . . .
    }

Αυτή η συνάρτηση κατακερματισμού, δηλώνει έναν ακέραιο για το κλειδί και πραγματοποιεί
μια απλή πράξη υπολοίπου με την τιμή της θέσης αποθήκευσης και την τιμή του κλειδιού. 
Στην συνέχεια κατασκευάζεται ένας νέος πίνακας, όπου προσδιορίζεται ότι το κλειδί θα είναι
ακέραιος και η τιμή συμβολοσειρά. Πρόκειται για την αντίστροφη διάταξη, από αυτή του πρώτου
πίνακα.


    import (
        "hash/fnv"
    )
    
    func main() {
        . . .
    
        words := []string{"foo", "bar", "baz"}
        for i, word := range words {
            table1.Insert(word, i)
            table2.Insert(i, word)
        }
    
        for i, s := range append(words, "nope!") {
            v1, ok1 := table1.Retrieve(s)
            fmt.Printf("t1.Rtr(%v) = (%v, %v)\n", s, v1, ok1)
            
            v2, ok2 := table2.Retrieve(i)
            fmt.Printf("t2.Rtr(%v) = (%v, %v)\n", i, v2, ok2)
        }
    }

Αποτέλεσμα:

    t1.Rtr(foo) = (0, true)
    t2.Rtr(0) = (foo, true)
    t1.Rtr(bar) = (1, true)
    t2.Rtr(1) = (bar, true)
    t1.Rtr(baz) = (2, true)
    t2.Rtr(2) = (baz, true)
    t1.Rtr(nope!) = (0, false)
    t2.Rtr(3) = (, false)

Τέλος, ο παραπάνω κώδικας αποθηκεύει και ανασύρει τιμές, από τους δύο αντίστοιχους πίνακες.