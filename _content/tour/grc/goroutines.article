Ρουτίνες συνεκτέλεσης της Go
Οι ρουτίνες συνεκτέλεσης της Go είναι συναρτήσεις που δημιουργούνται και προγραμματίζονται να εκτελεστούν ανεξάρτητα, από τον χρονοδρομολογητή της Go.

* Ρουτίνες συνεκτέλεσης της Go

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιήστε το Σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Οι ρουτίνες συνεκτέλεσης της Go (στμ. Goroutines) είναι συναρτήσεις που δημιουργούνται και προγραμματίζονται να εκτελεστούν 
ανεξάρτητα, από τον χρονοδρομολογητή (στμ. scheduler) της Go. Ο χρονοδρομολογητής της Go είναι
υπεύθυνος για την διαχείριση και την εκτέλεση των goroutines.

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1:* Οι Ρουτίνες Συνεκτέλεσης της Go και η Ταυτόχρονη Εκτέλεση
- *Παράδειγμα* *2:* Αλλαγή Περιβάλλοντος Λειτουργίας Ρουτίνας Συνεκτέλεσης της Go 
- *Παράδειγμα* *3:* Οι Ρουτίνες Συνεκτέλεσης της Go και ο Παραλληλισμός

.play goroutines/example1.go
.play goroutines/example2.go
.play goroutines/example3.go

** Σημειολογία Χρονοδρομολογητή

Όταν ένα πρόγραμμα της Go ξεκινάει, το εκτελέσιμο περιβάλλον της Go ζητάει από την μηχανή 
(εικονική ή πραγματική) τον αριθμό των νημάτων εκτέλεσης του λειτουργικού συστήματος, 
που μπορούν να εκτελεστούν παράλληλα. Αυτός ο αριθμός εξαρτάται από τον αριθμό των πυρήνων 
επεξεργαστή, που είναι διαθέσιμοι στο πρόγραμμα. Για κάθε διαθέσιμο νήμα εκτέλεσης που μπορεί
να εκτελεστεί παράλληλα, το εκτελέσιμο περιβάλλον δημιουργεί ένα νήμα του λειτουργικού 
συστήματος (M) και το συνδέει σε μια δομή δομή δεδομένων, που αντιπροσωπεύει έναν λογικό 
επεξεργαστή (P) εντός του προγράμματος. Αυτά τα P και M αποτελούν την υπολογιστική ισχύ 
ή το πλαίσιο εκτέλεσης για την εκτέλεση του προγράμματος της Go.

Επίσης, δημιουργείται μια αρχική ρουτίνα συνεκτέλεσης της Go (G) προκειμένου να διαχειριστεί την εκτέλεση οδηγιών σε 
επιλεγμένα M/P. Όπως ακριβώς ένα M διαχειρίζεται την εκτέλεση λειτουργιών στο υλικό,
μια G διαχειρίζεται την εκτέλεση οδηγιών στο M. Κατ' αυτόν τον τρόπο δημιουργείται ένα 
καινούργιο επίπεδο αφαίρεσης επάνω από το λειτουργικό σύστημα, όμως ο έλεγχος εκτέλεσης 
περνάει στο επίπεδο της εφαρμογής.

.image /tour/grc/static/img/gor1.png

Καθώς ο χρονοδρομολογητής της Go είναι τοποθετημένος πάνω από τον χρονοδρομολογητή του 
λειτουργικού συστήματος, είναι σημαντικό να υπάρχει κάποια σημειολογική κατανόηση του 
χρονοδρομολογητή του λειτουργικού συστήματος και των περιορισμών που επιβάλλει στον 
χρονοδρομολογητή της Go και στις εφαρμογές της.

Ο χρονοδρομολογητής του λειτουργικού συστήματος είναι επιφορτισμένος με το καθήκον να
δημιουργεί την ψευδαίσθηση ότι πολλαπλές εργασίες εκτελούνται την ίδια στιγμή. Ακόμα 
και όταν αυτό είναι πραγματικά αδύνατο. Κάτι τέτοιο απαιτεί κάποιους συμβιβασμούς στον
σχεδιασμό του χρονοδρομολογητή. Πρωτού γίνει πιο διεξοδική αναφορά, είναι σημαντικό να 
δωθούν οι ορισμοί μερικών εννοιών.

*Εργασία:* Ένα σύνολο οδηγιών προς εκτέλεση για μια εκτελούμενη εφαρμογή. Αυτό επιτυγχάνεται 
με την χρήση νημάτων εκτέλεσης και μια εφαρμογή μπορεί να έχει 1 ή περισσότερα νήματα εκτέλεσης.

*Νήμα* *Eκτέλεσης:* Μια πορεία εκτέλεσης η οποία προγραμματίζεται και εκτελείται. Τα νήματα 
εκτέλεσης είναι υπεύθυνα για την εκτέλεση των οδηγιών από το υλικό. 

*Καταστάσεις* *Νημάτων* *Εκτέλεσης:* Ένα νήμα εκτέλεσης μπορεί να βρίσκεται σε 
μια από τις ακόλουθες τρεις καταστάσεις: Εκτελείται, Προς Εκτέλεση ή Σε Αναμονή. 
Όταν ένα νήμα εκτέλεσης βρίσκεται σε κατάσταση εκτέλεσης, κάτι τέτοιο σημαίνει ότι
εκτελεί τις οδηγίες που του έχουν εκχωρηθεί στο υλικό, έχοντας μια G τοποθετημένη σε 
ένα M. Η κατάσταση "προς εκτέλεση" σημαίνει ότι το νήμα εκτέλεσης θέλει να αποκτήσει
χρόνο στο υλικό, προκειμένου να εκτελέσει τις οδηγίες που του έχουν ανατεθεί ενώ 
βρίσκεται σε μια ουρά προς εκτέλεση. Η κατάσταση "σε αναμονή" σημαίνει ότι το νήμα 
εκτέλεσης περιμένει κάτι πριν να είναι σε θέση να συνεχίσει τις εργασίες του. Τα νήματα
σε αυτή την κατάσταση δεν αποτελούν μέλημα του χρονοδρομολογητή.

*Ταυτόχρονη* *Εκτέλεση:* Αυτός ο όρος σημαίνει την απροσδιόριστη εκτέλεση εκτός προδιαγεγραμένης 
σειράς. Με άλλα λόγια, ένα σύνολο οδηγιών, που διαφορετικά θα εκτελούνταν με την σειρά στην 
οποία εμφανίζονται, τελικά εκτελείται με μια απροσδιόριστη διαφορετική σειρά, όμως 
εκτελείται το σύνολο των οδηγιών. Το σημαντικό σε αυτό είναι, ότι το αποτέλεσμα της εκτέλεσης 
ολόκληρου του συνόλου των οδηγιών σε μια απροσδιόριστη σειρά, παράγει το ίδιο αποτέλεσμα. Κανείς,
χρησιμοποιεί τον όρο, ότι είναι δυνατόν να πραγματοποιηθεί μια εργασία με ταυτόχρονη εκτέλεση, όταν
η σειρά με την οποία εκτελείται η εργασία δεν έχει σημασία, εφόσον είναι δυνατόν να ολοκληρωθεί στο
σύνολό της.

*Παράλληλη* *Εκτέλεση:* Αυτός ο όρος σημαίνει, κάνοντας πολλά πράγματα ταυτόχρονα. Προκειμένου κάτι τέτοιο 
να αποτελεί εφικτή επιλογή, χρειάζεται να υπάρχει η δυνατότητα να εκτελεστούν δύο ή περισσότερα 
νήματα του λειτουργικού συστήματος, ταυτόχρονα, στο υλικό.

*Εργασία* *Προορισμένη* *για* *την* *CPU:* Πρόκειται για κάποια εργασία η οποία δεν προκαλεί το
νήμα εκτέλεσης να μεταβεί με φυσικό τρόπο σε κατάσταση αναμονής. Ο υπολογισμός των αριθμών 
fibonacci μπορεί να θεωρηθεί ως Εργασία Προορισμένη για την CPU. 

*Εργασία* *Προορισμένη* *για* *την* *I/O:* Πρόκειται για κάποια εργασία η οποία προκαλεί το 
νήμα εκτέλεσης να μεταβεί με φυσικό τρόπο σε κατάσταση αναμονής. Η συλλογή δεδομένων απο 
διαφορετικά URL μπορεί να θεωρηθεί ως Εργασία Προορισμένη για την I/O.

*Συγχρονισμός:* Όταν δύο ή περισσότερες Goroutines θα χρειαστούν να έχουν πρόσβαση 
στην ίδια περιοχή μνήμης, πιθανόν την ίδια στιγμή, θα πρέπει να συγχρονιστούν και να 
περιμένει η κάθε μια την σειρά της. Αν δεν συμβεί αυτός ο συγχρονισμός, και υπάρχει 
τουλάχιστον μια Goroutine που πραγματοποιεί μια εγγραφή, είναι δυνατόν να προκύψει 
διαμάχη για δεδομένα (στμ. data race). Οι διαμάχες για δεδομένα αποτελούν αιτία προβλημάτων 
διαφθοράς των δεδομένων, τα οποία μπορεί να είναι δύσκολο να εντοπιστούν.

*Ενορχήστρωση:* Όταν δύο ή περισσότερες ρουτίνες συνεκτέλεσης της Go χρειάζεται να ενημερώσουν η 
μια την άλλη, με ή χωρίς την χρήση δεδομένων ότι, απαιτείται ενορχήστρωση. Αν δεν 
συμβεί η ενορχήστρωση, οι εγγυήσεις σχετικά με την ταυτόχρονη εκτέλεση και την 
διεξαγωγή εργασιών καθώς και την ολοκλήρωσή τους, θα απολεσθούν. Εαν συμβεί κάτι 
τέτοιο, είναι δυνατόν να προκληθούν όλων των ειδών τα προβλήματα διαφθοράς δεδομένων.

Υπάρχουν πολλές μικρές λεπτομέρειες που σχετίζονται με την σημειολογία της χρονοδρομολόγησης  
επομένως, προκειμένου να μάθει κανείς περισσότερα, μπορεί να διαβάσει τα τρία post στο 
κεφάλαιο 14 με τίτλο, Η Χρονοδρομολόγηση στην Go.

** Βασικές Έννοιες Ταυτόχρονη Εκτέλεσης 

Ξεκινώντας με ένα βασικό πρόβλημα ταυτόχρονης εκτέλεσης (στμ. concurrency) που απαιτεί 
ενορχήστρωση.

    func init() {
        runtime.GOMAXPROCS(1)
    }

Η κλήση στην GOMAXPROCS γίνεται, προκειμένου να εκτελεστεί το πρόγραμμα της Go, ως ένα 
πρόγραμμα της Go που εκτελείται σε ένα μοναδικό νήμα εκτέλεσης. Αυτό το πρόγραμμα θα 
έχει ένα μοναδικό νήμα εκτέλεσης και θα έχει ένα μοναδικό P/M προκειμένου να εκτελεστούν 
όλες οι ρουτίνες συνεκτέλεσης της Go. Η συνάρτηση είναι με κεφαλαία, επειδή είναι ταυτόχρονα και μια 
μεταβλητή περιβάλλοντος. Όμως, η κλήση της συνάρτησης θα αντικαταστήσει την τιμή της μεταβλητής.

    g := runtime.GOMAXPROCS(0)

Αυτή η συνάρτηση είναι σημαντική όταν κανείς θέλει να ορίσει όρια για την χρήση CPU
στην διαμόρφωση ενός container. Όταν περνάει κανείς το 0, η συνάρτηση αναφέρει τον
αριθμό των νημάτων εκτέλεσης που θα χρησιμοποιεί το πρόγραμμα Go. Κανείς, πρέπει να 
επιβεβαιώσει ότι αυτός ο αριθμός, ταιριάζει με τον αριθμό των νημάτων εκτέλεσης του
λειτουργικού συστήματος, που είναι διαθέσιμα στο περιβάλλον του container. Αν οι αριθμοί 
δεν ταιριάζουν, το πρόγραμμα της Go δεν θα εκτελεστεί τόσο καλά, όσο θα μπορούσε.  
Μπορεί κανείς να χρειαστεί να χρησιμοποιήσει την μεταβλητή περιβάλλοντος ή την αντίστοιχη κλήση
συνάρτησης, προκειμένου να διαβεβαιωθεί ότι οι σχετικοί αριθμοί ταιριάζουν. 

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        fmt.Println("Waiting To Finish")
        wg.Wait()

        fmt.Println("\nTerminating Program")
    }

Το παραπάνω πρόγραμμα πρέπει να λύσει ένα πρόβλημα ενορχήστρωσης. Η κύρια ρουτίνα συνεκτέλεσης της Go  
δεν μπορεί να επιτρέψει στην συνάρτηση main να επιστρέψει, μέχρι να υπάρξει εγγύηση, 
ότι οι δύο Goroutines που δημιουργήθηκαν, ολοκλήρωσαν την εργασία τους. Ένα WaitGroup 
είναι ένα τέλειο εργαλείο για την αντιμετώπιση προβλημάτων ενορχήστρωσης, που δεν απαιτούν 
ανταλλαγή δεδομένων μεταξύ Goroutines. Η σηματοδότηση, σε αυτή την περίπτωση, πραγματοποιείται 
μέσω ενός API, το οποίο επιτρέπει σε μια ρουτίνα συνεκτέλεσης της Go να περιμένει άλλες ρουτίνες
συνεκτέλεσης της Go να σηματοδοτήσουν το πέρας των εργασιών τους. 

Σε αυτόν τον κώδικα, δημιουργείται ένα WaitGroup στην κατάσταση μηδενικής τιμής και 
στην συνέχεια καλείται η μέθοδος τύπου Add, προκειμένου να θέσει το WaitGroup ίσο με 2, 
κάτι που ταιριάζει με τον αριθμό των ρουτίνων συνεκτέλεσης της Go που θα δημιουργηθούν. Όταν κανείς γνωρίζει 
προκαταβολικά τον αριθμό των ρουτίνων συνεκτέλεσης της Go που θα δημιουργηθούν, μπορεί να καλέσει την Add
μια φορά, με αυτό τον αριθμό. Όταν αυτός ο αριθμός δεν είναι γνωστός (όπως συμβαίνει σε μια
υπηρεσία streaming) τότε είναι αποδεκτή η κλήση Add(1) για κάθε καινούργια ρουτίνα συνεκτέλεσης της Go.

Στο τέλος της main, είναι η κλήση στην Wait. Η Wait αποτρέπει την κύρια ρουτίνα συνεκτέλεσης της Go απ' 
το να αναγκάσει την συνάρτηση να επιστρέψει. Όταν επιστρέφει η συνάρτηση main, το πρόγραμμα 
της Go σταματάει, με μεγάλη προσοχή. Αυτός είναι ο λόγος, που είναι σημαντικό, να γίνεται ορθή διαχείριση  
της ενορχήστρωσης με κατάλληλες εγγυήσεις. Η κληση στην Wait θα εμποδίσει τον τερματισμό, έως ότου 
το WaitGroup πάρει πάλι την τιμή 0.

Στην μέση του προγράμματος γίνεται η δημιουργία των δύο ρουτίνων συνεκτέλεσης της Go.

    func main() {
        . . .

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        . . .
    }

Ρητές συναρτήσεις δηλώνονται και εκτελούνται με την χρήση της λέξης-κλειδί go. Σε αυτό
το σημείο, ο χρονοδρομολογητής ενημερώνεται ότι, πρέπει να εκτελέσει αυτές τις συναρτήσεις 
ταυτόχρονα. Να τις εκτελέσει σε μια μη καθορισμένη σειρά εκτέλεσης. Μέσα στην υλοποίηση της 
κάθε ρουτίνας συνεκτέλεσης της Go, είναι η κλήση στην Done. Αυτή η κλήση μειώνει την τιμή της WaitGroup κατά 1. 
Όταν πραγματοποιηθούν και οι δύο κλήσεις στην Done, η τιμή του WaitGroup θα έχει αλλάξει 
από 2 σε 0 και η κύρια ρουτίνα συνεκτέλεσης της Go θα μπορέσει να αποδεσμευτεί από την κλήση στην Wait, 
διακόπτοντας έτσι την εκτέλεση του προγράμματος 

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            wg.Done()
        }()

        . . .
    }

Ενα σημαντικό κομμάτι του πρότυπου ενορχήστρωσης, που χρησιμοποιειται παραπάνω, είναι η διατήρηση των 
κλήσεων στην Add και στην Done, στο ίδιο ευδιάκριτο σημείο. Δεν πρέπει να περνάει η WaitGroup σαν μια 
παράμετρος συνάρτησης όπου χάνεται η κληση. Αυτά θα βοηθήσουν στην μείωση των προβλημάτων του προγράμματος. 

Αποτέλεσμα:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    Terminating Program

Όταν κανείς δημιουργήσει και εκτελέσει αυτό το πρόγραμμα, μπορεί να παρατηρήσει 
πως εκτελείται ταυτόχρονα. Η δεύτερη ρουτίνα συνεκτέλεσης της Go κατά σειρά δημιουργίας, προγραμματίστηκε 
από τον χρονοδρομολογητή να εκτελεστεί πρώτη. Μπόρεσε να εκτελέσει το σύνολο των 
εργασιών της και στην συνέχεια εκτελέστηκε η άλλη ρουτίνα συνεκτέλεσης της Go. Και οι δύο εκτελέστηκαν 
έως ότου ολοκλήρωσαν τις εργασίες τους και στην συνέχεια το πρόγραμμα τερματίστηκε.
Την επόμενη φορά που θα εκτελεστεί αυτό το πρόγραμμα, δεν υπάρχει καμία εγγύηση ότι θα 
παρατηρήσει κανείς το ίδιο αποτέλεσμα. Η μόνη εγγύηση σε αυτό το πρόγραμμα είναι 
ότι, το πρόγραμμα δεν θα τερματιστεί, πρωτού ολοκληρώσουν οι δύο ρουτίνες συνεκτέλεσης της Go.

Ακόμα και αν εκτελεστεί αυτό το πρόγραμμα 100 φορές και παρατηρήσει κανείς το ίδιο αποτέλεσμα, 
δεν υπάρχει καμία εγγύηση ότι κάτι τέτοιο θα συμβεί ξανά. Μπορεί κάτι τέτοιο να είναι εξαιρετικά 
πιθανό, παρόλα αυτά όμως δεν είναι εγγυημένο ότι θα συμβεί κατ' αυτό τον τρόπο. Ειδικότερα, 
δεν υπάρχει καμία εγγύηση για διαφορετικές εκδόσεις, λειτουργικά συστήματα και αρχιτεκτονικές υλικού. 

    func main() {
        . . .

        fmt.Println("Waiting To Finish")
        // wg.Wait()                           <-- ΑΛΛΑΞΕ

        fmt.Println("\nTerminating Program")
    }

Αν κανείς μετατρέψει σε σχόλιο κώδικα την κλήση στην Wait, τι αναμένεται να συμβεί όταν ξανατρέξει αυτό
το πρόγραμμα; Για άλλη μια φορά, δεν υπάρχει καμία εγγύηση απολύτως για το τι πρόκειται να συμβεί, όμως 
υπάρχουν διαφορετικά ενδεχόμενα.

Το πρόγραμμα θα μπορούσε να συμπεριφερθεί όπως πριν, καθώς οι κλήσεις στην Println είναι κλήσεις του 
συστήματος, που επιτρέπουν στον χρονοδρομολογητή να πραγματοποιήσει μια εναλλαγή περιβάλλοντος λειτουργίας. 
Το πρόγραμμα θα μπορούσε να εκτελέσει μονάχα μια από τις δύο ρουτίνες συνεκτέλεσης της Go ή πιθανότατα θα μπορούσε απλά να 
τερματίσει την λειτουργία του αμέσως. 

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            // wg.Done()               <-- ΑΛΛΑΞΕ
        }()

        . . .
    }

Τι θα συμβεί αν κανείς ξεχάσει να καλέσει την Done σε μια από τις ρουτίνες συνεκτέλεσης της Go; Σε αυτή την περίπτωση 
το πρόγραμμα θα κλειδώσει σε αδιέξοδο (στμ. deadlock) καθώς το WaitGroup δεν μπορεί να κατέβει στο 0. Η κλήση
στην Wait θα εμποδίσει τον τερματισμό, για πάντα 

Αποτέλεσμα:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    fatal error: all goroutines are asleep - deadlock!

    goroutine 1 [semacquire]:
    sync.runtime_Semacquire(0xc00001a0a8)
        /usr/local/go/src/runtime/sema.go:56 +0x45
    sync.(*WaitGroup).Wait(0xc00001a0a0)
        /usr/local/go/src/sync/waitgroup.go:130 +0x65
    main.main()
        concurrency/goroutines/example1/example1.go:42 +0x145
    exit status 2

Κανείς μπορεί να διαπιστώσει πως το εκτελέσιμο περιβάλλον της Go προσδιορίζει ότι το πρόγραμμα 
βρίσκεται σε αδιέξοδο στην γραμμή 42 όπου και πραγματοποιείται η κλήση στην Wait. 
Κανείς βέβαια δεν θα πρέπει να είναι υπερβολικά ενθουσιασμένος με τον εντοπισμό του αδιεξόδου 
καθώς θα πρέπει κάθε Goroutine να εμποδίζεται, χωρίς να έχει τρόπο να συνεχίσει. Αυτό υποδεικνύει γιατί 
είναι σημαντικό να βρίσκονται κοντά οι κλήσεις στην Add και στην Done.

    func main() {
        var wg sync.WaitGroup
        wg.Add(1)              <-- ΑΛΛΑΞΕ, Πολύ μικρός αριθμός 

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        . . .
    }

Τι θα συμβεί αν δεν περάσει κανείς τον σωστό αριθμό ρουτίνων συνεκτέλεσης της Go, που πρέπει να περιμένει 
να ολοκληρώσουν την λειτουργία τους, το WaitGroup; Αν ο αριθμός είναι πολύ μεγάλος, θα προκύψει
ένα ακόμα αδιέξοδο. Αν ο αριθμός είναι πολύ μικρός, δεν υπάρχει καμία εγγύηση ότι η εργασία θα
πραγματοποιηθεί, πρωτού το πρόγραμμα προχωρήσει παρακάτω. Το αποτέλεσμα του προγράμματος είναι
απροσδιόριστο.

** Χρονοδρομολογητής Προεκχώρησης 

Παρόλο που ο χρονοδρομολογητής εκτελείται εντός της εμβέλειας της εφαρμογής,
είναι σημαντικό να παρατηρήσει κανείς πως ο προγραμματισμός γίνεται με προεκχώρηση (στμ. preemptive). Αυτό σημαίνει 
ότι δεν είναι δυνατόν αν προβλεφθεί πότε θα πραγματοποιηθεί μια εναλλαγή περιβάλλοντος λειτουργίας
και αυτό θα αλλάζει κάθε φορά, που εκτελείται το πρόγραμμα.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            printHashes("A")
            wg.Done()
        }()

        go func() {
            printHashes("B")
            wg.Done()
        }()

        fmt.Println("Waiting To Finish")
        wg.Wait()

        fmt.Println("\nTerminating Program")
    }

Κάνοντας χρήση του ίδιου πρότυπου ενορχήστρωσης όπως και προηγουμένως, αυτό το πρόγραμμα 
έχει κάθε ρουτίνα συνεκτέλεσης της Go να κάνει περισσότερη εργασία. Ο χρονοδρομολογητής όμως δεν θα δώσει σε 
κάθε ρουτίνα συνεκτέλεσης της Go αρκετό χρόνο για την ολοκληρώσει εντελώς, μέσα σε δοσμένο χρόνου. 

    func printHashes(prefix string) {
        for i := 1; i <= 50000; i++ {
            num := strconv.Itoa(i)
            sum := sha1.Sum([]byte(num))
            fmt.Printf("%s: %05d: %x\n", prefix, i, sum)
        }
        fmt.Println("Completed", prefix)
    }

Αυτή η συνάρτηση εκτελεί πολλές εργασίες προορισμένες για την I/O, οι οποίες έχουν μεγάλη 
πιθανότητα να υποστούν εναλλαγή περιβάλλοντος λειτουργίας.

    $ ./example2 | cut -c1 | grep '[AB]' | uniq
    B
    A
    B
    A
    B
    A
    B
    A
    B
    A  9 Context Switches

    $ ./example2 | cut -c1 | grep '[AB]' | uniq
    B
    A
    B
    A  3 Context Switches

Οπως μπορεί να παρατηρήσει κανείς, κάθε φορά που εκτελείται το πρόγραμμα, υπάρχει διαφορετικός 
αριθμός εναλλαγών περιβάλλοντος λειτουργίας. Αυτό είναι σημαντικό διότι ένας χρονοδρομολογητής δεν πρέπει 
να είναι προβλέψιμος. Η ταυτόχρονη εκτέλεση (στμ. concurrency) πρέπει να παραμείνει απροσδιόριστη και κανείς
οφείλει να το θυμάται αυτό, όταν χρησιμοποιεί ταυτόχρονη εκτέλεση, προκειμένου να λύσει τα όποια προβλήματα 
απόδοσης.

    func init() {
        runtime.GOMAXPROCS(2)
    }

Τι θα συμβεί αν επιστρέψει κανείς στο αρχικό πρόγραμμα, αλλά αλλάξει την GOMAXPROCS, ώστε το πρόγραμμα να 
εκτελείται, ως ένα πρόγραμμα Go με δύο νήματα εκτέλεσης;

Αποτέλεσμα:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N a b c d e f g h i j k l m n o O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    Terminating Program

Aυτό που παρατηρεί κανείς είναι ότι, η ταυτόχρονη εκτέλεση του προγράμματος τώρα είναι περισσότερο λεπτομερής. Το
αποτέλεσμα, μέχρι κάθε γράμμα, είναι απροσδιόριστο και εκτός προκαθορισμένης σειράς.

** Σημειώσεις

- Οι ρουτίνες συνεκτέλεσης της Go είναι συναρτήσεις οι οποίες είναι προγραμματισμένες να εκτελεστούν ξεχωριστά.
- Πρέπει να υπάρχει πάντα μια καθαρή εικόνα των εκτελούμενων ρουτίνων συνεκτέλεσης της Go και να πραγματοποιείται ένας καθαρός τερματισμός.
- Η ταυτόχρονη εκτέλεση δεν είναι παραλληλη εκτέλεση.
- Η ταυτόχρονη εκτέλεση έχει να κάνει με την διαχείριση πολλών πραγμάτων ταυτόχρονα
- Η παραλληλη εκτέλεση έχει να κάνει με την πραγματοποίηση πολλών πραγμάτων ταυτόχρονα. 

"Η παραλληλη εκτέλεση έχει να κάνει με την εκτέλεση δύο ή περισσότερων πραγμάτων ταυτόχρονα. Η ταυτόχρονη εκτέλεση έχει να κάνει με την απροσδιόριστη εκτέλεση εκτός κανονικής σειράς." - William Kennedy

"Κανονικά οι ρουτίνες συνεκτέλεσης της Go δεν πρέπει να διατηρούνται για περισσότερο χρόνο από όσο υπάρχει η συνάρτηση που τις δημιούργησε. Αυτό εξαναγκάζει σε μια εξαιρετικά καλή σχεδιαστική θέση." - Peter Bourgon

** Οδηγίες Σχεδιασμού

- Μάθετε σχετικά με τις [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#concurrent-software-design][οδηγίες σχεδιασμού]] σχετικά με την ταυτόχρονη εκτέλεση.

** Πρόσθετα Αναγνώσματα

- [[https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html][Χρονοδρομολόγηση στην Go - Μέρος Ι]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html][Χρονοδρομολόγηση στην Go - Μέρος ΙΙ]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html][Ιχνηλάτηση Χρονοδρομολογητή στην Go]] - William Kennedy   
- [[https://blog.golang.org/advanced-go-concurrency-patterns][Προχωρημένα Πρότυπα Ταυτόχρονης Εκτέλεσης στην Go]] - Sameer Ajmani    
- [[https://blog.golang.org/context][Ταυτόχρονη Εκτέλεση στην Go: Γενικό Πλαίσιο]] - Sameer Ajmani    
- [[https://blog.golang.org/concurrency-is-not-parallelism][Η ταυτόχρονη εκτέλεση δεν είναι παραλληλη εκτέλεση]] - Rob Pike    
- [[https://talks.golang.org/2013/distsys.slide][Η Go για Kατανεμημένα Συστήματα ]] - Russ Cox    
- [[https://docs.google.com/document/d/1At2Ls5_fhJQ59kDK2DFVhFu3g5mATSXqqV5QrxinasI/edit][Προεπιλογή της GOMAXPROCS στην Go 1.5]]    
- [[https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html][Ταυτόχρονη εκτέλεση, Ρουτίνες Συνεκτέλεσης της Go και η GOMAXPROCS]] - William Kennedy    
- [[http://www.ece.ubc.ca/~sasha/papers/eurosys16-final29.pdf][Ο Χρονοδρομολογητής του Linux: μια Δεκαετία Αχρησιμοποίητων Πυρήνων Επεξεργαστών]]    
- [[https://news.ycombinator.com/item?id=12460807][Εξήγηση του Χρονοδρομολογητή]]    
- [[http://joeduffyblog.com/2016/11/30/15-years-of-concurrency/][15 Χρόνια Ταυτόχρονης Εκτέλεσης]] - Joe Duffy    
- [[https://www.quora.com/How-does-the-golang-scheduler-work/answer/Ian-Lance-Taylor][Πως λειτουργεί ο χρονοδρομολογητής της golang;]] - Ian Lance Taylor    
- [[https://www.youtube.com/watch?v=YHRO5WQGh0k][Η Επική Ιστορία του Χρονοδρομολογητή]] - Kavya Joshi    

* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Ασκηση 1

*Μέρος* *Α* Δημιουργήστε ένα πρόγραμμα που δηλώνει δύο ανώνυμες συναρτήσεις. Μια 
που μετράει από το 100 στο 0 και μια που μετράει από το 0 στο 100. Παρουσιάστε 
κάθε αριθμό με ένα μοναδικό αναγνωριστικό για κάθε goroutine. Στην συνέχεια 
δημιουργείστε ρουτίνες συνεκτέλεσης της Go από αυτές τις συναρτήσεις και μην επιτρέψετε στην main 
να επιστρέψει, μέχρι να ολοκληρώσουν οι ρουτίνες συνεκτέλεσης της Go.

*Μέρος* *Β* Εκτελέστε το πρόγραμμα παράλληλα. 

.play goroutines/exercise1.go
.play goroutines/answer1.go
