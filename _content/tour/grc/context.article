Πακέτο Context 
Το πακέτο context ορίζει τον τύπο Context, ο οποίος μεταφέρει προθεσμίες, σήματα ακύρωσης και άλλες τιμές με εμβέλεια αιτήματος, κατά μήκος των ορίων διαφόρων API και μεταξύ διεργασιών.

* Πακέτο Context 

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εάν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιήστε το Σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Το πακέτο context ορίζει τον τύπο Context, ο οποίος μεταφέρει προθεσμίες, σήματα ακύρωσης 
και άλλες τιμές με εμβέλεια αιτήματος, κατά μήκος των ορίων διαφόρων API και μεταξύ διεργασιών.

** Επισκόπηση Κώδικα

"Οι τιμές Context προορίζονται για δεδομένα εμβέλειας αιτήματος, που μεταφέρονται σε προγράμματα τα οποία εκτελούνται 
σε κατανεμημένα συστήματα."

- *Example* *1:* Αποθήκευση / Ανάκληση Τιμών
- *Example* *2:* WithCancel
- *Example* *3:* WithDeadline
- *Example* *4:* WithTimeout
- *Example* *5:* Αίτημα/Απάντηση
- *Example* *6:* Ακύρωση

.play context/example1.go
.play context/example2.go
.play context/example3.go
.play context/example4.go
.play context/example5.go
.play context/example6.go

** Σημειολογία Context

Η γλώσσα προγραμματισμού Go έχει την προεγκατεστημένη λέξη-κλειδί go, προκειμένου να 
δημιουργεί ρουτίνες συνεκτέλεσης της Go, όμως δεν έχει άλλες λέξεις-κλειδιά ή άμεση υποστήριξη για τον 
τερματισμό των ρουτίνων συνεκτέλεσης της Go. Σε μια υπηρεσία, στον πραγματικό κόσμο, η δυνατότητα λήξης και
τερματισμού των ρουτίνων συνεκτέλεσης της Go είναι κρίσιμη, για την διατήρηση της υγείας και της λειτουργίας 
μιας υπηρεσίας. Κανένα αίτημα ή εργασία δεν μπορεί να εκτελείται για πάντα, επομένως η 
εξακρίβωση και η διαχείριση της καθυστέρησης απόκρισης (στμ. latency), είναι μια ευθύνη, που φέρει κάθε
προγραμματιστής.

Μια λύση, που παρέχεται από την ομάδα της Go, προκειμένου να λυθεί αυτό το πρόβλημα, είναι
το πακέτο Context. Συντάχθηκε και εισήχθη από τον Sameer Ajmani, το 2014, στο συνέδριο 
Gotham Go. Ο ίδιος έγραψε επίσης, μια ανάρτηση για το blog της Go.

Καρτέλα των Slide: [[https://talks.golang.org/2014/gotham-context.slide#1][https://talks.golang.org/2014/gotham-context.slide#1]]

Ανάρτηση στο Blog: [[https://blog.golang.org/context][https://blog.golang.org/context]]

Μέσα από αυτή την δημοσιευμένη εργασία και διάφορες συζητήσεις με τον Sameer μέσα στα χρόνια,
αναπτύχθηκε μια σχετική σημειολογία.

*Εισερχόμενα* *αιτήματα* *σε* *ένα* *server* *πρέπει* *να* *δημιουργούν* *ένα* *Context*

Η στιγμή, προκειμένου να δημιουργηθεί μια Context, είναι πάντα όσο το δυνατόν νωρίτερα,
στην επεξεργασία ενός αιτήματος ή μιας εργασίας. Η εργασία με Context, νωρίς στον κύκλο 
ανάπτυξης, αναγκάζει τον σχεδιασμό API, που λαμβάνουν μια Context σαν την πρώτη παράμετρο. 
Ακόμα και αν κανείς δεν είναι 100% σίγουρος ότι χρειάζεται μια Context, είναι ευκολότερο
να αφαιρεθούν οι παράμετροι Context από κάμποσες συναρτήσεις, από το να προσπαθήσει κανείς
να τις προσθέσει αργότερα. 

    75 // Η Handle είναι ο μηχανισμός που χρησιμοποιείται για την εισαγωγή χειριστών 
    76 // για δεδομένο HTTP ζεύγος verb και path, κάτι που διευκολύνει την δρομολόγηση.
    77 func (a *App) Handle(verb, path string, handler Handler, mw ...Middleware) {
    ...
    85     // Η συνάρτηση που εκτελείται για κάθε αίτημα.
    86     h := func(w http.ResponseWriter, r *http.Request, params map[string]string) {
    87         ctx, span := trace.StartSpan(r.Context(), "internal.platform.web")
    88         defer span.End()
    ...
    106    // Προσθήκη συνάρτησης χειρισμού δρομολόγησης για συγκεκριμένα verb και διαδρομή.
    107    a.TreeMux.Handle(verb, path, h)
    108 }

Παραπάνω βλέπει κανείς κώδικα παρμένο από έργο υπηρεσίας, που διδάσκεται στα Ardan Labs. 
Η γραμμή 86 ορίζει μια συνάρτηση χειριστή, που δεσμεύεται σε όλες τις διαδρομές, όπως φαίνεται
στην γραμμή 107. Είναι αυτή η συνάρτηση, που αρχίζει να επεξεργάζεται, τα όποια εισερχόμενα 
αιτήματα. Στην γραμμή 87, δημιουργείται μια span για το αίτημα, η οποία παίρνει σαν πρώτη 
παράμετρο μια Context. Αυτή είναι η πρώτη φορά στον κώδικα της υπηρεσίας, που χρειάζεται μια 
Context.

Το σπουδαίο είναι, ότι η τιμή http.Request περιέχει ήδη μια. Αυτή η δυνατότητα προστέθηκε στην
έκδοση 1.7 της Go. Αυτό σημαίνει, ότι ο κώδικας δεν χρειάζεται να δημιουργήσει χειροκίνητα μια
Context, στο αρχικό επίπεδο. Αν κανείς χρησιμοποιεί την έκδοση 1.8 της Go, τότε θα πρέπει να 
δημιουργήσει μια άδεια Context, προηγουμένως από την κλήση στην StartSpan, κάνοντας χρήση της 
συνάρτησης context.Background.

    https://golang.org/pkg/context/#Background

    87         ctx := context.Background()
    88         ctx, span := trace.StartSpan(ctx, "internal.platform.web")
    89         defer span.End()

Έτσι θα έπρεπε να είναι ο κώδικας στην έκδοση 1.8 της Go. Όπως ακριβώς περιγράφεται στα έγγραφα
του πακέτου.

Η Background επιστρέφει μια τιμή Context, που είναι άδεια και δεν έχει τιμή nil. Αυτή η τιμή Context 
δεν ακυρώνεται ποτέ, δεν έχει καμία τιμή, και δεν έχει καμία προθεσμία. Χρησιμοποιείται συνήθως 
από την συνάρτηση main, κατά την διάρκεια αρχικής ανάθεσης τιμών και κατά την διάρκεια ελέγχων,
καθώς και ως η αρχική Context, για εισερχόμενα αιτήματα.

Είναι χαρακτηριστικό της συγγραφής κώδικα στην Go, να χρησιμοποιείται το όνομα μεταβλητής ctx, 
για όλες τις τιμές Context. Καθώς ο τύπος Context είναι μια διεπαφή, δεν πρέπει να χρησιμοποιείται 
σημειολογία δείκτη διεύθυνσης. 

    https://golang.org/pkg/context/#Context

    type Context interface {
        Deadline() (deadline time.Time, ok bool)
        Done() <-chan struct{}
        Err() error
        Value(key interface{}) interface{}
    }

Κάθε συνάρτηση, που δέχεται μια Context, πρέπει να λαμβάνει το δικό της αντίγραφο, της 
σχετικής τιμής διεπαφής.

*Εξερχόμενες* *κλήσεις *σε* *servers* *πρέπει* *να* *δέχονται* *μια* *Context*

Η ιδέα πίσω από αυτή την σημειολογία είναι, ότι οι κλήσεις σε ανώτερα επίπεδα πρέπει να 
μπορούν να επικοινωνήσουν με κλήσεις σε κατώτερα επίπεδα, για πόσο είναι διατεθειμένες να 
περιμένουν. Ένα καλό παράδειγμα των παραπάνω είναι στο πακέτο http και στις αλλαγές 
της έκδοσης 1.7, που έγιναν στην μέθοδο τύπου Do, προκειμένου να σέβεται τα χρονικά 
περιθώρια ενός αιτήματος.

    01 package main
    02 
    03 import (
    04     "context"
    05     "io"
    06     "log"
    07     "net/http"
    08     "os"
    09     "time"
    10 )
    11 
    12 func main() {
    13
    14     // Δημιουργία νέου αιτήματος 
    15     req, err := http.NewRequest("GET", "https://www.ardanlabs.com/blog/post/index.xml", nil)
    16     if err != nil {
    17         log.Println("ERROR:", err)
    18         return
    19     }
    20
    21     // Δημιουργία μιας context με timeout των 50 milliseconds.
    22     ctx, cancel := context.WithTimeout(req.Context(), 50*time.Millisecond)
    23     defer cancel()
    24
    25     // Ανάθεση της νέας Context στο αίτημα. 
    26     req = req.WithContext(ctx)
    27
    28     // Πραγματοποίηση της κλήσης web και επιστροφή όποιου σφάλματος. Η Do θα χειριστεί 
    29     // την ακύρωση επιπέδου Context.
    30     resp, err := http.DefaultClient.Do(req)
    31     if err != nil {
    32       log.Println("ERROR:", err)
    33       return
    34     }
    35
    36     // Κλείσιμο του σώματος της απάντησης στην επιστροφή 
    37     defer resp.Body.Close()
    38
    39     // Εγγραφή της απάντησης στην stdout.
    40     io.Copy(os.Stdout, resp.Body)
    41 }

Αυτό το πρόγραμμα, κάνει ένα αίτημα για την τροφοδοσία του blog της Ardan, με χρόνο 
timeout 50 millisecond. Στις γραμμές 15-19, δημιουργείται το αίτημα, προκειμένου να
πραγματοποιήσει μια κλήση GET, στο παρεχόμενο URL. Οι γραμμές 22-23 δημιουργούν μια 
Context, με χρόνο timeout 50 millisecond. Ένα νέο API που προστέθηκε στην τιμή Request 
στην έκδοση 1.7, είναι η μέθοδος τύπου WithContext. Αυτή η μέθοδος τύπου, επιτρέπει 
στο πεδίο Context, της τιμής Request, να ανανεωθεί. Στην γραμμή 26, ο κώδικας κάνει 
ακριβώς αυτό.

Στην γραμμή 30, πραγματοποιείται το αίτημα, χρησιμοποιώντας την μέθοδο τύπου Do, από το 
την τιμή DefaultClient, του πακέτου http. Η μέθοδος τύπου Do, θα σεβαστεί τον χρόνο timeout 
των 50 millisecond, που βρίσκεται στην Context εντός της τιμής Request. Αυτό που βλέπει κανείς
είναι ο κώδικας (συνάρτηση υψηλότερου επιπέδου) να λέει στην μέθοδο τύπου Do (συνάρτηση χαμηλότερου επιπέδου) 
πόσο είναι διατεθειμένος να περιμένει, ώστε η λειτουργία της Do να ολοκληρωθεί.

*Δεν* *πρέπει* *να* *αποθηκεύονται* *τιμές* *Context* *σε* *μεταβλητές* *τύπου* *struct*

Αντί για κάτι τέτοιο, περάστε μια Context εμφανώς σε κάθε συνάρτηση, που το χρειάζεται. 
Ουσιαστικά, κάθε συνάρτηση που εκτελεί I/O, θα πρέπει να αποδέχεται μια τιμή Context σαν 
την πρώτη της παράμετρο και να σέβεται τον χρόνο timeout ή όποια προθεσμία ρυθμίζεται, από τον 
καλώντα. Στην περίπτωση της Request, υπήρχαν ζητήματα συμβατότητας που έπρεπε να ληφθούν υπόψη. 
Έτσι αντί να αλλάξει το API, υλοποιήθηκε ο μηχανισμός που παρουσιάστηκε παραπάνω. 

Υπάρχουν εξαιρέσεις σε κάθε κανόνα. Όμως, εντός του εύρους εφαρμογής αυτού του post και για κάθε 
API από την προεγκατεστημένη βιβλιοθήκη, που παίρνει μια Context, είναι καθιερωμένο να χρησιμοποιείται
η πρώτη παράμετρος, προκειμένου να δεχτεί μια τιμή Context.

.image /tour/grc/static/img/context_figure1.png

Η παραπάνω εικόνα δείχνει ένα παράδειγμα από το πακέτο net, όπου η πρώτη παράμετρος κάθε
μεθόδου τύπου παίρνει μια Context και χρησιμοποιεί το καθιερωμένο όνομα
μεταβλητής ctx

*Η* *αλυσίδα* *των* *κλήσεων* *συναρτήσεων* *μεταξύ* *τους* *πρέπει* *να* *μεταδίδει* *την* *Context*

Ο παραπάνω είναι ένας σημαντικός κανόνας, καθώς μια Context βασίζεται σε κάποιο αίτημα ή σε κάποια εργασία.
Θέλει κανείς την Context και όποιες αλλαγές γίνουν σε αυτή, κατά την διάρκεια της επεξεργασίας του αιτήματος 
ή της εργασίας, να μεταδοθούν και να γίνουν σεβαστές.

    23 // Η List επιστρέφει όλους του υπάρχοντες χρήστες του συστήματος.
    24 func (u *User) List(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    25     ctx, span := trace.StartSpan(ctx, "handlers.User.List")
    26     defer span.End()
    27
    28     users, err := user.List(ctx, u.db)
    29     if err != nil {
    30         return err
    31     }
    32
    33     return web.Respond(ctx, w, users, http.StatusOK)
    34 }

Στην παραπάνω καταγραφή κώδικα μπορεί κανείς να δει μια συνάρτηση διαχείρισης αιτήματος 
(handler) με το όνομα List, που εκτελείται όταν ο χρήστης πραγματοποιεί ένα HTTP αίτημα, για το
παρόν ακραίο σημείο (στμ. end point) του κώδικα. Η συνάρτηση διαχείρισης αιτήματος δέχεται σαν την πρώτη παράμετρο μια
Context, καθώς είναι μέρος ενός αιτήματος και πρόκειται να πραγματοποιήσει λειτουργία I/O. 
Μπορεί κανείς να δεί στις γραμμές 25, 28 και 33 ότι η ίδια τιμή Context διαδίδεται προς τα κάτω,
στην στοίβα κλήσεων.

Δεν δημιουργείται μια νέα τιμή Context, καθώς αυτή η συνάρτηση δεν απαιτεί αλλαγές στην Context.
Αν θα έπρεπε να δημιουργηθεί μια νέα τιμή Context υψηλού επιπέδου από αυτή την συνάρτηση, 
όποια υπάρχουσα πληροφορία Context από κλήση σε υψηλότερο επίπεδο, που σχετιζόταν με αυτό το αίτημα, 
θα χανόταν. Αυτό δεν είναι κάτι, που θα έπρεπε να επιδιώκει κανείς. 

    33 // Η List ανασύρει έναν κατάλογο υπάρχοντων χρηστών από την βάση δεδομένων.
    34 func List(ctx context.Context, db *sqlx.DB) ([]User, error) {
    35     ctx, span := trace.StartSpan(ctx, "internal.user.List")
    36     defer span.End()
    37
    38     users := []User{}
    39     const q = `SELECT * FROM users`
    40
    41     if err := db.SelectContext(ctx, &users, q); err != nil {
    42         return nil, errors.Wrap(err, "selecting users")
    43     }
    44
    45     return users, nil
    46 }

Εδώ παρουσιάζεται η δήλωση της μεθόδου τύπου List, που κληθηκε στην γραμμή 28. Για άλλη 
μια φορά, αυτή η μέθοδος τύπου δεχεται μια Context, ως την πρώτη παράμετρο της. Αυτή η τιμή 
προωθείται στην συνέχεια, κατά μήκος της στοίβας κλήσεων, ξανά στις γραμμές 35 και 41. Καθώς
η γραμμή 41 είναι μια κλήση βάσης δεδομένων, αυτή η συνάρτηση θα πρέπει να σεβαστεί όποια
πληροφορία για χρόνο timeout οριστεί στην Context, από τον καλώντα του υψηλότερου επιπέδου.

*Αντικατάσταση* *μιας* *Context* *με* *WithCancel,* *WithDeadline,* *WithTimeout,* *ή* *WithValue*

Επειδή κάθε συνάρτηση μπορεί να προσθέσει/τροποποιήσει την Context για τις δικές της ανάγκες, 
και αυτές οι αλλαγές δεν πρέπει να επηρεάσουν όποια συνάρτηση είχε κληθεί προηγουμένως, η τιμή
Context χρησιμοποιεί σημειολογία τιμής. Αυτό σημαίνει ότι, κάθε αλλαγή σε μια τιμή Context, δημιουργεί 
μια νέα τιμή Context, που μεταδίδεται προς τα εμπρός. 

    01 func main() {
    02
    03     // Ορισμός διάρκειας
    04     duration := 150 * time.Millisecond
    05
    06     // Δημιουργία μιας Context η οποία μπορεί να ακυρωθεί χειροκίνητα και θα ενημερώσει 
    07     // για ακύρωση, σε συγκεκριμένη διάρκεια.
    08     ctx, cancel := context.WithTimeout(context.Background(), duration)
    09     defer cancel()
    10
    11     // Δημιουργία καναλιού επικοινωνίας για λήψη μηνύματος ολοκλήρωσης εργασίας.
    12     ch := make(chan data, 1)
    13
    14     // Αίτημα σε ρουτίνα συνεκτέλεσης της Go να πραγματοποιήσει εργασίες.
    15     go func() {
    16
    17         // Προσομοίωση εργασίας.
    18         time.Sleep(50 * time.Millisecond)
    19
    20         // Ενημέρωση ολοκλήρωσης εργασίας.
    21         ch <- data{"123"}
    22     }()
    23
    24     // Αναμονή ολοκλήρωσης εργασίας. Αν παίρνει πολύ χρόνο, συνέχεια παρακάτω.
    25     select {
    26         case d := <-ch:
    27             fmt.Println("work complete", d)
    28
    29         case <-ctx.Done():
    30             fmt.Println("work cancelled")
    31     }
    32 }

Το παραπάνω μικρό πρόγραμμα παρουσιάζει την φύση της σημειολογίας τιμής της 
συνάρτησης WithTimeout. Στην γραμμή 08, η κλήση στην WithTimeout επιστρέφει μια
νέα τιμή Context και μια συνάρτηση cancel. Εφόσον η κλήση της συνάρτησης απαιτεί 
αρχική τιμή Context, ο κώδικας χρησιμοποιεί την συνάρτηση Background, προκειμένου να 
δημιουργήσει μια άδεια, υψηλού επιπέδου, Context. Αυτός είναι ο προορισμός της συνάρτησης 
Background.

Στην συνέχεια, χρησιμοποιείται η τιμή Context που δημιουργήθηκε με την συνάρτηση WithTimeout.
Αν μελλοντικές συναρτήσεις στην αλυσίδα κλήσεων, χρειάζονται το δικό τους εξειδικευμένο χρόνο timeout 
ή άλλη προθεσμία, πρέπει να χρησιμοποιήσουν την κατάλληλη συνάρτηση With και αυτή την νέα τιμή Context 
ως αρχική.

Είναι κρίσιμο, όποια συνάρτηση cancel που επιστρέφεται από μια συνάρτηση With, 
να εκτελείται πριν την επιστροφή της συνάρτησης. Γι' αυτό τον λόγο, είναι καθιερωμένο να 
χρησιμοποιείται η λέξη-κλειδί defer αμέσως μετά την κλήση With, όπως φαίνεται στην γραμμή 26.
Αν δεν συμβεί αυτό, θα υπάρχουν διαρροές μνήμης στο πρόγραμμα.

*Όταν* *μια* *Context* *ακυρώνεται* *τότε* *ακυρώνονται* *όλες* *οι* *Context* *που* *προέκυψαν* *από* *αυτή*

Η χρήση της σημειολογίας τιμής, για το API του τύπου Context σημαίνει ότι, κάθε μια νέα τιμή Context 
παίρνει ό,τι έχει η αρχική τιμή Context, συν τις όποιες καινούργιες αλλαγές. Αυτό σημαίνει ότι, αν 
μια αρχική τιμή Context ακυρωθεί, όλες οι επόμενες που έπονται της αρχικής τιμής Context, ακυρώνονται 
και αυτές. 

    01 func main() {
    02
    03     // Δημιουργία Context που μπορεί να ακυρωθεί. 
    04     ctx, cancel := context.WithCancel(context.Background())
    05     defer cancel()
    06
    07     // Χρήση Waitgroup για ενορχήστρωση.
    08     var wg sync.WaitGroup
    09     wg.Add(10)
    10
    11     // Δημιουργία δέκα ρουτίνων συνεκτέλεσης Go, οι οποίες θα αποκτήσουν μια Context από 
    12     // εκείνη που δημιουργείται αρχικά.
    13     for i := 0; i < 10; i++ {
    14         go func(id int) {
    15             defer wg.Done()
    16
    17             // Δημιουργία νέας Context σε αυτή την ρουτίνα συνεκτέλεσης Go από την Context
    18             // που ανήκει στην συνάρτηση main.
    19             ctx := context.WithValue(ctx, key, id)
    20
    21             // Αναμονή έως ότου ακυρωθεί η Context.
    22             <-ctx.Done()
    23             fmt.Println("Cancelled:", id)
    24         }(i)
    25     }
    26
    27     // Ακύρωση της Context και όποια παράγωγη Context, επίσης.
    28     cancel()
    29     wg.Wait()
    30 }

Αυτό το πρόγραμμα δημιουργεί μια τιμή Context, η οποία μπορεί να ακυρωθεί στην 
γραμμή 04. Τότε στις γραμμές 13-25, δημιουργούνται δέκα ρουτίνες συνεκτέλεσης της Go. Κάθε ρουτίνα συνεκτέλεσης της Go 
τοποθετεί το μοναδικό id της στη δική της τιμή Context, στην γραμμή 19. Η κλήση στην 
WithValue παίρνει την τιμή Context της συνάρτησης main, ως αρχική. Μετά, στην 
γραμμή 22, κάθε ρουτίνα συνεκτέλεσης της Go περιμένει, έως ότου η Context της ακυρωθεί. 

Στην γραμμή 28, η κύρια ρουτίνα συνεκτέλεσης της Go ακυρώνει την δική της τιμή Context και στην 
συνέχεια περιμένει στην γραμμή 29 ώστε όλες οι δέκα ρουτίνες συνεκτέλεσης της Go να λάβουν το μήνυμα,
πρωτού τερματιστεί το πρόγραμμα. Όταν κληθεί η συνάρτηση cancel, όλες οι δέκα 
ρουτίνες συνεκτέλεσης της Go στην γραμμή 41, θα απελευθερωθούν και θα τυπώσουν ότι, έχουν ακυρωθεί.
Χρειάζεται μια κλήση στην cancel για να ακυρωθούν όλες.

Αυτό δείχνει επίσης ότι, η ίδια Context μπορεί να περάσει σε συναρτήσεις που 
εκτελούνται σε διαφορετικές ρουτίνες συνεκτέλεσης της Go. Μια Context είναι ασφαλής για ταυτόχρονη 
χρήση από πολλαπλές ρουτίνες συνεκτέλεσης της Go.

Δεν πρέπει να περνάει μια τιμή nil σε μια Context, ακόμα και αν η συνάρτηση το επιτρέπει.
Μπορεί κανείς να περάσει σε μια τιμή Context την TODO, αν δεν είναι ξεκάθαρο, ποια τιμή Context 
πρέπει να χρησιμοποιηθεί. Η συνάρτηση TODO του πακέτου Context, είναι μια αγαπημένη συνάρτηση. 
Ο προγραμματιστής πάντα επεξεργάζεται τον κώδικα που γράφει. Δεν υπάρχει σημαντική διαφορά,
με τον συγγραφέα, που επεξεργάζεται διαφορετικές εκδόσεις ενός άρθρου. Δεν μπορεί να 
ξέρει κανείς τα πάντα, καθώς γράφει κώδικα, όμως ελπίζει ότι γνωρίζει αρκετά, ώστε να κάνει 
κάποια πρόοδο. Τελικά, κανείς συνεχώς μαθαίνει, ξαναγράφει και πραγματοποιεί ελέγχους.

Υπάρχουν πολλές φορές, που μπορεί να γνωρίζει κανείς ότι χρειάζεται μια a Context,
όμως είναι αβέβαιο από που πρέπει να προέλθει. Αν γνωρίζει ότι, δεν είναι υπεύθυνος 
για την δημιουργία μιας Context υψηλότερου επιπέδου, τότε ξέρει ότι δεν μπορεί να χρησιμοποιήσει
την συνάρτηση Background. Αν γνωρίζει ότι χρειάζεται μια προσωρινή Context υψηλότερου επιπέδου, 
μέχρι να ξεκαθαρίσει την αρχική προέλευση της υπάρχουσας Context, τότε είναι που πρέπει
να χρησιμοποιήσει την συνάρτηση TODO, αντί της συνάρτησης Background.

*Χρήση* *τιμών* *Context* *μόνο* *για* *δεδομένα* *με* *εμβέλεια* *αιτήματος* 

Δεν πρέπει κανείς να χρησιμοποιεί την Context για να περνάει προαιρετικές παραμέτρους
σε συναρτήσεις. Αυτή ίσως είναι η σημαντικότερη σημειολογία όλων. Δεν πρέπει να 
χρησιμοποιεί κανείς την τιμή Context, για να περνάει δεδομένα σε μια συνάρτηση, όταν αυτά τα
δεδομένα χρειάζονται, ώστε η συνάρτηση να εκτελεστεί επιτυχημένα. Με άλλα λόγια, μια 
συνάρτηση θα πρέπει να μπορεί να εκτελέσει την λογική της με μια άδεια τιμή Context. 
Σε περίπτωση που μια συνάρτηση απαιτεί πληροφορίες από την Context, αν αυτή η πληροφορία
λείπει, το πρόγραμμα θα πρέπει να αποτύχει και να ενημερώσει την εφαρμογή ώστε να τερματιστεί. 

Ένα κλασσικό παράδειγμα κατάχρησης, του να περνάει κανείς δεδομένα σε μια κλήση συνάρτησης,
χρησιμοποιώντας μια Context, είναι με συνδέσεις σε βάσεις δεδομένων. Ως ένας γενικός κανόνας, 
θα πρέπει κανείς να θέλει να ακολουθήσει την συνήθη σειρά, όταν μετακινεί δεδομένα στο πρόγραμμα.

Τα δεδομένα πρέπει να περνάνε ως παράμετροι της συνάρτησης. Αυτός είναι ο πιο καθαρός τρόπος να
μετακινηθούν δεδομένα γύρω στο πρόγραμμα, χωρίς να κρύβονται.

Τα δεδομένα πρέπει να περνάνε από τον δέκτη μεθόδου. Αν η συνάρτηση που χρειάζεται τα δεδομένα δεν
είναι δυνατό να να αλλάξει την υπογραφή της, τότε κανείς μπορεί να χρησιμοποιήσει μια μέθοδο τύπου
και να περάσει τα δεδομένα μέσω του δέκτη μεθόδου.

Γρήγορο παράδειγμα χρήσης ενός δέκτη μεθόδου.

Οι χειριστές αιτημάτων αποτελούν ένα κλασσικό παράδειγμα του δεύτερου κανόνα παραπάνω. Καθώς μια 
συνάρτηση χειριστή αιτήματος δεσμεύεται από συγκεκριμένη δήλωση, η υπογραφή της δεν μπορεί να αλλάξει.

    23 // Η List επιστρέφει όλους τους υπάρχοντες χρήστες στο σύστημα. 
    24 func (u *User) List(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    25     ctx, span := trace.StartSpan(ctx, "handlers.User.List")
    26     defer span.End()
    27
    28     users, err := user.List(ctx, u.db)
    29     if err != nil {
    30         return err
    31     }
    32
    33     return web.Respond(ctx, w, users, http.StatusOK)
    34 }

Εδώ παρουσιάζεται η μέθοδος τύπου List του χειριστή αιτήματος, από το έργο service. 
Η υπογραφή αυτών των μεθόδων τύπου τις δεσμεύει, από ό,τι έχει οριστεί, από το πλαίσιο 
λειτουργίας web και δεν μπορεί να αλλάξει. Όμως, προκειμένου να γίνει η κλήση 
που αφορά την λογική της συγκεκριμένης υλοποίησης στην γραμμή 28, απαιτείται μια σύνδεση 
σε βάση δεδομένων. Ο κώδικας αυτός δεν αποκτά την δυνατότητα σύνδεσης από την τιμή Context
της συνάρτησης, αλλά από τον δέκτη μεθόδου.

    15 // Η User αντιπροσωπεύει το σύνολο χειριστών μεθόδων τύπου του API User.
    16 type User struct {
    17     db            *sqlx.DB
    18     authenticator *auth.Authenticator
    19
    20 // ΠΡΟΣΘΗΚΗ ΑΛΛΩΝ ΚΑΤΑΣΤΑΣΕΩΝ ΟΠΩΣ ΚΑΤΑΓΡΑΦΗΣ ΚΑΙ ΡΥΘΜΙΣΕΩΝ ΕΔΩ 
    21 }

Κανείς παρατηρεί την δήλωση του τύπου για τον λήπτη μεθόδου. Οτιδήποτε χρειάζεται ένας χειριστής 
αιτήματος, ορίζεται ως πεδίο. Αυτό επιτρέπει στην πληροφορία να μην είναι κρυμμένη και το επίπεδο 
που αφορά την λογική της υλοποίησης, μπορεί να λειτουργήσει με μια άδεια τιμή Context.

    14 // Η API δημιουργεί μαι τιμή τύπου http.Handler με όλες τις διαδρομές της εφαρμογής ορισμένες.
    15 func API(shutdown chan os.Signal, log *log.Logger, db *sqlx.DB, authenticator *auth.Authenticator) http.Handler {
    16
    ...
    26     // Καταχώρηση των σημείων τέλους για διαχείριση χρήστη και επιβεβαίωση γνησιότητας.
    27     u := User{
    28         db:            db,
    29         authenticator: authenticator,
    30     }
    31
    32     app.Handle("GET", "/v1/users", u.List)

Ο κώδικας παραπάνω δημιουργεί μια τιμή User και στην συνέχεια δεσμεύει την μέθοδο 
τύπου List στην δρομολόγηση. Για άλλη μια φορά, επειδή η υπογραφή της συνάρτησης χειριστή 
(στμ. handler) δεν μεταβάλλεται, η χρήση ενός δέκτη μεθόδου και μέθοδοι τύπου είναι ο επόμενος καλύτερος 
τρόπος, για να περάσουν δεδομένα χωρίς να είναι κρυμμένα. 

*Δεδομένα* *Αποσφαλμάτωσης* *ή* *Ιχνηλάτησης* *είναι* *ασφαλές* *να* *περάσουν* *σε* *μια* *Context*

Κάποια δεδομένα που μπορούν να αποθηκευτούν και να ανασυρθούν από μια τιμή Context, είναι δεδομένα
αποσφαλμάτωσης και πληροφορίες ιχνηλάτησης.

    23 // Η Values αντιπροσωπεύει την κατάσταση για κάθε αίτημα.
    24 type Values struct {
    25     TraceID    string
    26     Now        time.Time
    27     StatusCode int
    28 }

Εδώ παρουσιάζεται η δήλωση ενός τύπου, που δημιουργείται και αποθηκεύεται σε κάθε τιμή 
Context, που δημιουργείται για ένα νέο αίτημα. Τα τρία πεδία παρέχουν πληροφορίες ιχνηλάτησης 
και αποσφαλμάτωσης για το αίτημα. Σχετικές πληροφορίες συγκεντρώνονται καθώς το αίτημα 
προχωράει.

    75 // Η Handle είναι ο μηχανισμός για δήλωση χειριστών για δεδομένο HTTP ζεύγος
    76 // verb και path, αποτελεί μια εύκολη και βολική διαδικασία δρομολογήσεων.
    77 func (a *App) Handle(verb, path string, handler Handler, mw ...Middleware) {
    78
    ...
    79     // Η συνάρτηση που εκτελείται σε κάθε αίτημα.
    80     h := func(w http.ResponseWriter, r *http.Request, params map[string]string) {
    …
    84     // Ανάθεση της Context με τις απαιτούμενες τιμές ποροκειμένου να γίνει η
    85     // επεξεργασία του αιτήματος
    86     v := Values{
    87         TraceID: span.SpanContext().TraceID.String(),
    88         Now:     time.Now(),
    89     }
    90     ctx = context.WithValue(ctx, KeyValues, &v)

Μπορεί κανείς να παρατηρήσει πως ο τύπος Values δημιουργείται στην γραμμή 86 και μετά αποθηκεύεται 
στην Context, στην γραμμή 90. Η περισσότερη από την σχετική πληροφορία, είναι απαραίτητη στο ενδιάμεσο 
λογισμικό, που πραγματοποιεί καταγραφές.

    20 // Δημιουργία του χειριστή αιτημάτων που θα αποδοθεί στην αλυσίδα ενδιάμεσου λογισμικού.
    21 h := func(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    ...
    25     // Αν η Context δεν έχει αυτή την τιμή, ζητείται από την υπηρεσία
    26     // να τερματιστεί ομαλά.
    27     v, ok := ctx.Value(web.KeyValues).(*web.Values)
    28     if !ok {
    29         return web.NewShutdownError("web value missing from context")
    30     }
    ...
    34     log.Printf("%s : (%d) : %s %s -> %s (%s)",
    35         v.TraceID, v.StatusCode,
    36         r.Method, r.URL.Path,
    37         r.RemoteAddr, time.Since(v.Now),
    38     )

Οι συνέπειες διαμοιρασμού πληροφοριών μέσω της Context, φαίνονται στον κώδικα στις 
γραμμές 27-30. Ο κώδικας προσπαθεί να ανασύρει τα δεδομένα Values από την Context
και να ελέγξει αν τα δεδομένα ήταν παρόντα. Αν τα δεδομένα δεν είναι παρόντα, τότε 
υπάρχει σημαντικό θέμα ακεραιότητας της διαδικασίας και η υπηρεσία πρέπει να τερματιστεί.
Αυτό συμβαίνει στον κώδικα της υπηρεσίας με την αποστολή μιας ειδικής τιμής error 
πίσω, μέσω της εφαρμογής.

Αν κανείς περνάει συνδέσεις βάσεων δεδομένων ή πληροφορίες χρηστών στο επίπεδο της 
λογική της συγκεκριμένης υλοποίησης κάνοντας χρήση μιας Context, δημιουργούνται 
δύο προβλήματα:

- Απαιτείται έλεγχος ακεραιότητας και χρειάζεται διαθέσιμος μηχανισμός τερματισμού της υπηρεσίας, γρήγορα.
- Ο έλεγχος και η αποσφαλμάτωση γίνονται δυσκολότερα και περισσότερο περίπλοκα. Απομακρύνεται κανείς από την διαύγεια και την ευκολία ανάγνωσης του κώδικα του.

** Σημειώσεις

- Εισερχόμενα αιτήματα σε server πρέπει να δημιουργούν μια Context.
- Εξερχόμενες κλήσεις από server πρέπει να αποδέχονται μια Context. 
- Η αλυσίδα των κλήσεων συναρτήσεων μεταξύ τους πρέπει να μεταδίδουν την Context.
- Αντικατάσταση μιας Context με χρήση των WithCancel, WithDeadline, WithTimeout, ή WithValue.
- Όταν μια Context ακυρώνεται, όλες οι Contexts που προέρχονται από αυτή ακυρώνονται, επίσης.
- Δεν πρέπει να αποθηκεύονται οι Contexts σε τύπους struct, αλλά θα πρέπει να περνάνε φανερά, σε κάθε συνάρτηση που τις χρειάζεται.
- Δεν πρέπει να περνάει μια Context με τιμή nil, ακόμα και αν μια συνάρτηση το επιτρέπει. Πρέπει κανείς να περνάει την context.TODO αν δεν είναι σίγουρος ποια Context να χρησιμοποιήσει.
- Οι τιμές Context πρέπει να χρησιμοποιούνται μόνο για δεδομένα εμβέλειας αιτήματος, που μεταβαίνουν σε διαδικασίες και σε API, όχι προκειμένου να περνάνε προαιρετικές παράμετροι σε συναρτήσεις.
- Η ίδια τιμή Context μπορεί να περάσει σε συναρτήσεις που εκτελούνται σε διαφορετικές ρουτίνες συνεκτέλεσης της Go. Οι τιμές Context είναι ασφαλείς για ταυτόχρονη χρήση από πολλές ρουτίνες συνεκτέλεσης της Go.

** Πρόσθετα Αναγνώσματα

- [[https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html][Σημειολογία Πακέτου Context στην Go]] - William Kennedy  
- [[https://golang.org/pkg/context][Πακέτο context]] - Go Team    
- [[https://blog.golang.org/context][Πρότυπα Ταυτόχρονης Εκτέλεσης στην Go: Context]] - Sameer Ajmani    
- [[https://rakyll.org/leakingctx/][Χρήση των context προς αποφυγή ρουτίνων συνεκτέλεσης της Go με διαρροές]] - JBD    

* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

Χρησιμοποιήστε το πρότυπο και ακολουθείστε τις οδηγίες. Θα γράψετε έναν χειριστή ιστού (στμ. web) που πραγματοποιεί μια μίμηση κλήσης σε βάση δεδομένων, η οποία όμως θα λήξει λόγω ύπαρξης χρόνου timeout σε μια Context αν η κλήση διαρκεί περισσότερο χρόνο. Επίσης θα αποθηκεύσετε κατάσταση στην Context.

.play context/exercise1.go
.play context/answer1.go
