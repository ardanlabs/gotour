Βασικές Έννοιες
Μαθαίνοντας πως γράφεται μια βασική γενική συνάρτηση εκτύπωσης.

* Γενικός Προγραμματισμός - Βασικές Έννοιες 

Μαθαίνοντας πως γράφεται μια βασική γενική συνάρτηση εκτύπωσης.

** Video

Μπορεί κανείς να παρακολουθήσει την ομιλία του Bill Kennedy, σχετικά με τον Γενικό Προγραμματισμό,
που παρουσιάζει λεπτομερώς όλα τα παραδείγματα αυτής της ενότητας της Επισκόπησης.

.html generics-video.html

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1*: Συγκεκριμένη υλοποίηση της print
- *Παράδειγμα* *2*: Υλοποίηση της print με Διαβεβαίωση Τύπου
- *Παράδειγμα* *3*: Υλοποίηση της print με Αντανάκλαση
- *Παράδειγμα* *4*: Γενική υλοποίηση της print

.play generics/basics/example1.go
.play generics/basics/example2.go
.play generics/basics/example3.go
.play generics/basics/example4.go

** Εξήγηση

Αν θέλει κανείς να γράψει μια μοναδική συνάρτηση print, που να μπορεί να επιστρέψει μια φέτα
οποιουδήποτε τύπου, χωρίς την χρήση αντανάκλασης, μπορεί να χρησιμοποιήσει το νέο συντακτικό 
γενικού προγραμματισμού.

    func print[T any](slice []T) {
        fmt.Print("Generic: ")
        
        for _, v := range slice {
            fmt.Print(v, " ")
        }

        fmt.Print("\n")
    }

Πρόκειται για την υλοποίηση μιας μοναδικής συνάρτησης print, που μπορεί να επιστρέψει 
μια φέτα οποιουδήποτε δοσμένου τύπου, κάνοντας χρήσης του νέου συντακτικού γενικού προγραμματισμού.
Αυτό που είναι ωραίο με αυτό το συντακτικό είναι, ότι ο κώδικας στην συνάρτηση μπορεί να 
χρησιμοποιήσει συντακτικό και προεγκατεστημένες συναρτήσεις, που θα λειτουργούσαν με ένα
πραγματικό τύπο. Δεν συμβαίνει το ίδιο, όταν κανείς χρησιμοποιεί την κενή διεπαφή, προκειμένου
να γράψει κώδικα γενικού προγραμματισμού.

Πρέπει να υπάρχει κάποιος τρόπος να ενημερωθεί ο μεταγλωττιστής, ότι δεν θα δηλωθεί ο
τύπος T ρητά, αλλά ότι θα πρέπει να προσδιοριστεί, από τον μεταγλωττιστή κατά το στάδιο
της μεταγλώττισης. Το νέο συντακτικό χρησιμοποιεί αγκύλες γι' αυτό.
Οι αγκύλες ορίζουν έναν κατάλογο αναγνωριστικών γενικού τύπου, που αντιπροσωπεύουν τύπους
οι οποίοι είναι συγκεκριμένοι στην συνάρτηση, όπου πρέπει να εξακριβωθούν κατά το στάδιο 
μεταγλώττισης. Είναι ο τρόπος με τον οποίο ενημερώνεται ο μεταγλωττιστής, ότι οι τύποι 
με αυτά τα ονόματα δεν θα δηλωθούν, πρωτού γίνει η μεταγλώττιση του προγράμματος. Αυτοί οι
τύποι πρέπει να εξακριβωθούν, κατά το στάδιο της μεταγλώττισης. 

Σημείωση: Μπορεί κανείς να έχει πολλά αναγνωριστικά ορισμένα στις αγκύλες, μολονότι το παρόν
παράδειγμα χρησιμοποιεί μόνο ένα. Πχ. [T, S, R any]

Μπορεί κανείς να ονομάσει αυτά τα αναγνωριστικά τύπων όπως θέλει, προκειμένου να βοηθηθεί η
δυνατότητα ανάγνωσης του κώδικα. Σε αυτή την περίπτωση, ο κώδικας χρησιμοποιεί το κεφαλαίο 
γράμμα T, προκειμένου να περιγράψει μια φέτα κάποιου τύπου T (που πρέπει να προσδιοριστεί 
κατά το στάδιο μεταγλώττισης), που θα περάσει στην συνάρτηση. Είναι σύνηθες στην συγγραφή κώδικα 
Go, να χρησιμοποιούνται μοναδικά κεφαλαία γράμματα, όταν πρόκειται για συλλογές και είναι επίσης
μια σύμβαση, που πηγαίνει πίσω σε παλαιότερες γλώσσες προγραμματισμού, όπως η C++ και η Java.

Υπάρχει επίσης και η χρήση της λέξης any, εντός των αγκυλών. Αυτή αντιπροσωπεύει έναν 
περιορισμό σχετικά με τον τύπο T και τι μπορεί να είναι. Ο μεταγλωττιστής απαιτεί 
όλοι οι γενικοί τύποι να έχουν έναν καλά ορισμένο περιορισμο τύπου. Ο περιορισμός τύπου 
any είναι προεγκατεστημένος από τον μεταγλωττιστή και δηλώνει ότι δεν υπάρχουν περιορισμοί 
στον τύπο που μπορεί να είναι ο T.

    numbers := []int{1, 2, 3}
    print[int](numbers)

    strings := []string{"A", "B", "C"}
    print[string](strings)
    
    floats := []float64{1.7, 2.2, 3.14}
    print[float64](floats)

Με αυτό τον τρόπο γίνονται οι κλήσεις στην γενική συνάρτηση print, όπου η πληροφορία 
του τύπου για τον T παρέχεται λεπτομερώς στο σημείο κλήσης. Το συντακτικό μιμείται την 
ιδέα, ότι η δήλωση της συνάρτησης func name[T any](slice []T) ορίζει δύο σύνολα παραμέτρων.
Το πρώτο σύνολο αφορά τους τύπους, που ανταποκρίνονται στα αντίστοιχα αναγνωριστικά και το 
δεύτερο είναι τα δεδομένα, που αντιστοιχούν στις μεταβλητές εισόδου.

Ευτυχώς, ο μεταγλωττιστής μπορεί να συνάγει τον τύπο και να περιορίσει την ανάγκη, του να 
παρέχει κανείς λεπτομερώς πληροφορίες για τους τύπους στο σημείο, που πραγματοποιείται η
κλήση.

    numbers := []int{1, 2, 3}
    print(numbers)
    
    strings := []string{"A", "B", "C"}
    print(strings)
    
    floats := []float64{1.7, 2.2, 3.14}
    print(floats)

Ο κώδικας παραπάνω παρουσιάζει, πως είναι δυνατον να κληθεί μια γενική συνάρτηση print,
χωρίς να χρειάζεται να περάσουν πληροφορίες τύπων λεπτομερώς. Στο σημείο κλήσης της 
συνάρτησης, ο μεταγλωττιστής μπορεί να προσδιορίσει ποιόν τύπο να χρησιμοποιήσει για τον
T και να δημιουργήσει μια πραγματική εκδοχή για την συνάρτηση, προκειμένου να υποστηρίξει
φέτες αυτού του τύπου. Ο μεταγλωττιστής έχει την ικανότητα να συμπεράνει τον τύπο, με την 
πληροφορία που έχει στο σημείο κλήσης, με βάση τα δεδομένα που περνάνε σ' αυτή. 

* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Ασκήσεις 1

Υλοποιήστε μια γενική συνάρτηση με το όνομα marshal που αποδέχεται κάθε 
τιμή και μπορεί να σειριοποιήσει (στμ. marshal) αυτή την τιμή σε μορφή JSON, 
επιστρέφοντας την (στμ. κωδικοποίηση) JSON και ένα σφάλμα. Δηλώστε έναν τύπο struct με το όνομα 
User με δύο πεδία, Name και Age. Στην συνέχεια, δημιουργείστε μια τιμή του 
τύπου User και περάστε την τιμή στην γενική συνάρτηση marshal.

.play generics/basics/exercise1.go 
.play generics/basics/answer1.go
