Αποσύνδεση
Η σύνθεση τύπων πάει πιο μακριά από τον μηχανισμό ενσωμάτωσης τύπων και είναι κάτι περισσότερο από ένα απλό πρότυπο. 

* Αποσύνδεση

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιείστε το σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Ο καλύτερος τρόπος για να εκμεταλλευτεί κανείς την ενσωμάτωση τύπων είναι μέσω 
του πρότυπου σχετικά με τον συνθετικό σχεδιασμό. Πρόκειται για το κλειδί όσον αφορά την 
διατήρηση της σταθερότητας του λογισμικού, καθώς προσδίδει την ικανότητα της 
προσαρμογής στις αλλαγές των μετασχηματισμών δεδομένων, που αναμένονται στο μέλλον. 

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1:* Σύνθεση Struct 
- *Παράδειγμα* *2:* Αποσύνδεση με Διεπαφή
- *Παράδειγμα* *3:* Σύνθεση Διεπαφών 
- *Παράδειγμα* *4:* Αποσύνδεση με Σύνθεση Διεπαφών 
- *Παράδειγμα* *5:* Απομάκρυνση Μόλυνσης Διεπαφών 
- *Παράδειγμα* *6:* Περισσότερο Ακριβές API

.play composition/decoupling/example1.go
.play composition/decoupling/example2.go
.play composition/decoupling/example3.go
.play composition/decoupling/example4.go
.play composition/decoupling/example5.go
.play composition/decoupling/example6.go

** Μηχανισμός Αποσύνδεσης 

Η ιδέα είναι η σύνθεση μεγαλύτερων τύπων από μικρότερους και με έμφαση στην σύνθεση της 
συμπεριφοράς. 

    type Xenia struct {
        Host    string
        Timeout time.Duration
    }

    func (*Xenia) Pull(d *Data) error {
        switch rand.Intn(10) {
        case 1, 9:
            return io.EOF
        case 5:
            return errors.New("Error reading data from Xenia")
        default:
            d.Line = "Data"
            fmt.Println("In:", d.Line)
            return nil
        }
    }

Ο τύπος Xenia αντιπροσωπεύει ένα σύστημα από το οποίο κανείς, χρειάζεται να αντλεί 
στοιχεία. Η υλοποίηση δεν έχει σημασία. Αυτό που έχει σημασία είναι ότι, η μέθοδος 
τύπου Pull μπορεί να επιτύχει, να αποτύχει ή να μην έχει καθόλου δεδομένα τα οποία 
να μπορούν να αντληθούν

    type Pillar struct {
        Host    string
        Timeout time.Duration
    }

    func (*Pillar) Store(d *Data) error {
        fmt.Println("Out:", d.Line)
        return nil
    }

Ο τύπος Pillar αντιπροσωπεύει ένα σύστημα στο οποίο κανείς αποθηκεύει δεδομένα. Αυτό 
που σημασία είναι, πάλι, ότι η μέθοδος Store μπορεί να επιτύχει ή να αποτύχει.

Οι παραπάνω δύο τύποι αντιπροσωπεύουν ένα πρωτεύον επίπεδο κώδικα που παρέχει την 
βασική συμπεριφορά η οποία απαιτείται, για την επίλυση του πρακτικού προβλήματος 
ανάσυρσης δεδομένων από τον Xenia και αποθήκευσης αυτών των δεδομένων στον Pillar.

    func Pull(x *Xenia, data []Data) (int, error) {
        for i := range data {
            if err := x.Pull(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

    func Store(p *Pillar, data []Data) (int, error) {
        for i := range data {
            if err := p.Store(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

Το επόμενο επίπεδο του κώδικα αποτελείται από τις παραπάνω δύο συναρτήσεις, την Pull
και την Store. Βασίζονται επάνω στο προηγούμενο επίπεδο κώδικα με το να δέχονται μια 
συλλογή τιμών δεδομένων, από την οποία μπορούν να προμηθευτούν (Pull) ή να της τα παρέχουν 
(Store) από τα αντίστοιχα συστήματα. Αυτές οι συναρτήσεις επικεντρώνονται στους πραγματικούς
τύπους Xenia και Pillar καθώς αυτά είναι τα συστήματα με τα οποία το πρόγραμμα χρειάζεται να 
συνεργαστεί στην παρούσα στιγμή. 

    func Copy(sys *System, batch int) error {
        data := make([]Data, batch)

        for {
            i, err := Pull(&sys.Xenia, data)
            if i > 0 {
                if _, err := Store(&sys.Pillar, data[:i]); err != nil {
                    return err
                }
            }

            if err != nil {
                return err
            }
        }
    }

Η συνάρτηση Copy βασίζεται στις συναρτήσεις Pull και Store προκειμένου να μεταφέρει 
όλα τα δεδομένα, που αναμένουν μεταφορά, σε καθε δεδομένη εκτέλεση. Αν παρατηρήσει κανείς,
την πρώτη παράμετρο στην Copy, αυτή πρόκειται για ένα τύπο με το όνομα System.

    type System struct {
        Xenia
        Pillar
    }

Η αρχική ιδέα πίσω από έναν τύπο σαν το System είναι η σύνθεση ενός συστήματος που γνωρίζει 
πως να πραγματοποιεί Pull και Store. Στην παρούσα περίπτωση, αυτό που χρειάζεται να γνωρίζει 
το σύστημα είναι η δυνατότητα των Pull και Store από τους Xenia και Pillar.

    func main() {
        sys := System{
            Xenia: Xenia{
                Host:    "localhost:8000",
                Timeout: time.Second,
            },
            Pillar: Pillar{
                Host:    "localhost:9000",
                Timeout: time.Second,
            },
        }

        if err := Copy(&sys, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Τέλος, η συνάρτηση main μπορεί να χρησιμοποιηθεί για την κατασκευή μιας τιμής Xenia και μιας
τιμής Pillar εντός της σύνθεσης μιας τιμής System. Στην συνέχεια, η System μπορεί να περάσει 
στην συνάρτηση Copy και τα δεδομένα μπορούν να αρχίσουν να ρέουν μεταξύ των δύο συστημάτων. 

Με όλο αυτόν το κώδικα, κανείς έχει μια πρώτη εκδοχή, μιας πραγματικής λύσης σε ένα πραγματικό 
πρόβλημα.

** Αποσύνδεση με Διεπαφές

Το επόμενο βήμα είναι να κατανοήσει κανείς, τι θα μπορούσε να αλλάξει στο πρόγραμμα. 
Σε αυτή την περίπτωση, αυτό που μπορεί να αλλάξει, είναι τα ίδια τα συστήματα. Την 
δεδομένη στιγμή πρόκειται για τους Xenia και Pillar, κάποια άλλη στιγμή μπορεί αυτά 
να είναι οι Alice και Bob. Με αυτή την γνώση, κανείς θέλει να αποσυνδέσει την υπάρχουσα 
πραγματική λύση από αυτή την αναμενόμενη αλλαγή. Προκειμένου να συμβεί αυτό, κανείς 
χρειάζεται να μετατρέψει τις πραγματικές συναρτήσεις σε πολυμορφικές συναρτήσεις. 

    func Pull(p Puller, data []Data) (int, error) {
        for i := range data {
            if err := p.Pull(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

    func Store(s Storer, data []Data) (int, error) {
        for i := range data {
            if err := s.Store(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

Στην τρέχουσα υλοποίηση, η συνάρτηση Pull δέχεται μια τιμή Xenia και η συνάρτηση Store 
αποδέχεται μια τιμή Pillar. Ουσιαστικά, δεν ήταν οι Xenia και Pillar αυτό που ήταν σημαντικό, 
αλλά η πραγματική τιμή, που γνωρίζει πως να επιδεικνύει τις συμπεριφορές Pull και Store. Οι 
συναρτήσεις αυτές μπορούν να αλλάξουν και να γίνουν πολυμορφικές, ζητώντας δεδομένα 
με βάση το τι μπορούν να κάνουν, αντί για το τι είναι.

    type Puller interface {
        Pull(d *Data) error
    }

    type Storer interface {
        Store(d *Data) error
    }

Οι δύο παραπάνω διεπαφές περιγράφουν τι πρέπει να μπορούν να κάνουν τα πραγματικά 
δεδομένα και είναι αυτοί οι τύποι, που πρέπει να αντικατασταθούν, στην θέση των 
υπάρχοντων, στις δηλώσεις των συναρτήσεων Pull και Store. Με αυτή την αντικατάσταση,
αυτές οι συναρτήσεις γίνονται πολυμορφικές. Όταν οι Alice και Bob δηλωθούν και 
υλοποιηθούν ως Puller και Storer, τότε μπορούν να περάσουν στις συναρτήσεις. 

Δεν έχει ολοκληρωθεί η αλλαγή, ακόμα. Πρέπει να γίνει πολυμορφική και η συνάρτηση Copy.

    func Copy(ps PullStorer, batch int) error {
        data := make([]Data, batch)

        for {
            i, err := Pull(ps, data)
            if i > 0 {
                if _, err := Store(ps, data[:i]); err != nil {
                    return err
                }
            }

            if err != nil {
                return err
            }
        }
    }

Η συνάρτηση Copy δεν απαιτεί πια μια τιμή System, αλλά την όποια πραγματική τιμή, που γνωρίζει
πως να πραγματοποιεί τόσο Pull όσο και Store.

    type PullStorer interface {
        Puller
        Storer
    }

Η διεπαφή PullStorer δηλώνεται, κάνοντας χρήση της σύνθεσης. Αποτελείται από τις διεπαφές
Puller και Storer. Η δουλειά που γίνεται είναι η σύνθεση μεγαλύτερων διεπαφών από 
μικρότερες. 

Μπορεί να παρατηρήσει κανείς ότι, η μεταβλητή PullStorer περνάει στις συναρτήσεις Pull και
Store. Πως είναι κάτι τέτοιο δυνατό, όταν η πληροφορία τύπου είναι διαφορετική; 

    // func Pull(p Puller, data []Data) (int, error) {
    i, err := Pull(ps, data)

    // func Store(s Storer, data []Data) (int, error) {
    if _, err := Store(ps, data[:i]); err != nil {

Κανείς, πρέπει να θυμάται πάντα ότι, δεν περνάει μια τιμή διεπαφής γύρω στο πρόγραμμα, 
καθώς δεν υπάρχουν και δεν έχουν τιμή. Αυτό που μετακινείται, είναι τα πραγματικά 
δεδομένα. Επομένως, τα πραγματικά δεδομένα που βρίσκονται αποθηκευμένα εντός της 
μεταβλητής διεπαφής ps, είναι εκείνα που περνάνε στις Pull και Store. Δεν είναι 
αληθές ότι η πραγματική τιμή, που είναι αποθηκευμένη εντός της ps, πρέπει να γνωρίζει 
πως να πραγματοποιήσει Pull και Store;

.image /tour/grc/static/img/comp1.png

Εφόσον ο System αποτελείται από έναν Xenia και έναν Pillar, ο System υλοποιεί την 
διεπαφή PullStorer. Με αυτές τις αλλαγές, κανείς, μπορεί τώρα να δημιουργήσει νέους 
πραγματικούς τύπους, που υλοποιούν την διεπαφή PullStorer.

    type System1 struct {
        Xenia
        Pillar
    }

    type System2 struct {
        Alice
        Bob
    }

    type System3 struct {
        Xenia
        Bob
    }

    type System4 struct {
        Alice
        Pillar
    }

Όταν το σκεφτεί κανείς, λίγο καλύτερα, οι δηλώσεις διαφορετικών τύπων System για όλους 
πιθανούς συνδυασμούς, δεν είναι ένα ρεαλιστικό ενδεχόμενο. Σίγουρα θα λειτουργήσει, όμως 
ο εφιάλτης της συντήρησης, σε ένα τέτοιο ενδεχόμενο, απαιτεί μια καλύτερη λύση 

** Σύνθεση Διεπαφών

Τι θα συνέβαινε, αν κανείς αποφάσιζε, να συνθέσει τον πραγματικό τύπο System, από δύο τύπους 
διεπαφών;

    type System struct {
        Puller
        Storer
    }

Αυτή είναι μια ενδιαφέρουσα λύση. Κάτι τέτοιο, θα επέτρεπε στην εφαρμογή, να εισάγει τους 
πραγματικούς Puller ή Storer στο System, κατά την έναρξη λειτουργίας της εφαρμογής. 

    func main() {
        sys := System{
            Puller: &Xenia{
                Host:    "localhost:8000",
                Timeout: time.Second,
            },
            Storer: &Pillar{
                Host:    "localhost:9000",
                Timeout: time.Second,
            },
        }

        if err := Copy(&sys, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Αυτός ο μοναδικός τύπος System, υλοποιεί την διεπαφή PullStorer, για όλους τους πιθανούς 
συνδυασμούς πραγματικών τύπων.

.image /tour/grc/static/img/comp2.png

Με αυτή την αλλαγή, η εφαρμογή είναι πλήρως αποσυνδεδεμένη από αλλαγές, σε κάποιο νέο System
που μπορεί να λειτουργήσει στο μέλλον.

** Επισκόπηση Ακρίβειας

Η επόμενη ερώτηση που πρέπει να ρωτήσει κανείς είναι, αν είναι οι πολυμορφικές συναρτήσεις 
τόσο ακριβείς, όσο θα μπορούσαν διαφορετικά να είναι; Αυτό είναι μέρος της διαδικασίας του
σχεδιασμού που δεν μπορεί να παραληφθεί. Η απάντηση είναι όχι, μπορούν να γίνουν δύο 
αλλαγές. 

    func Copy(sys *System, batch int) error {

Η συνάρτηση Copy δεν χρειάζεται να είναι πολυμορφική πια, καθώς θα υπάρχει ένας μόνο τύπος 
System. Η διεπαφή PullStorer μπορεί να απομακρυνθεί από το πρόγραμμα. Αξίζει να θυμηθεί 
κανείς ότι, ο πολυμορφισμός μεταφέρθηκε εντός του τύπου, όταν έγινε η χρήση της σύνθεσης 
με την χρήση των τύπων διεπαφής.

    func Copy(p Puller, s Storer, batch int) error {

Αυτή είναι άλλη μια αλλαγή που μπορεί να γίνει στην συνάρτηση Copy. Αυτή η αλλαγή 
κάνει την συνάρτηση περισσότερο ακριβή και πολυμορφική ξανά. Τώρα η συνάρτηση 
ζητάει ακριβώς ό,τι χρειάζεται, με βάση του τι είναι ικανά να κάνουν τα πραγματικά
δεδομένα.

.image /tour/grc/static/img/comp3.png

Με αυτή την αλλαγή, ο τύπος struct System μπορεί επίσης, να απομακρυνθεί από το πρόγραμμα. 

    func main() {
        x := Xenia{
            Host:    "localhost:8000",
            Timeout: time.Second,
        }

        p := Pillar{
            Host:    "localhost:9000",
            Timeout: time.Second,
        }

        if err := Copy(&x, &p, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Απομακρύνοντας τους τύπους PullStorer και System, απλοποιείται το πρόγραμμα. Η συνάρτηση main
μπορεί να επικεντρωθεί στην κατασκευή των πραγματικών τιμών Puller και Storer, οι οποίες είναι
απαραίτητες για την μετακίνηση των δεδομένων. Το σύστημα τύπων και τα API είναι περισσότερο ακριβή.
Η ιδέα της ακρίβειας προέρχεται από τον Edsger W. Dijkstra

"Ο σκοπός της αφαίρεσης δεν είναι η ασάφεια, αλλά η δημιουργία ενός καινούργιου σημειολογικού επιπέδου 
 εντός του οποίου κανείς μπορεί να είναι απολύτως ακριβής."- Edsger W. Dijkstra

** Σημειώσεις 

- Πρόκειται για πολύ περισσότερα από τον μηχανισμό της ενσωμάτωσης τύπων.
- Πρέπει οι τύποι να δηλώνονται και να υλοποιούνται ροές εργασιών με την σκέψη στην σύνθεση.
- Πρέπει πρώτα να γίνεται κατανοητό το πρόβλημα που προσπαθεί να λύσει. Αυτό σημαίνει κατανόηση των δεδομένων.
- Ο σκοπός είναι να μειωθούν και να ελαχιστοποιηθούν αλληλοσυνδεόμενες αλλαγές στο λογισμικό.
- Οι διεπαφές παρέχουν την υψηλότερη μορφή σύνθεσης.
- Οι τύποι δεν πρέπει να ομαδοποιούνται από το κοινό τους DNA αλλά από την κοινή τους συμπεριφορά.
- Όλοι μπορούν να συνεργαστούν μεταξύ τους όταν δίνεται έμφαση σε αυτά που μπορούν να κάνουν και όχι σε αυτό που είναι.

** Παραθέσεις

"Ένα καλό API δεν είναι μόνο εύκολο προς χρήση αλλά και δύσκολο να χρησιμοποιηθεί λανθασμένα." - JBD

"Κανείς μπορεί πάντα να ενσωματώσει, όμως δεν γίνεται να αποσυνθέσει μεγάλες διεπαφές από την στιγμή που βρεθούν εκεί έξω. Οι διεπαφές πρέπει να είναι μικρές." - JBD

"Δεν πρέπει να σχεδιάζει κανείς με διεπαφές, αλλά πρέπει να τις ανακαλύπτει." - Rob Pike

"Ο διπλασιασμός εξαιτίας αντιγραφής είναι πολύ φθηνότερος από μια εσφαλμένη αφαίρεση. - Sandi Metz

** Οδηγίες Σχεδίασης

Μάθετε για τις [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#interface-and-composition-design][οδηγίες σχεδίασης]] σχετικά με την σύνθεση.

** Πρόσθετα Αναγνώσματα

- [[https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and][Επανέλαβε τον εαυτό σου, κάνε περισσότερα από ένα πράγματα, και ξαναγράψε τα πάντα]] - tef  
- [[https://golang.org/doc/effective_go.html#embedding][Ενσωμάτωση]]   
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Μέθοδοι τύπων, Διεπαφές και Ενσωμάτωση]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2015/09/composition-with-go.html][Σύνθεση τύπων στην Go]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2016/10/reducing-type-hierarchies.html][Ανάγοντας Ιεραρχίες Τύπων]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2016/10/avoid-interface-pollution.html][Αποφεύγοντας την επιμόλυνση Διεπαφών]] - William Kennedy 

* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

Χρησιμοποιώντας το πρότυπο, δηλώστε ένα σύνολο πραγματικών τύπων που υλοποιούν ένα σύνολο 
προκαθορισμένων τύπων διεπαφών. Στην συνέχεια, δημιουργείστε τιμές αυτών των τύπων και 
χρησιμοποιείστε τις προκειμένου να ολοκληρώσετε ένα σύνολο από προκαθορισμένες ενέργειες.

.play composition/decoupling/exercise1.go
.play composition/decoupling/answer1.go
