Φέτες
Οι φέτες (slices) είναι μια τρομερά σημαντική δομή δεδομένων στην Go. Αποτελούν την βάση του πως γίνεται η διαχείριση και η χρήση των δεδομένων με ένα τρόπο που είναι ευέλικτος, αποτελεσματικός και δυναμικός. Είναι πολύ ευεργετικό για όλους τους προγραμματιστές της Go να γνωρίζουν πως λειτουργούν οι φέτες, και πως να τις χρησιμοποιούν.

* Φέτες

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εάν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιήστε το Σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Οι φέτες είναι μια τρομερά σημαντική δομή δεδομένων στην Go. Αποτελούν την βάση του πως γίνεται η διαχείριση και η χρήση των δεδομένων με ένα τρόπο 
που είναι ευέλικτος, αποτελεσματικός και δυναμικός. Είναι πολύ ευεργετικό για όλους τους προγραμματιστές της Go να γνωρίζουν πως λειτουργούν οι φέτες, και 
πως να τις χρησιμοποιούν.

.image /tour/grc/static/img/sl1.png

** Επισκόπηση Κώδικα 

- *Example* *1:* Δήλωση και Μήκος 
- *Example* *2:* Τύποι Αναφορών
- *Example* *3:* Προσθέτοντας σε φέτες
- *Example* *4:* Λαμβάνοντας φέτες φετών
- *Example* *5:* Φέτες και Αναφορές 
- *Example* *6:* Συμβολοσειρές και φέτες
- *Example* *7:* Συναρτήσεις με μεταβλητό πλήθος ορισμάτων 
- *Example* *8:* Μηχανισμός range
- *Example* *9:* Αποτελεσματικές Διελεύσεις
- *Example* *10:* Δημιουργία Φετών Τριών Δεικτών 

.play slices/example1.go
.play slices/example2.go
.play slices/example3.go
.play slices/example4.go
.play slices/example5.go
.play slices/example6.go
.play slices/example7.go
.play slices/example8.go
.play slices/example9.go 
.play slices/example10.go

** Δημιουργία Φετών

Η δημιουργία μιας φέτας μπορεί να γίνει με διάφορους τρόπους.

    // Φέτα συμβολοσειράς που λαμβάνει την κατάσταση μηδενική τιμής.
    var slice []string

    // Φέτα συμβολοσειράς που λαμβάνει την κενή κατάσταση της.
    slice := []string{}

    // Φέτα συμβολοσειράς που δημιουργείται με μήκος και χωρητικότητα 5.
    slice := make([]string, 5)

    // Φέτα συμβολοσειράς που δημιουργείται με μήκος 5 και χωρητικότητα 8.
    slice := make([]string, 5, 8)

    // Φέτα συμβολοσειράς που δημιουργείται με τιμές, με μήκος και χωρητικότητα 5.
    slice := []string{"A", "B", "C", "D", "E"}

Είναι εμφανές, ότι η προεγκατεστημένη συνάρτηση make επιτρέπει την εκχώρηση από πριν, τόσο του μήκους όσο και της χωρητικότητας για τον υποστηρικτικό πίνακα. 
Αν ο μεταγλωττιστής γνωρίζει το μέγεθος, στο στάδιο της μεταγλώττισης, ο υποστηρικτικός πίνακας μπορεί να δημιουργηθεί στην στοίβα.

** Μήκος Φέτας αντί Χωρητικότητας

Το μήκος μιας φέτας αναφέρεται στο πλήθος των διαθέσιμων στοιχείων, που μπορούν να διαβαστούν και να γραφούν. 
Η χωρητικότητα αναφέρεται στο σύνολο των στοιχείων, που υπάρχουν στον υποστηρικτικό πίνακα, από αυτή την θέση δείκτη διεύθυνσης.

Εξαιτίας διευκολύνσεων στο συντακτικό, οι φέτες εμφανίζονται και δίνουν την αίσθηση πινάκων.

    slice := make([]string, 5)
    slice[0] = "Apple"
    slice[1] = "Orange"
    slice[2] = "Banana"
    slice[3] = "Grape"
    slice[4] = "Plum"

Είναι δυνατόν να ξεχωρίσει κανείς ανάμεσα στην δημιουργία μιας φέτας και ενός απλού πίνακα, επειδή ο πίνακας
έχει γνωστό μέγεθος κατά το στάδιο της μεταγλώττισης, ενώ οι φέτες απαραίτητα δεν έχουν.

Αν κανείς προσπαθήσει να προσπελάσει ένα στοιχείο, πέρα από το μήκος της φέτας, θα λάβει σφάλμα εκτέλεσης.

    slice := make([]string, 5)
    slice[5] = "Raspberry"

Σφάλμα Μεταγλωττιστή:

    Error: panic: runtime error: index out of range slice[5] = "Runtime error"

Σε αυτό το παράδειγμα, το μήκος της φέτας είναι 5, ενώ γίνεται προσπάθεια να προσπελαστεί το έκτο στοιχείο, 
το οποίο δεν υπάρχει.

** Σημειολογικές Κατευθύνσεις Δεδομένων Για Φέτες

Σαν μια υπόδειξη, αν τα δεδομένα με τα οποία δουλεύει κανείς είναι μια φέτα, τότε μπορεί να χρησιμοποιήσει σημειολογία τιμής 
για να μετακινήσει δεδομένα γύρω στο πρόγραμμα. Κάτι τέτοιο περιλαμβάνει και δηλώσεις πεδίων, σε ένα τύπο. 

    func Foo(data []byte) []byte

    type Foo struct {
        X []int
        Y []string
        Z []bool
    }

Αυτό ισχύει για όλες τις εσωτερικές δομές δεδομένων της Go (φέτες (στμ. slices), πίνακες κατακερματισμού (στμ. maps), κανάλια επικοινωνίας 
(στμ. channels), διεπαφές (στμ. interfaces) και συναρτήσεις (στμ. functions)).

Ενας λόγος να γυρίσει κανείς σε σημειολογία δείκτών διευθύνσεων είναι αν χρειάζεται να μοιραστεί την φέτα για μια λειτουργία 
αποκωδικοποίησης ή αποσειριοποίησης (στμ. unmarshaling). Η χρήση δεικτών διευθύνσεων για αυτούς τους τύπους των εργασιών είναι ok, όμως είναι καλό 
να υπάρχει σχετική καταγραφή της χρήσης τους, όπου αυτό δεν είναι εμφανές.

** Συνεχόμενη Διάταξη Μνήμης

Η ιδέα πίσω από την φέτα είναι να υπάρχει ένας πίνακας, που είναι η πιο 
αποτελεσματική δομή δεδομένων, καθώς σχετίζεται με το υλικό. Όμως κανείς χρειάζεται ακόμα 
την δυνατότητα να είναι δυναμικός και αποτελεσματικός με την ποσότητα των δεδομένων που χρειάζονται 
κατά την εκτέλεση και την όποια μελλοντική μεγέθυνση.

    func main() {
        slice := make([]string, 5, 8)
        slice[0] = "Apple"
        slice[1] = "Orange"
        slice[2] = "Banana"
        slice[3] = "Grape"
        slice[4] = "Plum"

        inspectSlice(slice)
    }

    func inspectSlice(slice []string) {
        fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
        for i := range slice {
            fmt.Printf("[%d] %p %s\n", i, &slice[i], slice[i])
        }
    }

Αποτέλεσμα:

    Length[5] Capacity[8]
    [0] 0xc00007e000 Apple
    [1] 0xc00007e010 Orange
    [2] 0xc00007e020 Banana
    [3] 0xc00007e030 Grape
    [4] 0xc00007e040 Plum

Η συνάρτηση inspectSlice παρουσιάζει πως μια φέτα, πράγματι, έχει 
έναν συνεχόμενο υποστηρικτικό πίνακα, με προβλέψιμο βήμα. Δείχνει ακόμα πως
μια φέτα έχει μήκος και χωρητικότητα, τα οποία μπορούν να διαφέρουν. 
Αξίζει να παρατηρήσει κανείς ότι, η συνάρτηση εκτύπωσης διατρέχει το μήκος μιας φέτας.

** Προσθέτοντας σε φέτες

Η γλώσσα παρέχει την προεγκατεστημένη συνάρτηση append, για την προσθήκη τιμών, σε 
υπάρχουσα φέτα.

    var data []string

    for record := 1; record <= 102400; record++ {
        data = append(data, fmt.Sprintf("Rec: %d", record))
    }

Η συνάρτηση append λειτουργεί με μια φέτα, ακόμα και όταν η φέτα
έχει λάβει ως αρχική κατάσταση, την κατάσταση μηδενικής τιμής. Ο σχεδιασμός API της append είναι 
αυτό που είναι ενδιαφέρον, επειδή χρησιμοποιεί μετατροπή σημειολογίας τιμής. Η 
append λαμβάνει το δικό της αντίγραφο μιας τιμής φέτας, μετατρέπει το δικό της 
αντίγραφο και στην συνέχεια επιστρέφει ένα αντίγραφο, στον καλώντα.

Για ποιό λόγο έχει γίνει ο σχεδιασμός API κατ' αυτό τον τρόπο; Αυτό συμβαίνει, διότι είναι
χαρακτηριστικό της γλώσσας να γίνεται χρήση σημειολογίας τιμής, για την μετακίνηση μιας φέτας
γύρω σε ένα πρόγραμμα. Αυτό πρέπει να γίνει σεβαστό ακόμα και σε μια 
λειτουργία μετατροπής. Επιπλέον, η μετατροπή με σημειολογία τιμής, είναι ο ασφαλέστερος τρόπος 
να γίνει η μετατροπή, καθώς η μετατροπή πραγματοποιείται στο αντίγραφο που διατηρεί η συνάρτηση 
των δεδομένων, σε απομόνωση.

Η append πάντα διατηρεί ένα συνεχόμενο τμήμα μνήμης για τον υποστηρικτικό πίνακα μιας φέτας, 
ακόμα και ύστερα από μια μεγέθυνση. Αυτό είναι σημαντικό, για το υλικό.

.image /tour/grc/static/img/sl2.png

Κάθε φορά που καλείται η συνάρτηση append, η συνάρτηση ελέγχει αν το μήκος και η χωρητικότητα 
μιας φέτας είναι τα ίδια ή όχι. Αν είναι τα ίδια, αυτό σημαίνει ότι δεν υπάρχει 
χώρος στον υποστηρικτικό πίνακα για μια νέα τιμή. Σε αυτή την περίπτωση, η append δημιουργεί 
έναν νέο υποστηρικτικό πίνακα (διπλασιάζοντας ή μεγεθύνοντας τον κατά 25%) και στην συνέχεια 
αντιγράφει τις τιμές από τον παλιό πίνακα στον καινούργιο. Στην συνέχεια, η νέα τιμή μπορεί 
να προστεθεί.

.image /tour/grc/static/img/sl3.png

Αν δεν είναι τα ίδια, αυτό σημαίνει ότι υπάρχει κάποιο επιπλέον στοιχείο χωρητικότητας για την 
προσθήκη. Αφαιρείται έτσι ένα στοιχείο από την χωρητικότητα και προστίθεται στο μήκος μιας φέτας.
Αυτό καθιστά την λειτουργία της append πολύ αποτελεσματική.

Όταν ο υποστηρικτικός πίνακας έχει 1024 στοιχεία χωρητικότητας ή λιγότερα, δημιουργείται νέος 
υποστηρικτικός πίνακας, διπλασιάζοντας το μέγεθος του υπάρχοντα πίνακα. Όταν ο υποστηρικτικός πίνακας 
γίνει μεγαλύτερος από 1024, η μεγέθυνση γίνεται στο 25%. 

*ΣΗΜΕΙΩΣΗ:* *Ο* *τρόπος* *που* *η* *συνάρτηση* *append* *μεγεθύνει* *την* *χωρητικότητα* *του* 
*υποστηρικτικού* *πίνακα* *έχει* *αλλάξει* *από* *την* *Go* *1.18.*

- [[https://tip.golang.org/doc/go1.18#runtime][https://tip.golang.org/doc/go1.18#runtime]]

** Φέτες από Φέτες 

Οι φέτες δίνουν την δυνατότητα αποφυγής δημιουργίας επιπλέον αντιγράφων και εκχωρήσεων στον σωρό για τον 
υποστηρικτικό πίνακα, όταν είναι αναγκαίο να απομονωθούν κάποια στοιχεία του υποστηρικτικού πίνακα, για
διαφορετικές λειτουργίες.

Το συντακτικό διαμέρισης (στμ. που δημιουργεί μια φέτα) παριστάνει η σειρά [a:b) που σημαίνει: 
να συμπεριληφθούν τα στοιχεία από τον δείκτη a έως τον δείκτη b, χωρίς όμως να συμπεριληφθεί το στοιχείο, 
που αντιστοιχεί στον δείκτη b.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]

Η μεταβλητή slice2 είναι μια νέα τιμή φέτας, που τώρα μοιράζεται τον ίδιο υποστηρικτικό πίνακα 
που χρησιμοποιεί και η slice1. Όμως η slice2 επιτρέπει μόνο την πρόσβαση στα στοιχεία των δεικτών 2 και 3 
(τα C και D) του υποστηρικτικού πίνακα, της αρχικής φέτας. Το μήκος της slice2 είναι 2 και όχι 5 
όπως της slice1 και η χωρητικότητα είναι 3, επειδή τώρα υπάρχουν 3 στοιχεία από αυτή την θέση δείκτη διεύθυνσης.

.image /tour/grc/static/img/sl4.png

Ένας καλύτερος τρόπος να σκεφτεί κανείς την διαδικασία διαμέρισης είναι να επικεντρωθεί στο μήκος, χρησιμοποιώντας 
την σημειογραφία [a:a+len] που συμπεριλαμβάνει τον δείκτη a έως τον δείκτη a, συν το μήκος. Αυτή η προσέγγιση θα 
μειώσει τα σφάλματα στον υπολογισμό των νέων φετών. 

Χρησιμοποιώντας την παρακάτω συνάρτηση επιθεώρησης:

    func inspectSlice(slice []string) {
        fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
        for i, s := range slice {
            fmt.Printf("[%d] %p %s\n",
                i,
                &slice[i],
                s)
        }
    }

Κανείς μπορεί να διαπιστώσει τα παραπάνω, στην πράξη:

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    inspectSlice(slice1)
    inspectSlice(slice2)

Αποτέλεσμα:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[3]
    [0] 0xc00007e020 C     <-- ΙΔΙΟ ΟΠΩΣ ΣΤΟΝ ΔΕΙΚΤΗ 2 ΣΤΗΝ ΦΕΤΑ 1
    [1] 0xc00007e030 D     <-- ΙΔΙΟ ΟΠΩΣ ΣΤΟΝ ΔΕΙΚΤΗ 3 ΣΤΗΝ ΦΕΤΑ 1

Κανείς παρατηρεί πως οι δύο διαφορετικές φέτες μοιράζονται τον ίδιο υποστηρικτικό πίνακα. Αυτό 
διαπιστώνεται αν συγκριθούν οι διευθύνσεις.

Το καλό εδώ είναι, ότι δεν υπάρχουν εκχωρήσεις μνήμης. Ο μεταγλωττιστής γνωρίζει το μέγεθος του υποστηρικτικού 
πίνακα για την slice1, κατά τον χρόνο μεταγλώττισης. Περνώντας ένα αντίγραφο της τιμής της φέτας στην
συνάρτηση inspectSlice, διατηρούνται τα πάντα στην στοίβα.

** Μετατροπές στον Υποστηρικτικό Πίνακα 

Όταν κανείς χρησιμοποιεί την slice2 για να αλλάξει την τιμή της συμβολοσειράς στον δείκτη 0, όποια τιμή φέτας
μοιράζεται τον ίδιο υποστηρικτικό πίνακα (όπου η διεύθυνση για αυτόν τον δείκτη είναι μέρος του μήκους της
φέτας) θα δει την αλλαγή.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    slice2[0] = "CHANGED"
    inspectSlice(slice1)
    inspectSlice(slice2)

Αποτέλεσμα:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 CHANGED
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[3]
    [0] 0xc00007e020 CHANGED
    [1] 0xc00007e030 D

Κανείς πρέπει να είναι σε θέση να αναγνωρίσει, πότε θα μεταβάλλει μια τιμή σε κάποια θέση δείκτη, αν ο
υποστηρικτικός πίνακας μοιράζεται με άλλη φέτα.

.image /tour/grc/static/img/sl5.png

Τι θα συμβεί αν γίνει χρήση της προεγκατεστημένης συνάρτησης append;

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    slice2 = append(slice2, "CHANGED")
    inspectSlice(slice1)
    inspectSlice(slice2)

Αποτέλεσμα:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 CHANGED
    Length[3] Capacity[3]
    [0] 0xc00007e020 C
    [1] 0xc00007e030 D
    [2] 0xc00007e040 CHANGED

Η συνάρτηση append δημιουργεί το ίδιο παράπλευρο αποτέλεσμα, το οποίο όμως δεν είναι εμφανές. 
Σε αυτή την περίπτωση, φέρνοντας περισσότερο μήκος από τη χωρητικότητα για την slice2, προκαλεί 
την αλλαγή της τιμής στην διεύθυνση 0xc00007e040. Δυστυχώς, η φέτα slice1 είχε αυτή 
την διεύθυνση, ήδη ως μέρος του μήκους της.

.image /tour/grc/static/img/sl6.png

Ένας τρόπος να αποτραπεί αυτή η παρενέργεια, είναι η χρήση διαμέρισης με τρεις δείκτες στην δημιουργία 
της slice2, ώστε το μήκος και η χωρητικότητα να είναι τα ίδια στον δείκτη 2.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4:4]
    inspectSlice(slice1)
    inspectSlice(slice2)

Αποτέλεσμα:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[2]
    [0] 0xc00007e020 C
    [1] 0xc00007e030 D

Το συντακτικό διαμέρισης (στμ. που δημιουργεί μια φέτα) είναι [a:b:c] όταν τα b και c πρέπει να είναι τα ίδια
καθώς το [a-b] θέτει το μήκος και το [a-c] θέτει την χωρητικότητα. Τώρα, το μήκος και η χωρητικότητα της slice2 είναι τα ίδια.

Τώρα, μπορεί να χρησιμοποιηθεί η προεγκατεστημένη συνάρτηση append, ξανά όπως πριν:

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4:4]
    slice2 = append(slice2, "CHANGED")
    inspectSlice(slice1)
    inspectSlice(slice2)

Αποτέλεσμα:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[3] Capacity[4]
    [0] 0xc000016080 C
    [1] 0xc000016090 D
    [2] 0xc0000160a0 CHANGED

Παρατηρεί κανείς ότι μετά την κλήση στην append, η slice2 αποκτά ένα νέο υποστηρικτικό πίνακα.

.image /tour/grc/static/img/sl7.png

Αυτό γίνεται εμφανές, συγκρίνοντας τις διευθύνσεις της κάθε φέτας. Σε αυτή την περίπτωση,
η μεταβολή στην slice2 δεν προκάλεσε καμία παρενέργεια στην slice1.

** Αντιγραφή Φετών Χειροκίνητα

Υπάρχει μια προεγκατεστημένη συνάρτηση με το όνομα copy, που επιτρέπει την ρηχή αντιγραφή φετών. 
Καθώς μια συμβολοσειρά έχει ένα υποστηρικτικό πίνακα από byte, που είναι αμετάβλητος, μπορεί να
χρησιμοποιηθεί ως πηγή, όμως ποτέ ως προορισμός.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice3 := make([]string, len(slice1))
    copy(slice3, slice1)

    inspectSlice(slice1)
    inspectSlice(slice3)

Αποτέλεσμα:

    Length[5] Capacity[5]
    [0] 0xc00005c050 A
    [1] 0xc00005c060 B
    [2] 0xc00005c070 C
    [3] 0xc00005c080 D
    [4] 0xc00005c090 E
    Length[5] Capacity[5]
    [0] 0xc00005c0a0 A
    [1] 0xc00005c0b0 B
    [2] 0xc00005c0c0 C
    [3] 0xc00005c0d0 D
    [4] 0xc00005c0e0 E

Όσο η φέτα προορισμού έχει τον σωστό τύπο και το σωστό μήκος, η προεγκατεστημένη συνάρτηση
copy μπορεί να δημιουργήσει ένα ρηχό αντίγραφο.

** Οι Φέτες Χρησιμοποιούν Μετατροπή Σημειολογίας Δείκτη Διεύθυνσης

Είναι σημαντικό να θυμάται κανείς ότι, παρόλο που χρησιμοποιείται σημειολογία τιμής για την μετακίνηση μιας φέτας
γύρω στο πρόγραμμα, όταν γίνεται ανάγνωση και εγγραφή μιας φέτας, κανείς χρησιμοποιεί
σημειολογία δείκτη διεύθυνσης. Ο διαμοιρασμός των μεμονωμένων στοιχείων μιας φέτας, σε διαφορετικά μέρη του
προγράμματος, μπορεί να δημιουργήσει ανεπιθύμητες παρενέργειες.

    // Δημιουργία φέτας ενός user, εκχώρηση του user σε δείκτη διεύθυνσης,
    // χρήση δείκτη διεύθυνσης για την ανανέωση των like.

    users := make([]user, 1)
    ptrUsr0 := &users[0]
    ptrUsr0.likes++

    for i := range users {
        fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
    }

Αποτέλεσμα:

    User: 0 Likes: 1

Μια φέτα χρησιμοποιείται για την διατήρηση μιας συλλογής από χρήστες. Στην συνέχεια 
ο πρώτος user εκχωρείται σε ένα δείκτη διεύθυνσης, ο οποίος με την σειρά του χρησιμοποιείται, προκειμένου
να ανανεωθούν τα like. Το αποτέλεσμα παρουσιάζει ότι, χρησιμοποιώντας τον δείκτη διεύθυνσης, κάτι τέτοιο, λειτουργεί.

.image /tour/grc/static/img/sl8.png

Στην συνέχεια, ένας νέος user προστίθεται στην συλλογή και ο δείκτης διεύθυνσης χρησιμοποιείται ξανά, για
την πρόσθεση ενός like στον πρώτο user. 

    // Πρόσθεση νέου user στην συλλογή. Χρήση δείκτη διεύθυνσης ξανά
    // για ανανέωση των like.

    users = append(users, user{})
    ptrUsr0.likes++

    for i := range users {
        fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
    }

Αποτέλεσμα:

    User: 0 Likes: 1
    User: 1 Likes: 0

Όμως επειδή η συνάρτηση append αντικαθιστά τον υποστηρικτικό πίνακα με ένα νέο, ο δείκτης διεύθυνσης
ανανεώνει τον παλιό υποστηρικτικό πίνακα και τα like χάνονται. Το αποτέλεσμα παρουσιάζει τα like για 
τον πρώτο χρήστη, τα οποία δεν αυξήθηκαν.

.image /tour/grc/static/img/sl9.png

Κανείς πρέπει να είναι προσεκτικός και να ξέρει, αν η φέτα πρόκειται να χρησιμοποιηθεί σε 
λειτουργία append, στην διάρκεια εκτέλεσης ενός προγράμματος. Ο τρόπος με τον οποίο μοιράζεται κανείς μια φέτα,
πρέπει να λαμβάνεται υπόψη. Το να μοιράζεται κανείς μεμονωμένους δείκτες, μπορεί να μην είναι η
καλύτερη ιδέα. Το να μοιράζεται κανείς ολόκληρη την τιμή της φέτας, μπορεί να μην δουλεύει, εξίσου,
όταν μια λειτουργία είναι η προσθήκη στοιχείων. Πιθανόν, η χρήση μιας φέτας, ως ένα πεδίο σε ένα struct
και η διανομή της τιμής struct, να είναι η καλύτερη επιλογή.

** Αποτελεσματικότητα Γραμμικής Διέλευσης

Η ομορφιά μιας φέτας είναι η δυνατότητα που έχει να επιτρέπει την διενέργεια γραμμικών διελεύσεων, 
οι οποίες είναι μηχανικά συμπαθητικές, ενώ ταυτόχρονα μπορεί να μοιράζεται δεδομένα με σημειολογία τιμής, για να 
ελαχιστοποιήσει τις εκχωρήσεις στον σωρό.

    x := []byte{0x0A, 0x15, 0x0e, 0x28, 0x05, 0x96, 0x0b, 0xd0, 0x0}

    a := x[0]
    b := binary.LittleEndian.Uint16(x[1:3])
    c := binary.LittleEndian.Uint16(x[3:5])
    d := binary.LittleEndian.Uint32(x[5:9])

    Println(a, b, c, d)

Ο κώδικας πραγματοποιεί μια γραμμική διέλευση, δημιουργώντας τιμές φέτας, που διαβάζουν 
διαφορετικά μέρη του πίνακα των byte, από την αρχή μέχρι το τέλος.

.image /tour/grc/static/img/sl10.png

Όλα τα δεδομένα σε αυτό τον κώδικα παραμένουν στην στοίβα. Δεν υπάρχουν επιπλέον αντίγραφα δεδομένων εντός της 
φέτας, που να αντιγράφονται.

** Σημειώσεις

- Οι φέτες με υποστηρικτικούς πίνακες μοιάζουν με δυναμικούς πίνακες με ειδική προεγκατεστημένη λειτουργικότητα.
- Υπάρχει διαφορά ανάμεσα στο μήκος και στην χωρητικότητα μιας φέτας και το κάθε μέγεθος εξυπηρετεί κάποιο σκοπό.
- Οι φέτες επιτρέπουν πολλαπλές "προοπτικές" του ίδιου υποστηρικτικού πίνακα.
- Οι φέτες μπορούν να μεγεθυνθούν με την χρήση της προεγκατεστημένης συνάρτησης append.

** Πρόσθετα Αναγνώσματα

- [[https://blog.golang.org/go-slices-usage-and-internals][Οι Φέτες της Go: χρήση και λειτουργία]] - Andrew Gerrand    
- [[https://blog.golang.org/strings][Συμβολοσειρές, byte, ρούνοι και χαρακτήρες στην Go]] - Rob Pike    
- [[https://blog.golang.org/slices][Πίνακες, φέτες (και συμβολοσειρές): Ο μηχανισμός της 'append']] - Rob Pike        
- [[https://www.ardanlabs.com/blog/2013/08/understanding-slices-in-go-programming.html][Κατανοώντας τις Φέτες στον Προγραμματισμό της Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/08/collections-of-unknown-length-in-go.html][Συλλογές Αγνώστου Μήκους στην Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/09/iterating-over-slices-in-go.html][Διαδοχικές Προσπελάσεις σε Φέτες στην Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/09/slices-of-slices-of-slices-in-go.html][Φέτες από Φέτες Φετών στην Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/12/three-index-slices-in-go-12.html][Φέτες Τριών Δεικτών στην Go 1.2]] - William Kennedy    
- [[https://github.com/golang/go/wiki/SliceTricks][SliceTricks]]    
- [[https://go-review.googlesource.com/c/go/+/347917][εκτελέσιμο περιβάλλον: Κάνοντας τον τύπο της μεγέθυνσης μιας φέτας λίγο πιο ομαλό]] - Go Team 
			 
* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

*Μέρος* *Α:* Δηλώστε μια nil φέτα ακεραίων. Δημιουργείστε μια επανάληψη, που προσθέτει 10 τιμές
στην φέτα. Επισκεφθείτε διαδοχικά τα στοιχεία της φέτας και παρουσιάστε κάθε τιμή.

*Μέρος* *Β:* Δηλώστε μια φέτα πέντε συμβολοσειρών και δώστε αρχική τιμή στην φέτα με ρητές τιμές
συμβολοσειρών. Παρουσιάστε όλα τα στοιχεία. Δημιουργείστε μια φέτα των δεικτών ένα και δύο και παρουσιάστε
την θέση δείκτη και την τιμή κάθε στοιχείου στην νέο φέτα.

.play slices/exercise1.go		  
.play slices/answer1.go
