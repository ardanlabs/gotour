Ανταγωνισμός για Δεδομένα
Ένας ανταγωνισμός για δεδομένα συμβαίνει όταν δύο ή περισσότερες ρουτίνες συνεκτέλεσης της Go προσπαθούν να διαβάσουν ή να γράψουν, στον ίδιο πόρο συστήματος, την ίδια χρονική στιγμή.

* Ανταγωνισμός για Δεδομένα

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εάν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιήστε το Σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Ένας ανταγωνισμός για δεδομένα (στμ. data race) συμβαίνει όταν, δύο ή περισσότερες ρουτίνες συνεκτέλεσης της Go προσπαθούν να 
έχουν πρόσβαση στην ίδια περιοχή μνήμης, την ίδια χρονική στιγμή, οπότε τουλάχιστον
άλλη μια ρουτίνα συνεκτέλεσης της Go, πραγματοποιεί μια εγγραφή. Όταν συμβαίνει αυτό, δεν είναι δυνατόν να 
προβλεφθεί το αποτέλεσμα. Αυτού του είδους τα προβλήματα είναι δύσκολο να εντοπιστούν, 
επειδή προκαλούν ζητήματα, τα οποία πάντα εμφανίζονται ως τυχαία.

Αυτά τα ~8 λεπτά από τον Scott Meyers είναι υπέροχα να τα ακούσει κανείς εδώ:

[[https://youtu.be/WDIkqP4JbkE?t=1809][CPU Caches and Why You Care 30:09-38:30]]

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1:* Ανταγωνισμός για Δεδομένα
- *Παράδειγμα* *2:* Ατομικές Μεταβολές 
- *Παράδειγμα* *3:* Αμοιβαίος Αποκλεισμός
- *Παράδειγμα* *4:* Αμοιβαίος Αποκλεισμός Ανάγνωσης/Εγγραφής
- *Παράδειγμα* *5:* Ανταγωνισμός για Δεδομένα Σχεσιακού Πίνακα
- *Παράδειγμα* *6:* Συνθήκη Διαμάχης Δεδομένων Βασισμένη σε Διεπαφή 

.play data_race/example1.go
.play data_race/example2.go     
.play data_race/example3.go
.play data_race/example4.go
.play data_race/example5.go
.play data_race/example6.go

** Παράδειγμα Ανταγωνισμού για Δεδομένα

Αυτό είναι ένα καλό παράδειγμα ενός ανταγωνισμού για δεδομένα και πως μπορεί να παραμείνει 
κρυμμένος για χρόνια και να εμφανιστεί τελικά, σε ανύποπτο χρόνο, ώστε να προκαλέσει 
διαφθορά δεδομένων.

    var counter int

    func main() {
        const grs = 2

        var wg sync.WaitGroup
        wg.Add(grs)

        for g := 0; g < grs; g++ {
            go func() {
                for i := 0; i < 2; i++ {
                    value := counter
                    value++
                    counter = value
                }
                wg.Done()
            }()
        }

        wg.Wait()
        fmt.Println("Counter:", counter)
    }

Αυτό το πρόγραμμα δημιουργεί δύο ρουτίνων συνεκτέλεσης της Go, η καθεμία απ' τις οποίες έχει πρόσβαση 
στην ίδια ακέραια μεταβλητή, της οποίας την τιμή αυξάνουν δύο φορές. Η ρουτίνα συνεκτέλεσης της Go εκτελεί
μια λειτουργία ανάγνωσης, μετατροπής και εγγραφής επί της κοινώς μοιραζόμενης κατάστασης, 
με χειροκίνητο τρόπο. 

    var counter int

    func main() {
        . . .

        go func() {
            for i := 0; i < 2; i++ {
                value := counter
                value++
                counter = value
            }
            wg.Done()
        }()

        . . .
    }

Μπορεί κανείς να παρατηρήσει την πρόσβαση στην κατάσταση, επί της οποίας υπάρχει κοινή πρόσβαση,
μέσα στην επανάληψη for. Όταν δημιουργηθεί και εκτελεστεί το πρόγραμμα, δίνει την σωστή απάντηση,
που είναι 4 κάθε φορά. 

    $ ./example1
    Final Counter: 4

    $ ./example1
    Final Counter: 4

    $ ./example1
    Final Counter: 4

Πως είναι δυνατόν κάτι τέτοιο να δουλεύει;

    G1                              Κοινή Κατάσταση: 0                            G2
    ----------------------------------------------------------------------------
    Ανάγνωση : 0
    Μετατροπή: 1
    Εγγραφή  : 1                    Κοινή Κατάσταση: 1
    Εναλλαγή περιβάλλοντος λειτουργίας 
                                                                    Ανάγνωση : 1
                                                                    Μετατροπή: 2
                                    Κοινή Κατάσταση: 2              Εγγραφή  : 2
                                               Εναλλαγή περιβάλλοντος λειτουργίας 
    Ανάγνωση : 2
    Μετατροπή: 3
    Εγγραφή  : 3                    Κοινή Κατάσταση: 3
    Τερματισμός
                                                                    Ανάγνωση : 3
                                                                    Μετατροπή: 4
                                    Κοινή Κατάσταση: 4              Εγγραφή  : 4
                                                                    Τερματισμός
    ----------------------------------------------------------------------------

Οι λειτουργίες ανάγνωσης, μετατροπής και εγγραφής συμβαίνουν ανεμπόδιστα. Όμως, 
επειδή λαμβάνει κανείς την σωστή απάντηση, δεν σημαίνει ότι δεν υπάρχει πρόβλημα.
Τι θα συμβεί αν κανείς προσθέσει μια δήλωση καταγραφής, στην μέση των λειτουργιών
ανάγνωσης, μετατροπής και εγγραφής;

    var counter int

    func main() {
        . . .

        go func() {
            for i := 0; i < 2; i++ {
                value := counter
                value++
                log.Println("logging")     <-- Προσθήκη Καταγραφής Εδώ
                counter = value
            }
            wg.Done()
        }()

        . . .
    }

Αν κανείς εκτελέσει το πρόγραμμα, δεν παίρνει πια σαν αποτέλεσμα το 4, αλλά τώρα η 
απάντηση είναι 2.

    $ ./example1
    Final Counter: 2

    $ ./example1
    Final Counter: 2

    $ ./example1
    Final Counter: 2


Τι συμβαίνει; Αυτό που συμβαίνει, είναι ότι εμφανίζεται το πρόβλημα ανταγωνισμού για 
δεδομένα που υπήρχε και προηγούμενως όμως δεν εκδηλωνόταν. Η κλήση στην log 
τώρα προκαλεί τον χρονοδρομολογητή να δημιουργήσει μια αλλαγή περιβάλλοντος 
λειτουργίας, μεταξύ των δύο ρουτίνων συνεκτέλεσης της Go, σε άσχημη στιγμή.

    G1                                Κοινή Κατάσταση: 0                         G2
    ----------------------------------------------------------------------------
    Ανάγνωση : 0
    Μετατροπή: 1
    Αλλαγή Περιβάλλοντος Λειτουργίας
                                                                    Ανάγνωση : 0
                                                                    Μετατροπή: 1
                                                Αλλαγή Περιβάλλοντος Λειτουργίας 
    Εγγραφή  : 1                      Κοινή Κατάσταση: 1
    Ανάγνωση : 1
    Μετατροπή: 2
    Αλλαγή Περιβάλλοντος Λειτουργίας
                                      Κοινή Κατάσταση: 1            Εγγραφή  : 1
                                                                    Ανάγνωση : 1
                                                                    Μετατροπή: 2
                                                Αλλαγή Περιβάλλοντος Λειτουργίας 
    Εγγραφή  : 2                      Κοινή Κατάσταση: 2
    Τερματισμός
                                      Κοινή Κατάσταση: 2            Εγγραφή:  2
                                                                    Τερματισμός
    ----------------------------------------------------------------------------

Μετά την λειτουργία μετατροπής, συμβαίνει μια αλλαγή περιβάλλοντος λειτουργίας. 
Οι τρεις λειτουργίες δεν είναι πια συνεχόμενες και η ρουτίνα συνεκτέλεσης της Go 2 καταλήγει με την δική
της τοπική τιμή να είναι λάθος, όταν ολοκληρώνει την λειτουργία εγγραφής. Είναι 
τυχερό που αυτό συμβαίνει κάθε φορά και είναι δυνατόν να το εντοπίσει κανείς. 
Συνήθως όμως, ένας ανταγωνισμός για δεδομένα σαν και αυτόν συμβαίνει τυχαία και είναι αδύνατο να
το γνωρίζει κανείς, παρά μόνο όταν είναι πολύ αργά. Ευτυχώς, η Go έχει έναν ανιχνευτή 
ανταγωνισμού για δεδομένα, προκειμένου να βοηθήσει στην ανακάλυψη τέτοιων ανταγωνισμών.

** Εντοπισμός Διαμάχης για Δεδομένα 

Υπάρχουν αρκετοί τρόποι να ενεργοποιηθεί ο ανιχνευτής των ανταγωνισμών για δεδομένα. Μπορεί 
κανείς να τον χρησιμοποιήσει με τις εντολές run, build και test. Αν χρησιμοποιηθεί με
την εντολή build, κανείς πρέπει να θυμάται, ότι πρέπει να εκτελεστεί το πρόγραμμα. Λέγεται
ότι ένα εκτελέσιμο με ενσωματωμένα διαγνωστικά εργαλεία μπορεί να είναι πιο αργό κατά ~20%.

    $ go build -race
    $ ./example1

Η παράμετρος -race είναι ο τρόπος με τον οποίο μπορεί να πραγματοποιηθεί η δημιουργία του
εκτελέσιμου μαζί με τον ανιχνευτή ανταγωνισμών για δεδομένα. Είναι πιθανόν να χρησιμοποιηθεί
περισσότερο με την εντολή γραμμής εντολών "go test", όμως για αυτό το παράδειγμα, το εργαλείο 
του ανιχνευτή, ενσωματώνεται πρώτα στο εκτελέσιμο και στην συνέχεια εκτελείται. 

    2021/02/01 17:30:52 logging
    2021/02/01 17:30:52 logging
    2021/02/01 17:30:52 logging
    ==================
    WARNING: DATA RACE
    Write at 0x000001278d88 by goroutine 8:
    main.main.func1()
        /data_race/example1/example1.go:41 +0xa6

    Previous read at 0x000001278d88 by goroutine 7:
    main.main.func1()
        /data_race/example1/example1.go:38 +0x4a

    Goroutine 8 (running) created at:
    main.main()
        /data_race/example1/example1.go:36 +0xaf

    Goroutine 7 (finished) created at:
    main.main()
        /data_race/example1/example1.go:36 +0xaf
    ==================
    2021/02/01 17:30:52 logging
    Final Counter: 2
    Found 1 data race(s)

Βλέπει κανείς ότι εντοπίζεται ο ανταγωνισμός για δεδομένα, όταν εκτελείται το πρόγραμμα. 
Αυτό θα συνέβαινε με ή χωρίς την εισαγωγή της δήλωσης log. Όταν εντοπίζεται ο
ανταγωνισμός για δεδομένα, το πρόγραμμα μπαίνει σε κατάσταση panic και παρέχει το παραπάνω
ίχνος. Η ιχνηλάτηση παρουσιάζει που έχει πραγματοποιηθεί πρόσβαση, χωρίς να έχει 
προηγηθεί συγχρονισμός στην ίδια κοινή κατάσταση, όπου τουλάχιστον μια πρόσβαση, 
ήταν μια εγγραφή. 

Σε παραπάνω ιχνηλάτηση, μια ρουτίνα συνεκτέλεσης της Go πραγματοποίησε μια εγγραφή στην διεύθυνση 
0x000001278d88 στην γραμμή 41 και υπήρχε επίσης μια εγγραφή, χωρίς να έχει προηγηθεί 
συγχρονισμός, στην ίδια διεύθυνση από μια άλλη ρουτίνα συνεκτέλεσης της Go στην γραμμή 38. Και οι 
δύο ρουτίνες συνεκτέλεσης της Go δημιουργούνται στην γραμμή 36.

    36 go func() {
    37     for i := 0; i < 2; i++ {
    38         value := counter
    39         value++
    40         log.Println("logging")
    41         counter = value
    42     }
    43     wg.Done()
    44 }()

Είναι εμφανής η πραγματοποίηση ανάγνωσης και εγγραφής χωρίς να έχει προηγηθεί 
συγχρονισμός. Παρενθετικά, η λειτουργία συν συν, στην γραμμή 39, θα προκαλούσε 
επίσης ένας ανταγωνισμό για δεδομένα, αν ο κώδικας είχε πρόσβαση στην μεταβλητή counter. 
Η λειτουργία συν συν, αποτελείται από μια λειτουργία ανάγνωσης, μετατροπής
και εγγραφής από κάτω και το λειτουργικό σύστημα θα μπορούσε να προκαλέσει εναλλαγή 
περιβάλλοντος εκτέλεσης, στην μέση όλων αυτών.

Επομένως, πως είναι δυνατόν να επιδιορθωθεί ο κώδικας, ώστε κανείς να είναι σίγουρος 
ότι έχει απομακρυνθεί ο ανταγωνισμός για δεδομένα; Υπάρχουν δύο εργαλεία που μπορεί να 
χρησιμοποιήσει κανείς, τις ατομικές οδηγίες και τα αντικείμενα αμοιβαίου αποκλεισμού (στμ. mutex).

** Ατομικές Οδηγίες

Οι ατομικές οδηγίες παρέχουν συγχρονισμό στο επίπεδο του υλικού. Εξαιτίας αυτού, είναι
περιορισμένες σε λέξεις και δεδομένα μισής λέξης. Επομένως, οι οδηγίες αυτές είναι καλές 
για μετρητές ή μηχανισμούς ταχείας εναλλαγής περιβάλλοντος εκτέλεσης. Το API του WaitGroup
χρησιμοποιεί ατομικές οδηγίες.

Ποιες αλλαγές πρέπει να γίνουν, προκειμένου να εφαρμοστούν ατομικές οδηγίες στον κώδικα;

    var counter int32                             <-- ΑΛΛΑΞΕ

    func main() {
        const grs = 2

        var wg sync.WaitGroup
        wg.Add(grs)

        for g := 0; g < grs; g++ {
            go func() {
                for i := 0; i < 2; i++ {
                    atomic.AddInt32(&counter, 1)  <-- ΑΛΛΑΞΕ
                }
                wg.Done()
            }()
        }

        wg.Wait()
        fmt.Println("Counter:", counter)
    }

Χρειάζεται να γίνουν μονάχα μερικές αλλαγές. Πρώτα, πρέπει να αλλάξει η μεταβλητή counter 
σε ακέραια τιμή με ακρίβεια. Αυτό εμφανίζεται στην κορυφή της περιγραφής του κώδικα. 
Οι ατομικές συναρτήσεις μπορούν να λειτουργήσουν μόνο με ακέραιους ακριβείας. Στην συνέχεια, 
πρέπει να αντικατασταθούν οι οδηγίες ανάγνωσης, μετατροπής και εγγραφής με μια κλήση στην 
atomic.AddInt32. Αυτή η μοναδική κλήση, μπορεί να χειριστεί όλα τις προηγούμενες οδηγίες. 

Όλες οι συναρτήσεις που σχετίζονται με το πακέτο atomic, παίρνουν την διεύθυνση στην κοινή 
κατάσταση, που πρέπει να υποστεί συγχρονισμό. Ο συγχρονισμός συμβαίνει μονάχα στο επίπεδο 
διεύθυνσης μνήμης. Επομένως, διαφορετικές ρουτίνες συνεκτέλεσης της Go που καλούν την ίδια συνάρτηση, όμως 
σε διαφορετική διεύθυνση μνήμης, δεν θα συγχρονιστούν.

Το API των ατομικών οδηγιών μοιάζει ως εξής:

    func AddInt32(addr *int32, delta int32) (new int32)
    func AddInt64(addr *int64, delta int64) (new int64)
    func AddUint32(addr *uint32, delta uint32) (new uint32)
    func AddUint64(addr *uint64, delta uint64) (new uint64)
    func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)

    func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)
    func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)
    func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)
    func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)
    func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)
    func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)

    func LoadInt32(addr *int32) (val int32)
    func LoadInt64(addr *int64) (val int64)
    func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)
    func LoadUint32(addr *uint32) (val uint32)
    func LoadUint64(addr *uint64) (val uint64)
    func LoadUintptr(addr *uintptr) (val uintptr)

    func StoreInt32(addr *int32, val int32)
    func StoreInt64(addr *int64, val int64)
    func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)
    func StoreUint32(addr *uint32, val uint32)
    func StoreUint64(addr *uint64, val uint64)
    func StoreUintptr(addr *uintptr, val uintptr)

    func SwapInt32(addr *int32, new int32) (old int32)
    func SwapInt64(addr *int64, new int64) (old int64)
    func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)
    func SwapUint32(addr *uint32, new uint32) (old uint32)
    func SwapUint64(addr *uint64, new uint64) (old uint64)
    func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)

    type Value
        func (v *Value) Load() (x interface{})
        func (v *Value) Store(x interface{})

Μπορεί κανείς να παρατηρήσει ότι η πρώτη παράμετρος είναι πάντα μια διεύθυνση σε 
ακέραια τιμή ακρίβειας ή σε αντίστοιχο δείκτη διεύθυνσης. Υπάρχει επίσης ένας τύπος
με το όνομα Value, που παρέχει μια σύγχρονη value με ένα μικρό API.

** Αμοιβαίος Αποκλεισμός

Τι θα έπρεπε να συμβεί, αν κάποιος ήθελε να διατηρήσει τις προηγούμενες τρεις γραμμές
κώδικα; Σε αυτή την περίπτωση, η χρήση ατομικών οδηγιών δεν θα λειτουργήσουν. Αυτό που 
χρειάζεται να χρησιμοποιηθεί είναι ο αμοιβαίος αποκλεισμός. Ο αμοιβαίος αποκλεισμός επιτρέπει 
την ομαδοποίηση ορισμένου κώδικα, ώστε μόνο μια ρουτίνα συνεκτέλεσης της Go τη φορά, να μπορεί να εκτελέσει αυτόν
τον κώδικα. 

    var counter int

    func main() {
        const grs = 2

        var wg sync.WaitGroup
        wg.Add(grs)

        var mu sync.Mutex                    <-- ΑΛΛΑΞΕ

        for g := 0; g < grs; g++ {
            go func() {
                for i := 0; i < 2; i++ {
                    mu.Lock()                <-- ΑΛΛΑΞΕ
                    {
                        value := counter
                        value++
                        counter = value
                    }
                    mu.Unlock()              <-- ΑΛΛΑΞΕ
                }
                wg.Done()
            }()
        }

        wg.Wait()
        fmt.Println("Counter:", counter)
    }

Υπάρχουν αρκετές αλλαγές σε αυτόν τον κώδικα, απο το πρωτότυπο. Έχει προστεθεί η 
δημιουργία της μεταβλητής mu ως μια μεταβλητή τύπου Mutex, που λαμβάνει την 
μηδενική τιμή της. Στην συνέχεια, μέσα στην επανάληψη for, προστίθενται οι κλήσεις 
στις μεθόδους τύπου Lock και Unlock, με ένα πρόσθετο τμήμα κώδικα. Εντός του 
ομαδοποιημένου τμήματος κώδικα, βρίσκεται ο κώδικας που πρέπει να συγχρονιστεί. 
Η ομαδοποίηση κώδικα χρησιμοποιείται για λόγους ευκολίας στην ανάγνωση. 

Με αυτόν τον κώδικα τοποθετημένο, ο χρονοδρομολογητής θα επιτρέψει μόνο σε μια 
ρουτίνα συνεκτέλεσης της Go, να εισέλθει στο ομαδοποιημένο τμήμα κώδικα, κάθε φορά. Είναι σημαντικό 
να καταλάβει κανείς ότι, ο Mutex δεν είναι μια ουρά. Η πρώτη ρουτίνα συνεκτέλεσης της Go που καλεί 
την μέθοδο τύπου Lock, δεν είναι απαραίτητα η πρώτη ρουτίνα συνεκτέλεσης της Go που θα αποκτήσει 
την λειτουργία της Lock. Υπάρχει ένας αλγόριθμος που βασίζεται στην δίκαιη πρόσβαση,
όμως αυτός είναι επίτηδες έτσι, ώστε οι χρήστες να μην χρησιμοποιούν τα αντικείμενα
αμοιβαίου αποκλεισμού ως ουρές.

Είναι σημαντικό να θυμάται κανείς ότι, η κλήση στην μέθοδο τύπου Lock δημιουργεί πρόσθετη 
πίεση, έτσι όσο περισσότερο χρειάζεται να περάσει κανείς από την Lock στην Unlock, τόσο
μεγαλύτερη είναι η πιθανότητα να υπάρχουν ρουτίνες συνεκτέλεσης της Go που περιμένουν την σειρά τους.
Αν κανείς ξεχάσει να καλέσει την μέθοδο τύπου Unlock, τότε όλες οι ρουτίνες συνεκτέλεσης της Go, που περιμένουν, θα 
βρεθούν σε αδιέξοδο. Γι' αυτόν τον λόγο, είναι σημαντικό να συμβαίνουν οι κλήσεις στην
Lock και την Unlock στην ίδια συνάρτηση. Πρέπει κανείς να επιβεβαιώνει ότι, πράγματι 
συμβαίνει ο αναγκαίος συγχρονισμός που απαιτείται κατ' ελάχιστο, εντός του ομαδοποιημένου 
τμήματος κώδικα, όμως πρέπει πράγματι να είναι ο ελάχιστος που απαιτείται και όχι τίποτα 
λιγότερο.

Ο ακόλουθος κώδικας είναι ένα πολύ κακό παράδειγμα κώδικα, όπου κάποιος προσπαθεί να μπει 
και να βγει τόσο γρήγορα από την κατάσταση κλειδώματος, ώστε ουσιαστικά δεν πραγματοποιεί τον 
επιζητούμενο συγχρονισμό και ούτε ο ανιχνευτής διαμάχης δεδομένων είναι σε θέση να 
ανιχνεύσει το πρόβλημα. 

    var counter int

    func main() {
        const grs = 2

        var wg sync.WaitGroup
        wg.Add(grs)

        var mu sync.Mutex

        for g := 0; g < grs; g++ {
            go func() {
                for i := 0; i < 2; i++ {
                    var value int
                    mu.Lock()              <-- Κακή Χρήση Mutex
                    {
                        value = counter
                    }
                    mu.Unlock()

                    value++

                    mu.Lock()              <-- Κακή Χρήση Mutex
                    {
                        counter = value
                    }
                    mu.Unlock()
                }
                wg.Done()
            }()
        }

        wg.Wait()
        fmt.Println("Counter:", counter)
    }

Ως γενική κατεύθυνση, αν κανείς παρατηρήσει μια κλήση στην μέθοδο τύπου Lock από την ίδια μεταβλητή
Mutex δύο φορές στην ίδια συνάρτηση, μπορεί να σταματήσει την επισκόπηση του κώδικα. Πιθανότατα 
υπάρχει κάποιο λάθος ή υπερβολική πολυπλοκότητα. Στην παρούσα περίπτωση, οι κλήσεις 
για την ανάγνωση και την εγγραφή συγχρονίζονται, όμως οι δύο ρουτίνες συνεκτέλεσης της Go μπορούν να 
βρεθούν στην γραμμή κώδικα με την value++ με την την ίδια τιμή. Ο ανταγωνισμός για τα δεδομένα 
υπάρχει ακόμα και ο ανιχνευτής διαμαχών δεδομένων είναι αβοήθητος στον εντοπισμό της.

** Αντικείμενα Αμοιβαίου Αποκλεισμού Εγγραφής/Ανάγνωσης

Υπάρχει ένα δεύτερο είδος αμοιβαίου αποκλεισμού, που ονομάζεται 
αμοιβαίος αποκλεισμος ανάγνωσης/εγγραφής. Επιτρέπει να διαχωριστούν τα κλειδώματα των 
αναγνώσεων και των εγγραφών. Αυτό είναι σημαντικό διότι η ανάγνωση δεδομένων δεν αποτελεί 
πρόβλημα, εκτός και αν μια ρουτίνα συνεκτέλεσης της Go προσπαθεί να πραγματοποιήσει εγγραφή, την ίδια στιγμή. 
Έτσι, αυτό το είδος του αμοιβαίου αποκλεισμού, επιτρέπει σε πολλές ρουτίνες συνεκτέλεσης της Go 
να διαβάσουν την ίδια περιοχή μνήμης, ταυτόχρονα. Όταν ζητηθεί ένα κλείδωμα για εγγραφή, 
οι αναγνώσεις σταματούν να πραγματοποιούνται, γίνεται η εγγραφή και στην συνέχεια οι αναγνώσεις 
μπορούν να ξεκινήσουν πάλι.

    package main

    import (
        "fmt"
        "math/rand"
        "sync"
        "time"
    )

    var data []string
    var rwMutex sync.RWMutex

    func main() {
        var wg sync.WaitGroup
        wg.Add(1)

        go func() {
            for i := 0; i < 10; i++ {
                writer(i)
            }
            wg.Done()
        }()

        for i := 0; i < 8; i++ {
            go func(id int) {
                for {
                    reader(id)
                }
            }(i)
        }

        wg.Wait()
        fmt.Println("Program Complete")
    }

    func writer(i int) {
        rwMutex.Lock()
        {
            time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
            fmt.Println("****> : Performing Write")
            data = append(data, fmt.Sprintf("String: %d", i))
        }
        rwMutex.Unlock()
    }

    func reader(id int) {
        rwMutex.RLock()
        {
            time.Sleep(time.Duration(rand.Intn(10)) * time.Millisecond)
            fmt.Printf("%d : Performing Read : Length[%d]\n", id, len(data))
        }
        rwMutex.RUnlock()
    }

Μπορεί κανείς να παρατηρήσει την χρήση μιας μεταβλητής αμοιβαίου αποκλεισμού ανάγνωσης/εγγραφής
όπου υπάρχουν 8 ρουτίνες συνεκτέλεσης της Go, οι οποίες διαβάζουν όλο το μήκος μιας φέτας, με μια καθυστέρηση 
10 millisecond η μια από την άλλη, ενώ 1 ρουτίνα συνεκτέλεσης της Go ξυπνάει εντός 100 millisecond, προκειμένου 
να προσθέσει μια τιμή (εγγραφή) στην φέτα. 

Το κλειδί βρίσκεται στην υλοποίηση των συναρτήσεων writer και reader. Παρατηρεί κανείς πως
χρησιμοποιείται η μέθοδος τύπου Lock για την writer και η RLock για την reader. Το μεγαλύτερο λάθος που 
μπορεί να κάνει κανείς με αυτό είναι να μπερδέψει τις κλήσεις στην Unlock με την λάθος εκδοχή. 
Αν έχει κανείς μια Lock και μια αντίστοιχη RUnlock, δεν θα έχει καλή κατάληξη. 

    7 : Performing Read : Length[0]
    5 : Performing Read : Length[0]
    0 : Performing Read : Length[0]
    3 : Performing Read : Length[0]
    7 : Performing Read : Length[0]
    2 : Performing Read : Length[0]
    1 : Performing Read : Length[0]
    ****> : Performing Write
    0 : Performing Read : Length[1]
    5 : Performing Read : Length[1]
    3 : Performing Read : Length[1]
    6 : Performing Read : Length[1]
    7 : Performing Read : Length[1]
    4 : Performing Read : Length[1]
    1 : Performing Read : Length[1]
    2 : Performing Read : Length[1]
    ****> : Performing Write
    7 : Performing Read : Length[2]
    1 : Performing Read : Length[2]
    3 : Performing Read : Length[2]

Το αποτέλεσμα δείχνει πως πολλές ρουτίνες συνεκτέλεσης της Go διαβάζουν την ίδια στιγμή, αλλά όλες οι αναγνώσεις
σταματάνε, όταν πραγματοποιείται μια εγγραφή. 

** Σημειώσεις

- Οι ρουτίνες συνεκτέλεσης της Go πρέπει να είναι οργανωμένες και συγχρονισμένες.
- Όταν δύο ή περισσότερες ρουτίνες συνεκτέλεσης της Go προσπαθούν να έχουν πρόσβαση στον ίδιο πόρο συστήματος, προκύπτει ανταγωνισμός για δεδομένα. 
- Οι συναρτήσεις ατομικής πρόσβασης και τα αντικείμενα αμοιβαίου αποκλεισμού παρέχουν την υποστήριξη που χρειάζεται κανείς. 

** Συνοχή Μνήμης Ταχείας Προσπέλασης και Εσφαλμένος Διαμοιρασμός 

Αυτό το περιεχόμενο παρέχεται από τον Scott Meyers από την ομιλία του το 2014 στο Dive:

[[https://youtu.be/WDIkqP4JbkE?t=1809][Οι Μνήμες Ταχείας Προσπέλασης της CPU και Γιατί σε Ενδιαφέρει (30:09-38:30)]]  
[[https://github.com/ardanlabs/gotraining/blob/master/topics/go/testing/benchmarks/falseshare/README.md][Παράδειγμα Κώδικα]]

.image /tour/grc/static/img/figure1_data_race.png

** Σημειώσεις σχετικά με την Συνοχή Μνήμης Ταχείας Προσπέλασης και τον Εσφαλμένο Διαμοιρασμό

- Έχει σημασία η πρόσβαση στην μνήμη νήματος εκτέλεσης 
- Αν ο αλγόριθμος δεν κλιμακώνεται, πρέπει να αναζητηθεί η ύπαρξη προβλημάτων εσφαλμένου διαμοιρασμού

** Πρόσθετα Αναγνώσματα

- [[http://www.drdobbs.com/parallel/eliminate-false-sharing/217500206][Εξάλειψη Εσφαλμένου Διαμοιρασμού]] - Herb Sutter    
- [[https://golang.org/ref/mem][Το Υπόδειγμα Μνήμης της Go]]    
- [[http://blog.golang.org/race-detector][Παρουσιάζοντας τον Ανιχνευτή Ανταγωνισμού για Δεδομένα της Go]] - Dmitry Vyukov and Andrew Gerrand    
- [[https://www.ardanlabs.com/blog/2013/09/detecting-race-conditions-with-go.html][Ανιχνεύοντας Συνθήκες Ανταγωνισμού για Δεδομένα με την Go]] - William Kennedy    
- [[https://golang.org/doc/articles/race_detector.html][Ανιχνευτής Ανταγωνισμού για Δεδομένα]]    

* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

Με βάση το ακόλουθο πρόγραμμα, χρησιμοποιήστε τον ανιχνευτή ανταγωνισμού για δεδομένα, προκειμένου να βρείτε και να διορθώσετε τον ανταγωνισμό για δεδομένα.

.play data_race/exercise1.go
.play data_race/answer1.go
