Τύποι Struct
Είναι δυνατόν να δηλωθεί ένας τύπος struct, ως ένας γενικός τύπος.

* Γενικός Προγραμματισμός - Τύποι Struct

Είναι δυνατόν να δηλωθεί ένας τύπος struct, ως ένας γενικός τύπος.

** Video

Μπορεί κανείς να παρακολουθήσει την ομιλία του Bill Kennedy, σχετικά με τον Γενικό Προγραμματισμό,
που παρουσιάζει λεπτομερώς όλα τα παραδείγματα αυτής της ενότητας της Επισκόπησης.

.html generics-video.html

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1*: Συνδεδεμένες Λίστες

.play generics/struct-types/example1.go

** Επεξήγηση

Τι θα συνέβαινε αν ήθελε κανείς να δηλώσει έναν τύπο struct, ως ένα γενικό τύπο;

    type node[T any] struct {
        Data T
        next *node[T]
        prev *node[T]
    }

Ο παραπάνω τύπος struct δηλώνεται, για να αναπαραστήσει ένα στοιχείο σε μια συνδεδεμένη
λίστα. Κάθε στοιχείο περιλαμβάνει ένα ξεχωριστό μέρος δεδομένων, που αποθηκεύεται και 
διαχειρίζεται από την λίστα. Η χρήση των αγκυλών δηλώνει, ότι ο τύπος T είναι ένας γενικός
τύπος, που πρέπει να εξακριβωθεί στο στάδιο της μεταγλώττισης. Η χρήση του περιορισμού "any" 
περιγράφει, ότι δεν υπάρχει κανένας περιορισμός στον τύπο, που είναι δυνατόν να είναι ο T.

Με την δήλωση του τύπου, το πεδίο Data μπορεί να προσδιοριστεί ως ένα πεδίο κάποιου τύπου T,
ο οποίος πρέπει να προσδιοριστεί αργότερα. Τα πεδία next και prev πρέπει να δείχνουν σε στοιχείο 
του ίδιου τύπου T. Αυτοί είναι δείκτες διεύθυνσης στο επόμενο και στο προηγούμενο στοιχείο στην
συνδεδεμένη λίστα, αντίστοιχα. Προκειμένου να γίνει αυτή η σύνδεση, τα πεδία δηλώνονται ως δείκτες 
διεύθυνσης σε στοιχείο, που είναι δεσμευμένο στον τύπο T, μέσω της χρήσης των αγκυλών. 

    type list[T any] struct {
        first *node[T]
        last *node[T]
    }

Ο δεύτερος τύπος struct ονομάζεται list και αναπαριστά μια συλλογή από στοιχεία, με το να
διατηρούν δείκτες στο πρώτο και στο τελευταίο στοιχείο στην λίστα. Αυτά τα πεδία πρέπει να
διατηρούν ένα δείκτη σε στοιχείο κάποιου τύπου T, όπως ακριβώς τα πεδία next και prev από τον
τύπο node.

Ξανά, το αναγνωριστικό T ορίζεται ως ένας γενικός τύπος (που θα καθοριστεί αργότερα)
ο οποίος μπορεί να αντικατασταθεί, για κάθε πραγματικό τύπο, όπως περιγράφεται από τον 
περιορισμό τύπου "any". Στην συνέχεια, το πρώτο και το τελευταίο πεδίο δηλώνονται ως 
δείκτες διεύθυνσης σε στοιχείο κάποιου τύπου T, χρησιμοποιώντας στο συντακτικό των 
αγκυλών.

    func (l *list[T]) add(data T) *node[T] {
        n := node[T]{
            Data: data,
            prev: l.last,
        }
        
        if l.first == nil {
            l.first = &n
            l.last = &n
            return &n
        }

        l.last.next = &n
        l.last = &n
        
        return &n
    }

Αυτή είναι η υλοποίηση μιας μεθόδου τύπου, που ονομάζεται add, για τον τύπο list. Δεν χρειάζεται
καμία επίσημη δήλωση του γενικού τύπου list (όπως συμβαίνει με τις συναρτήσεις) καθώς η μέθοδος
τύπου δεσμεύεται στον list, μέσω του δέκτη μεθόδου. Ο δέκτης μεθόδου, της μεθόδου τύπου add, δηλώνεται 
ως δείκτης σε list κάποιου τύπου T και η επιστροφή δηλώνεται ως δείκτης διεύθυνσης σε στοιχείο της
συνδεδεμένης λίστας, με τον ίδιο τύπο.

Ο κώδικας μετά την δημιουργία ενός στοιχείου της συνδεδεμένης λίστας θα είναι πάντα ο ίδιος, 
ανεξάρτητα από τον τύπο των δεδομένων, που θα αποθηκευτούν στην συνδεδεμένη λίστα, καθώς πρόκειται 
για απλούς χειρισμούς δείκτη διεύθυνσης. Μονάχα η κατασκευή ενός νέου στοιχείου επηρεάζεται από
τον τύπο δεδομένων, που πρόκειται να διαχειριστεί. Με την βοήθεια του γενικού προγραμματισμού, 
η κατασκευή ενός στοιχείου μπορεί να δεσμευθεί στον τύπο T, ο οποίος αντικαθίσταται αργότερα, κατά 
το στάδιο μεταγλώττισης.

Χωρίς τον γενικό προγραμματισμό, ολόκληρη η μέθοδος τύπου θα έπρεπε να αναπαραχθεί, καθώς η 
κατασκευή ενός στοιχείου θα έπρεπε να ενσωματωθεί χειροκίνητα σε κάποιο γνωστό τύπο, ο οποίος 
είναι δηλωμένος πριν την μεταγλώττιση. Επειδή η ποσότητα του κώδικα (για ολόκληρη την υλοποίηση του
τύπου list), που χρειάζεται να αλλάξει, για τους διαφορετικούς τύπους δεδομένων, είναι πολύ μικρή,
η δυνατότητα δήλωσης ενός στοιχείου και της αντίστοιχης συνδεδεμένης λίστας, προκειμένου να γίνει
η διαχείριση δεδομένων κάποιου τύπου T, μειώνει το κόστος της αναπαραγωγής κώδικα και την 
απαιτούμενη συντήρηση.

    type user struct {
        name string
    }
    
    func main() {
        // Αποθήκευση τιμών user στην συνδεδεμένη λίστα.
        var lv list[user]
        n1 := lv.add(user{"bill"})
        n2 := lv.add(user{"ale"})
        fmt.Println(n1.Data, n2.Data)
        
        // Αποθήκευση δεικτών διεύθυνσης τύπου user στην συνδεδεμένη λίστα.
        var lp list[*user]
        n3 := lp.add(&user{"bill"})
        n4 := lp.add(&user{"ale"})
        fmt.Println(n3.Data, n4.Data)
    }

Αποτέλεσμα:

    {bill} {ale}
    &{bill} &{ale}

Παραπάνω είναι μια μικρή εφαρμογή. Δηλώνεται ένας τύπος με το όνομα user και στην συνέχεια 
κατασκευάζεται μια συνδεδεμένη λίστα, στην κατάσταση μηδενικής τιμής της, προκειμένου να 
διαχειριστεί τιμές τύπου user. Στην συνέχεια κατασκευάζεται μια δεύτερη συνδεδεμένη λίστα, 
στην κατάσταση μηδενικής τιμής και αυτή η συνδεδεμένη λίστα διαχειρίζεται δείκτες διεύθυνσης 
σε τιμές τύπου user. Η μόνη διαφορά μεταξύ των δύο συνδεδεμένων λιστών είναι, ότι η μια 
διαχειρίζεται τιμές τύπου user και η άλλη δείκτες διεύθυνσης τύπου user.

Καθώς ο τύπος user περιγράφεται ρητά κατά την κατασκευή του τύπου της συνδεδεμένης λίστας, 
η μέθοδος τύπου add, με την σειρά της, αποδέχεται τιμές του τύπου user. Καθώς ένας δείκτης 
διεύθυνσης τύπου user δηλώνεται καθαρά, κατά την κατασκευή του τύπου συνδεδεμένης λίστας, η
μέθοδος τύπου add δέχεται δείκτες διεύθυνσης τύπου user.

Παρατηρεί κανείς στο αποτέλεσμα του προγράμματος, ότι το πεδίο Data για τα στοιχεία της συνδεδεμένης 
λίστας, σε κάθε περίπτωση, ταιριάζει με την σημειολογία των δεδομένων, που χρησιμοποιείται στην 
κατασκευή τους.

* Ασκήσεις

Χρησιμοποιήστε το παρόν πρότυπο ως σημείο αναφοράς προκειμένου να ολοκληρώσετε τις ασκήσεις. Σας παρέχεται μια πιθανή λύση.

** Άσκηση 1

Δηλώστε ένα γενικό τύπο, με το όνομα stack, που χρησιμοποιεί έναν struct 
με μοναδικό πεδίο με το όνομα data, δηλωμένο σαν μια φέτα κάποιου τύπου T. 
Δηλώστε μια μέθοδο τύπου, με το όνομα push, που αποδέχεται μια τιμή κάποιου 
τύπου T και προσθέτει αυτή την τιμή στην φέτα. Δηλώστε μια μέθοδο τύπου με το 
όνομα pop, που επιστρέφει την τελευταία τιμή του τύπου T, που προστέθηκε 
στην φέτα καθώς και ένα σφάλμα. Στην συνέχεια, γράψτε μια συνάρτηση main,
που χρησιμοποιεί αυτές τις μεθόδους τύπου.

.play generics/struct-types/exercise1.go 
.play generics/struct-types/answer1.go
