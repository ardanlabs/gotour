Πίνακες 
Οι πίνακες είναι μια ξεχωριστή δομή δεδομένων στην Go που επιτρέπει την εκχώρηση συνεχόμενων τμημάτων μνήμης σταθερού μεγέθους.

* Πίνακες

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Παρακολουθήστε το Video]]
- Εαν Χρειάζεστε Οικονομική Συνδρομή, Χρησιμοποιείστε το σχετικό [[https://www.ardanlabs.com/scholarship/][Έγγραφο Υποτροφίας]]

Οι πίνακες είναι μια ξεχωριστή δομή δεδομένων στην Go που επιτρέπει την εκχώρηση συνεχόμενων τμημάτων μνήμης 
σταθερού μεγέθους. Οι πίνακες έχουν κάποια ειδικά χαρακτηριστικά στην Go σχετικά με το πως δηλώνονται και 
πως αντιμετωπίζονται ως τύποι.

** Επισκόπηση Κώδικα

- *Παράδειγμα* *1:* Δήλωση, ανάθεση αρχικής τιμής και διαδοχική προσπέλαση
- *Παράδειγμα* *2:* Πίνακες διαφορετικού τύπου
- *Παράδειγμα* *3:* Εκχωρήσεις συνεχούς μνήμης
- *Παράδειγμα* *4:* Μηχανισμός range 

.play arrays/example1.go
.play arrays/example2.go
.play arrays/example3.go
.play arrays/example4.go

** Δηλώνοντας και Εκχωρώντας Αρχικές Τιμές

Δηλώνοντας ένα πίνακα πέντε συμβολοσειρών που λαμβάνει αρχική κατάσταση την κατάσταση μηδενικής τιμής. 

    var strings [5]string

Μια συμβολοσειρά είναι μια αμετάβλητη δομή δεδομένων δύο λέξεων, που αναπαριστά ένα δείκτη διεύθυνσης 
σε ένα υποστηρικτικό πίνακα από byte και τον συνολικό αριθμό byte στον υποστηρικτικό πίνακα. Καθώς
αυτός ο πίνακας παίρνει την κατάσταση μηδενικής τιμής, κάθε στοιχείο παίρνει και αυτό με την σειρά του
την κατάσταση μηδενικής τιμής. Αυτό σημαίνει ότι κάθε συμβολοσειρά έχει την πρώτη λέξη ίση με nil και την 
δεύτερη λέξη ίση με το 0.

.image /tour/grc/static/img/a1.png

** Εκχωρήσεις Συμβολοσειρών 

Τι συμβαίνει όταν μια συμβολοσειρά εκχωρείται σε μια άλλη συμβολοσειρά;

    strings[0] = "Apple"

Όταν μια συμβολοσειρά εκχωρείται σε μια άλλη συμβολοσειρά, αντιγράφεται η τιμή των δύο λέξεων,
με αποτέλεσμα δύο διαφορετικές συμβολοσειρές να μοιράζονται τον ίδιο υποστηρικτικό πίνακα.

.image /tour/grc/static/img/a2.png

Το κόστος αντιγραφής μιας συμβολοσειράς είναι το ίδιο, ανεξάρτητα από το μέγεθος της συμβολοσειράς, 
καθώς πρόκειται για αντιγραφή δύο λέξεων.

** Διαδοχική Προσπέλαση Συλλογών

Η Go παρέχει δύο διαφορετικές σημειολογίες για την διαδοχική προσπέλαση μιας συλλογής. Είναι δυνατόν 
να γίνει η διαδοχική προσπέλαση με σημειολογία τιμής ή με σημειολογία δείκτη διεύθυνσης μνήμης.

    // Διαδοχική Προσπέλαση με Σημειολογία Τιμής
    for i, fruit := range strings {
        println(i, fruit)
    }


    // Διαδοχική Προσπέλαση με Σημειολογία Δείκτη Διεύθυνσης
    for i := range strings {
        println(i, strings[i])
    }

Όταν χρησημοποιείται διαδοχική προσπέλαση με σημειολογία τιμής συμβαίνουν δύο πράγματα. 
Πρώτα, η συλλογή αντιγράφεται και η διαδοχική προσπέλαση γινεται στο αντίγραφο. Στην 
περίτπωση ενός πίνακα, το αντίγραφο μπορεί να κοστίζει να γίνει, καθώς πρόκειται για αντιγραφή
ολόκληρου του πίνακα. Στην περίπτωση ενός δυναμικού πίνακα (slice) δεν υπάρχει πραγματικό κόστος, καθώς 
αντιγράφεται μόνο η τιμή του εσωτερικού δυναμικού πίνακα και όχι ο υποστηρικτικός πίνακας. Στην 
συνέχεια, η διαδοχική προσπέλαση λαμβάνει ένα αντίγραφο κάθε στοιχείου.

Όταν χρησημοποιείται διαδοχική προσπέλαση με σημειολογία δείκτη διεύθυνσης μνήμης, η διαδοχική
προσπέλαση γίενται επί της αρχικής συλλογής και η πρόσβαση κάθε στοιχείου της συλλογής γίνεται άμεσα.

** Διαδοχική Προσπέλαση με Σημειολογία Τιμής 

Παρουσιάζεται ο ακόλουθος κώδικας και το αποτέλεσμα αυτού.

    strings := [5]string{"Apple", "Orange", "Banana", "Grape", "Plum"}
    for i, fruit := range strings {
        println(i, fruit)
    }

Αποτέλεσμα:

    0 Apple
    1 Orange
    2 Banana
    3 Grape
    4 Plum

Η μεταβλητή strings είναι ένας πίνακας 5 συμβολοσειρών. Η διαδοχική προσπέλαση γίνεται
σε κάθε συμβολοσειρά της συλλογής και παρουσιάζεται ο δείκτης θέσης και η τιμή της συμβολοσειράς. 
Εφόσον πρόκειται για διαδοχική προσπέλαση με σημειολογία τιμής, το range της for επισκέπτεται το
δικό της ρηχό αντίγραφο του πίνακα και σε κάθε επανάληψη η μεταβλητή fruit είναι ένα αντίγραφο 
κάθε συμβολοσειράς (της δομής δεδομένων των δύο λέξεων).

Παρατηρεί κανείς πως η μεταβλητή fruit περνάει στην συνάρτηση εκτύπωσης με την χρήσης σημειολογίας 
τιμής. Επίσης η συνάρτηση εκτύπωσης λαμβάνει το δικό της αντίγραφο της τιμής της συμβολοσειράς. Εως ότου 
η συμβολοσειρά έχει περάσει στην συνάρτηση εκτύπωσης, υπάρχουν 4 αντίγραφα της τιμής της συμβολοσειράς
(ο πίνακας, το ρηχό αντίγραφο, η μεταβλητή fruit και το αντίγραφο της συνάρτησης εκτύπωσης). Όλα αυτά τα 
4 αντίγραφα μοιράζονται τον ίδιο υποστηρηκτικό πίνακα από byte. 

.image /tour/grc/static/img/a3.png

Είναι σημαντική η δημιουργία αντιγράφων της τιμής της συμβολοσειράς επειδή κάτι τέτοιο αποτρέπει την τιμή της
συμβολοσειράς να διαφύγει στον σωρό. Με αυτό τον τρόπο, αποκλείονται αναποτελεσματικές εκχωρήσεις μνήμης στον 
σωρό.

** Διαδοχική Προσπέλαση με Σημειολογία Δείκτη Διευθύνσεων

Με βάση τον παρακάτω κώδικα και το αποτέλεσμα από την εκτέλεση του: 

    strings := [5]string{"Apple", "Orange", "Banana", "Grape", "Plum"}
    for i := range strings {
        println(i, strings[i])
    }

Αποτέλεσμα:

    0 Apple
    1 Orange
    2 Banana
    3 Grape
    4 Plum

Ακόμα μια φορά, η μεταβλητή strings είναι ένας πίνακας 5 συμβολοσειρών. Η διαδοχική προσπέλαση 
επισκέφτεται κάθε συμβολοσειρά στην συλλογή και παρουσιάζει τον δείκτη θέσης και την τιμή της συμβολοσειράς.
Καθώς η διαδοχική προσπέλαση χρησιμοποιεί σημειολογία δείκτη διεύθυσνης, το range της for επισκέπτεται 
τον πίνακα strings απευθείας και σε κάθε προσπέλαση, η τιμή συμβολοσειράς, για κάθε δείκτη τοποθεσίας,
περνάει απευθείας στην κλήση παρουσίασης.

** Διαφορετικοί Τύποι Πινάκων

Είναι ενδιαφέρον να δει κανείς τι σφάλμα παρέχει ο μεταγλωττιστής όταν γίνεται ανάθεση 
πινάκων ίδιου τύπου αλλά με διαφορετικό μήκος.

    var five [5]int
    four := [4]int{10, 20, 30, 40}

    five = four

Σφάλμα Μεταγλωττιστή:

    cannot use four (type [4]int) as type [5]int in assignment

Εδώ δηλώνονται δύο πίνακες 5 και 4 ακεραίων. Ο πρώτος λαμβάνει ως αρχική κατάσταση την κατάσταση μηδενικής τιμής.

Στην συνέχεια γίνεται απόπειρα να ανατεθεί ο δεύτερος στον πρώτο και ο μεταγλωττιστής ενημερώνει, "δεν είναι δυνατόν 
να χρησιμοποιηθεί ο four (τύπος [4]int) ως τύπος [5]int στην ανάθεση".

Είναι σημαντικό να ξεκαθαριστεί τι ακριβώς αναφέρει ο μεταγλωττιστής. Αυτό που αναφέρει είναι ότι, 
ένας πίνακας 4 ακεραίων και ένας πίνακας 5 ακεραίων, αναπαριστούν δεδομένα διαφορετικών τύπων.
Το μέγεθος ενός πίνακα είναι μέρος της πληροφορίας που αφορά τον τύπο του. Στην Go, το μέγεθος ενός πίνακα
πρέπει να είναι γνωστό, ήδη από το στάδιο της μεταγλώττισης.

** Κατασκευή Συνεχόμενων Τμημάτων Μνήμης 

Προκειμένου να αποδειχθεί ότι ένας πίνακας παρέχει μια συνεχόμενη διάταξη μνήμης:

    five := [5]string{"Annie", "Betty", "Charley", "Doug", "Bill"}

    for i, v := range five {
        fmt.Printf("Value[%s]\tAddress[%p]  IndexAddr[%p]\n",
            v, &v, &five[i])
    }

Αποτέλεσμα:

    Value[Annie]     Address[0xc000010250]    IndexAddr[0xc000052180]
    Value[Betty]     Address[0xc000010250]    IndexAddr[0xc000052190]
    Value[Charley]   Address[0xc000010250]    IndexAddr[0xc0000521a0]
    Value[Doug]      Address[0xc000010250]    IndexAddr[0xc0000521b0]
    Value[Bill]      Address[0xc000010250]    IndexAddr[0xc0000521c0]

Παραπάνω δηλώνεται ένας πίνακας 5 συμβολοσειρών κα λαμβάνει ως αρχική τιμή κάποιες συμβολοσειρές.
Στην συνέχεια χρησιμοποιείται διαδοχική προσπέλαση με σημειολογία τιμής προκειμένου 
να παρουσιαστούν πληροφορίες για κάθε συμβολοσειρά. Το αποτέλεσμα δείχνει κάθε ξεχωριστή
τιμή συμβολοσειράς, την διεύθυνση της μεταβλητής `v` και την διεύθυνση κάθε στοιχείου στον 
πίνακα.

Είναι προφανές πως ο πίνακας αποτελείται από ένα συνεχόμενο τμήμα μνήμης και πως μια συμβολοσειρά 
είναι μια δομή δεδομένων με δύο λέξεις ή 16 byte σε αρχιτεκτονική 64 bit. Η διεύθυνση για 
κάθε στοιχείο απέχει κατά 16 byte.

Το γεγονός ότι η μεταβλητή `v` έχει την ίδια διεύθυνση σε κάθε διαδοχική προσπέλαση, ενισχύει την 
πεποίθηση ότι η `v` είναι μια τοπική μεταβλητή τύπου συμβολοσειράς, που περιέχει ένα αντίγραφο κάθε 
τιμής συμβολοσειράς κατά την διάρκεια των διαδοχικών προσπέλάσεων.

** Η Ταχεία Μνήμη της CPU

Υπάρχουν πολλές μηχανικές διαφορές μεταξύ επεξεργαστών και των σχεδιασμών τους. Σε
αυτό το μέρος, θα γίνει αναφορά σε υψηλό επίπεδο αφαίρεσης, σχετικά με τους επεξεργαστές και
την σημειολογία, που είναι σχετικά ίδια μεταξύ τους. Αυτή η σημειολογική κατανόηση θα παρέχει ένα
καλό νοητικό υπόδειγμα σχετικά με το πως λειτουργεί ο επεξεργαστής και την συμπάθεια που κανείς 
μπορεί να προσφέρει.

Κάθε πυρήνας εντός του επεξεργαστή έχει την δική του τοπική μνήμη (L1 και L2) και υπάρχει  
και μια κοινή περιοχή μνήμης (L3) η οποία χρησιμοποιείται για την αποθήκευση/προσπέλαση δεδομένων και οδηγιών. Τα φυσικά
νήματα εκτέλεσης σε κάθε πυρήνα μπορούν να έχουν πρόσβαση στην τοπική τους L1 και L2 μνήμη. Τα δεδομένα από την L3 ή από την
κύρια μνήμη πρέπει να αντιγραφούν πρώτα στις L1 και L2 για να μπορούν να προσπελαστούν.

.image /tour/grc/static/img/a4.png

Το κόστος καθυστέρησης πρόσβασης σε δεδομένα που υπάρχουν σε διαφορετικές περιοχές μνήμης αλλάζει
από το χαμηλότερο στο υψηλότερο: L1 -> L2 -> L3 -> κύρια μνήμη. Όπως έχει πει ο Scott Meyers, "Αν η απόδοση
μετράει, τότε η συνολική διαθέσιμη μνήμη είναι το συνολικό μέγεθος των τοπικά διαθέσιμων μνημών. Η κύρια
μνήμη είναι τόσο αργή στην προσπέλαση ώστε, πρακτικά μιλώντας, είναι σαν να μην υπάρχει."

Η απόδοση σήμερα εξαρτάται από το πόσο αποτελεσματικά διακινούνται τα δεδομένα στο υλικό. Αν κάθε 
μεμωνομένο κομμάτι δεδομένων που χρειάζεται το υλικό (σε κάθε δεδομένη στιγμή) υπάρχει μόνο στην κύρια μνήμη, τα
προγράμματα θα τρέχουν πιο αργά, συγκριτικά με προγράμματα, των οποίων τα δεδομένα είναι ήδη παρόντα στην L1 ή στην L2.

    3GHz(3 κύκλοι/ns) * 4 οδηγίες ανά κύκλο = 12 οδηγίες ανά ns!

    1 ns .............................................. 1 ns .............. 12 οδηγίες  (μονάδες) 
    1 µs .......................................... 1,000 ns .......... 12,000 οδηγίες  (εκατοντάδες)
    1 ms ...................................... 1,000,000 ns ...... 12,000,000 οδηγίες  (εκατομμύρια)
    1 s ................................... 1,000,000,000 ns .. 12,000,000,000 οδηγίες  (δισεκατομμύρια)

    Τιμές Καθυστέρησης από την Βιομηχανία
    Τιμή αναφοράς L1             .................... 0.5 ns ..............  6 οδηγίες
    Τιμή αναφοράς L2             ...................... 7 ns .............. 84 οδηγίες
    Τιμή αναφοράς Κύριας μνήμης  .................... 100 ns ............ 1200 οδηγίες

Πως γράφει κανείς κώδικα που εγγυάται ότι, τα δεδομένα που είναι απαραίτητα για την 
εκτέλεση μιας οδηγίας, είναι πάντα παρόντα στην L1 η στην L2? Είναι απαραίτητο να γράφει 
κανείς κώδικα που είναι μηχανικά συμπαθητικός με τον μηχανισμό που εξασφαλίζει στον επεξεργαστή 
τα δεδομένα (prefetcher). Ο μηχανισμός αυτός, προσπαθεί να προβλέψει τι δεδομένα θα χρειαστούν, πριν ακόμα οι οδηγίες
αναζητήσουν τα δεδομένα, ώστε να βρίσκονται ήδη στην μνήμη L1 ή L2. 

Υπάρχουν διαφορετικοί βαθμοί πιστότητας στην προσπέλαση μνήμης, ανάλογα με το που συμβαίνει αυτή
η προπέλαση. Ο κώδικας μπορεί να διαβάσει/γράψει ένα byte μνήμης, ως την μικρότερη δυνατή προσπέλασιμη 
μονάδα μνήμης. Όμως, από την μεριά των συστημάτων αποθήκευσης, η πιστότητα είναι 64 byte. Αυτό το μέρος
της μνήμης των 64 byte αποκαλείται μια σειρά μνήμης ταχείας προσπέλασης (cache line).

Ο μηχανισμός που προβλέπει τι δεδομένα θα χρειαστούν στον επεξεργαστή, δουλεύει πιο αποτελεσματικά
όταν οι οδηγίες που εκτελούνται, δημιουργούν προβλέψιμα μοτίβα προσπέλασης στην μνήμη. Ένας τρόπος για να 
δημιουργηθεί ένα προβλέψιμο μοτίβο προσπέλασης στην μνήμη είναι η δημιουργία ενός σηνεχόμενου τμήματος μνήμης
και στην συνέχεια η πραγματοποίηση μιας διαδοχικής προσπέλαση αυτής της μνήμης, κάνοντας μια γραμμική διέλευση 
με προβλέψιμο βήμα.

Ο πίνακας είναι η πιο σημαντική δομή δεδομένων στο υλικό επειδή υποστηρίζει προβλέψιμα μοτίβα προσπέλασης. Όμως 
ο δυναμικός πίνακας (slice) είναι η πιο σημαντική δομή δεδομένων στην Go. Οι δυναμικοί πίνακες στην Go χρησιμοποιούν 
έναν πίνακα από κάτω.

Όταν κανείς κατασκευάσει έναν πίνακα, κάθε στοιχείο του πίνακα βρίσκεται σε ίδια απόσταση από το επόμενο ή από
το προηγούμενο στοιχείο. Καθώς επισκέπτεται διαδοχικά κανείς ένα πίνακα, διατρέχει κάθε σειρά μνήμης καθώς και κάθε 
άλλη συνδεδεμένη σειρά μνήμης, με προβλέψιμο βήμα. Ο μηχανισμός που εξασφαλίζει δεδομένα στον επεξεργαστή θα αντιληφθεί 
αυτό το προβλέψιμο μοτίβο πρόσβασης δεδομένων και θα ξεκινήσει να φέρνει τα δεδομένα στον επεξεργαστή, μειώνοντας έτσι 
τα κόστη από την καθυστέρηση εξαιτίας της ανάγκης πρόσβασης στα δεδομένα.

Φανταστείτε ότι έχετε ένα μεγάλο τετραγωνικό πίνακα μνήμης και μια συνδεδεμένη λίστα, τα στοιχεία της οποίας ταιριάζουν σε
πλήθος, με τα στοιχεία του πίνακα. Αν κανείς εκτελέσει μια διέλευση, στην συνδεδεμένη λίστα και στην συνέχεια επισκεφθεί τον
πίνακα και στις δύο κατευθύνσεις (Στηλών και Γράμμών), πως θα σχετίζονται οι δύο διελεύσεις, από την άποψη της απόδοσης; 

    func RowTraverse() int {
        var ctr int
        for row := 0; row < rows; row++ {
            for col := 0; col < cols; col++ {
                if matrix[row][col] == 0xFF {
                    ctr++
                }
            }
        }
        return ctr
    }

Η προσπέλαση των γραμμών θα έχει την καλύτερη απόδοση, επειδή διατρέχει την μνήμη, από την μία σειρά μνήμης 
στην επόμενη συνδεδεμένη σειρά μνήμης, κάτι που δημιουργεί ένα προβλέψιμο μοτίβο πρόσβασης. Οι σειρές μνήμης μπορούν 
να αντιγραφούν από τον μηχανισμό παροχής δεδομένων στον επεξεργαστή, στην L1 ή στην L2, πριν ακόμα τα δεδομένα χρειαστούν. 

    func ColumnTraverse() int {
        var ctr int
        for col := 0; col < cols; col++ {
            for row := 0; row < rows; row++ {
                if matrix[row][col] == 0xFF {
                    ctr++
                }
            }
        }
        return ctr
    }

Η διέλευση ανά στήλη είναι η χειρότερη, κατά μια τάξη μεγέθους, επειδή αυτό το μοτίβο πρόσβασης
διατρέχει τα όρια των σελίδων μνήμης του λειτουργικού (OS pages) σε κάθε προσπέλαση μνήμης που πραγματοποιεί. 
Αυτός ο τρόπος διέλευσης δεν μπορεί να δημιουργήσει προβλέψιμα μοτίβα για τις σειρές μνήμης, τις οποίες
εκμεταλεύεται ο μηχανισμός τροφοδότησης με δεδομένα του επεξεργαστή και ουσιαστικά η διαδικασία μετατρέπεται
σε πρόσβαση μνήμης με τυχαίο τρόπο.

    func LinkedListTraverse() int {
        var ctr int
        d := list
        for d != nil {
            if d.v == 0xFF {
                ctr++
            }
            d = d.p
        }
        return ctr
    }

Η συνδεδεμένη λίστα είναι δύο φορές πιο αργή, από την διέλευση επί των γραμμών, κυρίως επειδή υπάρχουν αστοχίες
στην ανάγνωση των γραμμών μνήμης, όμως υπάρχουν και λιγότερες αστοχίες της TLB (Translation Lookaside Buffer). Ένα 
σύνολο των συνδεδεμένων στοιχείων της λίστας υπάρχουν εντός των ίδιων σελίδων μνήμης του λειτουργικού.

    BenchmarkLinkListTraverse-16    128      28738407 ns/λειτουργία
    BenchmarkColumnTraverse-16       30     126878630 ns/λειτουργία
    BenchmarkRowTraverse-16         310      11060883 ns/λειτουργία

** Πλησιέστερη Ενδιάμεση Μνήμη Μεταφοράς Διευθύνσεων (Translation Lookaside Buffer - TLB)

Κάθε πρόγραμμα που εκτελείται, αποκτά μια πλήρη απεικόνιση της εικονικής μνήμης από το 
λειτουργικό, έτσι αυτό το πρόγραμμα πιστεύει ότι έχει διαθέσιμη όλη την φυσική μνήμη στο μηχάνημα. Όμως,
η φυσική μνήμη χρειάζεται να διαμοιράζεται σε όλα τα προγράμματα που εκτελούνται. Το λειτουργικό σύστημα
μοιράζεται την φυσική μνήμη, χωρίζοντας την σε σελίδες και αντιστοιχίζοντας τις σελίδες στην εικονική 
μνήμη, για κάθε πρόγραμμα που εκτελείται. Κάθε λειτουργικό μπορεί να αποφασίσει για το μέγεθος μιας σελίδας,
όμως τα 4k, τα 8k, τα 16k είναι λογικά και κοινώς αποδεκτά μεγέθη.

Η TLB είναι μια μικρή μνήμη, μέσα στον επεξεργαστή, που βοηθάει στον περιορισμό της 
καθυστέρησης, από την μετάφραση μιας εικονικής διεύθυνσης μνήμης, σε μια φυσική διεύθυνση 
μνήμης, εντός του πλαισίου μιας σελίδας του λειτουργικού και της σχετικής θέσης, εντός της 
σελίδας. Μια αστοχία στην εσωτερική μνήμη TLB μπορεί να προκαλέσει μεγάλες καθυστερήσεις, 
επειδή, τώρα, το υλικό πρέπει να περιμένει ώστε το λειτουργικό να ελέγξει τον πίνακα των σελίδων 
που διατηρεί, προκειμένου να εντοπίσει την σωστή σελίδα για την συγκεκριμένη εικονική διεύθυνση 
μνήμης. Αν το πρόγραμμα τρέχει σε ένα εικονικό μηχάνημα (όπως συμβαίνει στο cloud) τότε πρέπει 
να ελεγχθεί πρώτα ο πίνακας των σελίδων του εικονικού μηχανήματος.

Υπενθύμιση όσων αναφέρθηκαν παραπάνω:

Η συνδεδεμένη λίστα είναι δύο φορές πιο αργή από την διέλευση κατά τις γραμμές, κυρίως διότι 
υπάρχουν κάποιες αστοχίες γραμμών μνήμης (cache line misses) όμως υπάρχουν λιγότερες αστοχίες στην TLB (επεξήγηση αργότερα). 
Η πλειονότητα των στοιχείων της συνδεδεμένης λίστας υπάρχουν εντός των σελίδων μνήμης του λειτουργικού.

Η συνδεδεμένη λίστα είναι τάξεις μεγέθους γρηγορότερη από την διέλευση κατά στήλες, 
εξατίας της πρόσβασης στην TLB. Ακόμα και με τις αστοχίες στις γραμμές μνήμης που συμβαίνουν 
στην διέλευση της συνδεδεμένης λίστας, επειδή η πλειονότητα της μνήμης για ένα σύνολο στοιχείων της
θα βρίσκεται εντός της ίδιας σελίδας μνήμης του λειτουργικού, οι καθυστερήσεις της TLB δεν 
επηρεάζουν την απόδοση. Γι' αυτό, για προγράμματα που χρησιμοποιούν μεγάλη ποσόστητα μνήμης, όπως
εφαρμογές που βασίζονται στην επεξεργασία DNA, κανείς θα προτιμούσε να χρησιμοποιήσει μια διανομή
Linux που είναι διαμορφωμένη με μεγέθη σελίδας μνήμης του λειτουργικού της τάξης του ενός ή των δύο megabyte.

Με όλα τα παραπάνω, φαίνεται ότι έχει σημασία ένας σχεδιασμός προσανατολισμένος προς τα δεδομένα. Η συγγραφή ενός 
αποτελεσματικού αλγόριθμου πρέπει να λάβει υπόψη τον τρόπο πρόσβασης στα δεδομένα. Κανείς οφείλει να θυμάται ότι
η αποδοτικότητα σήμερα, αφορά την αποτελεσματικότητα με την οποία είναι δυνατόν να μεταφερθούν τα δεδομένα στον 
επεξεργαστή.

- [[https://youtu.be/WDIkqP4JbkE?t=1129][Ταχείες Μνήμες της CPU και Γιατί σε Ενδιαφέρουν (18:50-20:30)]] - Scott Meyers  
- [[https://youtu.be/WDIkqP4JbkE?t=2676][Ταχείες Μνήμες της CPU και Γιατί σε Ενδιαφέρουν (44:36-45:40)]] - Scott Meyers   
- [[https://youtu.be/jEG4Qyo_4Bc?t=266][Απόδοση Μέσω Ορθής Χρήσης της Ταχείας Μνήμης (4:25-5:48)]] - Damian Gryski  

** Σημειώσεις σχετικά με την Ταχεία Μνήμη της CPU

.html arrays/array_list.html

** Πρόσθετα Διαγράμματα

*Υστερήσεις* *Καθορισμένες* *από* *την* *Βιομηχανία*  

    Ταχεία μνήμη L1  ............................................... 0.5 ns ............  6 οδηγίες
    Αστοχία κλάδου ................................................... 5 ns ............ 60 οδηγίες
    Ταχεία μνήμη L2  ................................................. 7 ns ............ 84 οδηγίες
    Αμοιβαίος αποκλεισμός κλείδωμα/ξεκλείδωμα ....................... 25 ns ........... 300 οδηγίες
    Κύρια μνήμη .................................................... 100 ns .......... 1200 οδηγίες           
    Συμπίεση 1K byte με το Zippy ................................. 3,000 ns (3 µs) .... 36k οδηγίες
    Αποστολή 2K byte σε δίκτυο 1 Gbps ........................... 20,000 ns (20 µs) .. 240k οδηγίες
    Τυχαία ανάγνωση SSD ........................................ 150,000 ns (150 µs) ..1.8M οδηγίες
    Ανάγνωση 1 MB διαδοχικά από μνήμη  ......................... 250,000 ns (250 µs) ....3M οδηγίες
    Κυκλική διαδρομή εντός datacenter .......................... 500,000 ns (0.5 ms) ....6M οδηγίες
    Ανάγνωση 1 MB διαδοχικά από SSD  ......................... 1,000,000 ns (1 ms) ......2M οδηγίες
    Αναζήτηση σε δίσκο ...................................... 10,000,000 ns (10 ms) .....0M οδηγίες
    Ανάγνωση 1 MB διαδοχικά από δίσκο ....................... 20,000,000 ns (20 ms) ....40M οδηγίες
    Αποστολή πακέτου απο Καλιφόρνια->Ολλανδία->Καλιφόρνια .. 150,000,000 ns (150 ms) ....8B οδηγίες

*Εικόνα* *Καθυστέρησης* *Ταχείας* *Μνήμης*

.image /tour/grc/static/img/cache_latencies_graph.png

** Πρόσθετα Αναγνώσματα

*Ταχεία* *Μνήμη* *CPU* */* *Μνήμη*

- [[https://www.youtube.com/watch?v=WDIkqP4JbkE][Ταχείες Μνήμες της CPU και Γιατί σε Ενδιαφέρουν - Video]] - Scott Meyers  
- [[https://www.youtube.com/watch?v=OFgxAFdxYAQ][Ταχύρυθμο Μάθημα για το Σύγχρονο Υλικό - Video]] - Cliff Click  
- [[http://frankdenneman.nl/2016/07/06/introduction-2016-numa-deep-dive-series/][Σειρά Βαθειάς Κατανόησης NUMA]] - Frank Denneman    
- [[http://www.aristeia.com/TalkNotes/codedive-CPUCachesHandouts.pdf][Ταχείες Μνήμες της CPU και Γιατί σε Ενδιαφέρουν]] - Scott Meyers  
- [[https://www.youtube.com/watch?v=MC1EKLQ2Wmg][Απομυθοποιώντας το Σύγχρονο Υλικό για την Απόκτηση 'Μηχανικής Συμπάθειας']] - Martin Thompson  
- [[http://www.akkadia.org/drepper/cpumemory.pdf][Αυτό που Πρέπει να Γνωρίζει κάθε Προγραμματιστής για την Μνήμη]] - Ulrich Drepper  
- [[http://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips][Πως Λειτουργούν οι Ταχείες Μνήμες της CPU και Γιατί]] - Joel Hruska  
- [[http://www.lighterra.com/papers/modernmicroprocessors][Σύγχρονοι Μικροεπεξεργαστές Ένας Οδηγός 90 Λεπτών]] - Jason Robert Carey Patterson  
- [[http://lwn.net/Articles/252125][Μνήμη μέρος 2: Ταχείες Μνήμες της CPU]] - Ulrich Drepper  
- [[http://www.gotw.ca/publications/concurrency-ddj.htm][Το Δωράν Γεύμα δεν Υφίσταται Πια]] - Herb Sutter  
- [[https://m.youtube.com/watch?feature=youtu.be&v=QBu2Ae8-8LM][Υπολογιστές των Data Center: Σύγχρονες Προκλήσεις στον Σχεδιασμό CPU]] - Dick Sites  
- [[https://en.wikipedia.org/wiki/Wirth%27s_law][Ο Νόμος του Wirth]] - Wikipedia  
- [[http://www.drdobbs.com/parallel/eliminate-false-sharing/217500206][Εξάλειψη Εσφαλμένου Διαμοιρασμού]] - Herb Sutter  
- [[http://www.ilikebigbits.com/2014_04_21_myth_of_ram_1.html][Ο Μύθος της Ram]] - Emil Ernerfeldt  
- [[https://www.infoq.com/presentations/hardware-transactional-memory][Κατανοώντας την Μνήμη Υλικού σχετικά με Ταυτόχρονες Συναλλαγές]] - Gil Gene  
- [[https://youtu.be/jEG4Qyo_4Bc?t=266][Αποτελεσματικότητα Μέσω Φιλικής Χρήσης της Ταχείας Μνήμης της CPU (4:25-5:48)]] - Damian Gryski   
- [[https://www.youtube.com/watch?v=2EWejmkKlxs][Φτάνοντας Πουθενά Γρηγορότερα]] - Chandler Carruth  

*Σχεδιασμός* *Επικεντρωμένος* *στα* *Δεδομένα*

- [[https://www.youtube.com/watch?v=rX0ItVEVjHc][Σχεδιασμός Επικεντρωμένος στα Δεδομένα και η C++]] - Mike Acton  
- [[https://www.youtube.com/watch?v=fHNmRkzxHWs][Αποτελεσματικότητα με Αλγόριθμους, Απόδοση με Δομές Δεδομένων]] - Chandler Carruth  
- [[https://www.youtube.com/watch?v=LrVi9LHP8Bk][Δαμάζοντας το Θηρίο της Απόδοσης]] - Klaus Iglberger  
- [[http://harmful.cat-v.org/software/OO_programming/_pdf/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf][Παγίδες του OOP]] - Tony Albrecht  
- [[https://www.youtube.com/watch?v=YQs6IC-vgmo][Γιατί κανείς πρέπει να αποφεύγει τις συνδεδεμένες λίστες]] - Bjarne Stroustrup  
- [[http://gamesfromwithin.com/data-oriented-design][Σχεδιασμός Προσανατολισμένος στα Δεδομένα (Ή Γιατί Ενδέχεται να Πυροβολεί Κανείς Το Πόδι του Με τον OOP)]] - Noel    
- [[https://www.quora.com/Was-object-oriented-programming-a-failure][Ήταν ο αντικειμενοστραφής προγραμματισμός μια αποτυχία;]] - Quora  

** Σημειώσεις

- Αν κανείς δεν κατανοεί τα δεδομένα, δεν κατανοεί ούτε το πρόβλημα.
- Αν κανείς δεν κατανοεί το κόστος επίλυσης του προβλήματος, δεν μπορεί ούτε να επιχειρηματολογήσει σχετικά με το πρόβλημα.
- Αν κανείς δεν κατανοεί το υλικό, δεν μπορεί να επιχειρηματολογήσει σχετικά με το κόστος επίλυσης του προβλήματος.
- Οι πίνακες είναι δομές δεδομένων σταθερού μήκους που δεν μεταβάλλονται.
- Πίνακες διαφορετικών μεγεθών θεωρούνται ότι είναι διαφορετικών τύπων.
- Η μνήμη εκχωρείται σε συνεχόμενα τμήματα.
- Η Go παρέχει έλεγχο στην χωρική τοπικότητα.

* Ασκήσεις

Χρησιμοποιείστε το παρόν πρώτυπο ως αφετηρία για να ολοκληρώσετε τις ασκήσεις. Παρέχεται μια πιθανή λύση.

** Άσκηση 1

Δηλώστε ένα πίνακα 5 συμβολοσειρών με κάθε στοιχείο του πίνακα να λαμβάνει σαν αρχική κατάσταση την κατάσταση 
μηδενικής τιμής. Δηλώστε ένα δεύτερο πίνακα 5 συμβολοσειρών και δώστε αρχικές τιμές στα στοιχεία του με ρητές 
τιμές συμβολοσειράς. Εκχωρείστε τον δεύτερο πίνακα στον πρώτο και παρουσιάστε τα αποτελέσματα του πρώτου πίνακα. 
Παρουσιάστε την τιμή συμβολοσειράς και την διεύθυνση μνήμης κάθε στοιχείου.

.play arrays/exercise1.go
.play arrays/answer1.go
