Data Races
Data race terjadi ketika dua atau lebih goroutine berupaya untuk membaca dan menulis ke sumber daya
yang sama pada saat yang bersamaan.

* Data Races

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Data race terjadi ketika dua atau lebih Goroutine berusaha mengakses lokasi memori yang sama
pada saat yang bersamaan, di mana setidaknya satu Goroutine sedang melakukan operasi tulis.
Ketika ini terjadi, hasilnya tidak dapat diprediksi. Jenis bug ini sulit ditemukan karena
menyebabkan masalah yang selalu terlihat acak.

Video 8 menit dari Scott Meyers ini sangat bagus untuk didengarkan:

[[https://youtu.be/WDIkqP4JbkE?t=1809][CPU Caches and Why You Care 30:09-38:30]]

** Ulasan Kode

- *Contoh* *1:* Data Race
- *Contoh* *2:* Peningkatan Skala Kecil (Atomic)
- *Contoh* *3:* Mutex
- *Contoh* *4:* Membaca/Menulis Mutex
- *Contoh* *5:* Data Race pada Map
- *Contoh* *6:* Kondisi Data Race Berbasis Interface

.play data_race/example1.go
.play data_race/example2.go
.play data_race/example3.go
.play data_race/example4.go
.play data_race/example5.go
.play data_race/example6.go

** Contoh Data Race

Ini adalah contoh bagus dari data race dan bagaimana mereka dapat tersembunyi selama bertahun-tahun,
dan akhirnya muncul pada waktu yang aneh, menyebabkan kerusakan data.

var counter int

    func main() {
        const grs = 2

        var wg sync.WaitGroup
        wg.Add(grs)

        for g := 0; g < grs; g++ {
            go func() {
                for i := 0; i < 2; i++ {
                    value := counter
                    value++
                    counter = value
                }
                wg.Done()
            }()
        }

        wg.Wait()
        fmt.Println("Counter:", counter)
    }

Program ini membuat dua Goroutine yang masing-masing mengakses variabel integer yang sama,
menambahkan nilai variabel tersebut dua kali. Goroutine tersebut melakukan operasi baca,
modifikasi, dan menulis terhadap sumber daya bersama secara manual.

    var counter int

    func main() {
        . . .

        go func() {
            for i := 0; i < 2; i++ {
                value := counter
                value++
                counter = value
            }
            wg.Done()
        }()

        . . .
    }

Anda dapat melihat akses ke status yang bisa diakses bersama di dalam loop for.
Ketika Anda membuat dan menjalankan program ini, Anda akan mendapatkan jawaban yang benar sebanyak 4 setiap kali.

    $ ./example1
    Final Counter: 4

    $ ./example1
    Final Counter: 4

    $ ./example1
    Final Counter: 4

Bagaimana ini bekerja?

    G1                            Shared State: 0                            G2
    ----------------------------------------------------------------------------
    Read:   0
    Modify: 1
    Write:  1                         Shared State: 1
    Context Switch
                                                                      Read: 1
                                                                    Modify: 2
                                    Shared State: 2                  Write: 2
                                                               Context Switch
    Read:   2
    Modify: 3
    Write:  3                         Shared State: 3
    Terminate
                                                                      Read: 3
                                                                    Modify: 4
                                    Shared State: 4                  Write: 4
                                                                    Terminate
    ----------------------------------------------------------------------------

Operasi baca, modifikasi, dan tulis terjadi tanpa henti. Hanya karena saya
mendapatkan jawaban yang benar tidak berarti tidak ada masalah. Apa yang terjadi jika Anda
menambahkan pernyataan log di tengah operasi baca, modifikasi, dan tulis?

    var counter int

    func main() {
        . . .

        go func() {
            for i := 0; i < 2; i++ {
                value := counter
                value++
                log.Println("logging")     <-- Add Logging Here
                counter = value
            }
            wg.Done()
        }()

        . . .
    }

Jika Anda menjalankan program ini, Anda tidak lagi mendapatkan hasil yang sama yaitu 4,
sekarang Anda mendapatkan jawaban yaitu 2.

    $ ./example1
    Final Counter: 2

    $ ./example1
    Final Counter: 2

    $ ./example1
    Final Counter: 2


Apa yang terjadi? Anda mengalami bug data race yang sebelumnya memang ada, tetapi tidak terjadi.
Panggilan ke log sekarang menyebabkan penjadwalan untuk melakukan peralihan konteks antara dua Goroutine
pada waktu yang kurang tepat.

    G1                                Shared State: 0                         G2
    ----------------------------------------------------------------------------
    Read:   0
    Modify: 1
    Context Switch
                                                                        Read:   0
                                                                        Modify: 1
                                                                   Context Switch
    Write:  1                         Shared State: 1
    Read:   1
    Modify: 2
    Context Switch
                                    Shared State: 1                     Write:  1
                                                                        Read:   1
                                                                        Modify: 2
                                                                    Context Switch
    Write:  2                         Shared State: 2
    Terminate
                                    Shared State: 2                     Write:  2
                                                                        Terminate
    ----------------------------------------------------------------------------

Setelah operasi modifikasi, terjadi peralihan konteks. Ketiga operasi tidak lagi berlangsung tanpa henti,
dan Goroutine 2 akhirnya mendapatkan nilai lokal yang salah pada saat menyelesaikan operasi tulis.
Anda sangat beruntung karena ini terjadi setiap kali dan Anda dapat melihatnya. Tetapi biasanya,
data race seperti ini terjadi "secara acak" dan tidak mungkin diketahui sampi semuanya terlambat.
Untungnya, Go memiliki pendeteksi data race (race detector) untuk membantu menemukan data race.

** Mendeteksi Data Race

Ada beberapa cara untuk menggunakan race detector. Anda dapat menggunakannya dengan perintah run, build, dan test.
Jika Anda menggunakannya dengan perintah build, Anda harus ingat untuk menjalankan program.
Mereka mengatakan binary yang telah diinstrumentasi dapat memperlambat program sekitar ~20%.

    $ go build -race
    $ ./example1

Flag -race adalah cara untuk menginstrumentasi perintah build dengan race detector.
Anda mungkin akan menggunakannya lebih banyak dengan "go test," tetapi untuk contoh ini,
Anda menginstrumentasi binary dan kemudian menjalankannya.

    2021/02/01 17:30:52 logging
    2021/02/01 17:30:52 logging
    2021/02/01 17:30:52 logging
    ==================
    WARNING: DATA RACE
    Write at 0x000001278d88 by goroutine 8:
    main.main.func1()
        /data_race/example1/example1.go:41 +0xa6

    Previous read at 0x000001278d88 by goroutine 7:
    main.main.func1()
        /data_race/example1/example1.go:38 +0x4a

    Goroutine 8 (running) created at:
    main.main()
        /data_race/example1/example1.go:36 +0xaf

    Goroutine 7 (finished) created at:
    main.main()
        /data_race/example1/example1.go:36 +0xaf
    ==================
    2021/02/01 17:30:52 logging
    Final Counter: 2
    Found 1 data race(s)

Anda dapat melihat bahwa data race terdeteksi saat menjalankan program. Ini akan terjadi
baik dengan atau tanpa pernyataan log yang ditambahkan. Ketika sebuah data race terdeteksi,
program mengalami panic dan memberikan trace ini. Trace menunjukkan di mana akses tanpa
sinkronisasi ke status bersama terjadi, di mana setidaknya satu akses adalah operasi tulis.

Dalam trace ini, sebuah Goroutine melakukan operasi tulis pada alamat 0x000001278d88 pada baris 41,
dan terjadi baca tanpa sinkronisasi pada alamat yang sama oleh Goroutine lain pada baris 38.
Kedua Goroutine dibuat pada baris 36.

    36 go func() {
    37     for i := 0; i < 2; i++ {
    38         value := counter
    39         value++
    40         log.Println("logging")
    41         counter = value
    42     }
    43     wg.Done()
    44 }()

Anda dapat dengan jelas melihat baca dan tulis tanpa sinkronisasi. Sebagai catatan tambahan,
operasi plus plus pada baris 39 juga akan menjadi data race jika kode mengakses variabel counter.
Operasi plus plus adalah operasi baca, modifikasi, dan juga operasi tulis di dalamnya, dan sistem operasi
dengan mudah dapat melakukan konteks beralih di tengah-tengahnya.

Jadi, bagaimana Anda dapat memperbaiki kode untuk memastikan menghilangkan data race?
Ada dua alat yang dapat Anda gunakan, instruksi atomic dan mutex.

** Atomics

Atomic menyediakan sinkronisasi pada tingkat perangkat keras. Karena itu, mereka terbatas
pada kata-kata dan separuh kata data. Jadi, mereka sangat baik untuk counter atau mekanika pengalihan cepat.
API WaitGroup menggunakan atomic.

Apa perubahan yang perlu Anda lakukan untuk menerapkan atomic pada kode ini?

    var counter int32                             <-- CHANGED

    func main() {
        const grs = 2

        var wg sync.WaitGroup
        wg.Add(grs)

        for g := 0; g < grs; g++ {
            go func() {
                for i := 0; i < 2; i++ {
                    atomic.AddInt32(&counter, 1)  <-- CHANGED
                }
                wg.Done()
            }()
        }

        wg.Wait()
        fmt.Println("Counter:", counter)
    }

Anda hanya perlu melakukan beberapa hal. Pertama, ubah variabel counter menjadi integer berbasis presisi.
Anda dapat melihatnya di bagian atas daftar kode. Fungsi atomic hanya berfungsi dengan integer berbasis presisi.
Kedua, hapus kode baca, modifikasi, dan tulis manual untuk satu panggilan atomic.AddInt32.
Satu panggilan tersebut menangani semuanya.

Semua fungsi yang terkait dengan paket atomic mengambil alamat dari status bersama yang akan disinkronkan.
Sinkronisasi hanya terjadi pada tingkat alamat. Jadi, Goroutine yang berbeda yang memanggil fungsi yang sama,
tetapi dengan alamat yang berbeda, tidak akan disinkronkan.

API atomic terlihat seperti ini:

    func AddInt32(addr *int32, delta int32) (new int32)
    func AddInt64(addr *int64, delta int64) (new int64)
    func AddUint32(addr *uint32, delta uint32) (new uint32)
    func AddUint64(addr *uint64, delta uint64) (new uint64)
    func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)

    func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)
    func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)
    func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)
    func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)
    func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)
    func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)

    func LoadInt32(addr *int32) (val int32)
    func LoadInt64(addr *int64) (val int64)
    func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)
    func LoadUint32(addr *uint32) (val uint32)
    func LoadUint64(addr *uint64) (val uint64)
    func LoadUintptr(addr *uintptr) (val uintptr)

    func StoreInt32(addr *int32, val int32)
    func StoreInt64(addr *int64, val int64)
    func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)
    func StoreUint32(addr *uint32, val uint32)
    func StoreUint64(addr *uint64, val uint64)
    func StoreUintptr(addr *uintptr, val uintptr)

    func SwapInt32(addr *int32, new int32) (old int32)
    func SwapInt64(addr *int64, new int64) (old int64)
    func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)
    func SwapUint32(addr *uint32, new uint32) (old uint32)
    func SwapUint64(addr *uint64, new uint64) (old uint64)
    func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)

    type Value
        func (v *Value) Load() (x interface{})
        func (v *Value) Store(x interface{})

Anda dapat melihat bahwa parameter pertama selalu berupa alamat integer
berbasis presisi atau pointer. Ada juga tipe bernama Value yang
menyediakan nilai sinkron dengan API kecil.

** Mutexes

Jika Anda ingin tetap menggunakan tiga baris kode yang tadi, maka atomik tidak akan berfungsi.
Yang Anda butuhkan adalah mutex. Sebuah mutex memungkinkan Anda mengelompokkan sekelompok kode
sehingga hanya satu Goroutine pada satu waktu yang dapat mengeksekusi kode tersebut.

    var counter int

    func main() {
        const grs = 2

        var wg sync.WaitGroup
        wg.Add(grs)

        var mu sync.Mutex                    <-- CHANGED

        for g := 0; g < grs; g++ {
            go func() {
                for i := 0; i < 2; i++ {
                    mu.Lock()                <-- CHANGED
                    {
                        value := counter
                        value++
                        counter = value
                    }
                    mu.Unlock()              <-- CHANGED
                }
                wg.Done()
            }()
        }

        wg.Wait()
        fmt.Println("Counter:", counter)
    }

Ada beberapa perubahan pada kode ini dari yang asli. Anda menambahkan konstruksi variabel mu
untuk menjadi mutex yang diatur pada nilai nolnya. Kemudian di dalam pengulangan for,
Anda menambahkan panggilan Lock dan Unlock dengan blok kode buatan. Di dalam blok kode,
Anda memiliki kode yang perlu disinkronkan. Blok kode digunakan agar mudah dibaca.

Dengan kode ini di tempat, penjadwal hanya akan mengizinkan satu Goroutine masuk
ke dalam blok kode pada satu waktu. Penting untuk memahami bahwa sebuah mutex bukanlah antrian.
Goroutine pertama yang memanggil Lock tidak selalu Goroutine pertama yang mendapatkan Lock.
Ada algoritma yang adil, tetapi ini dilakukan dengan sengaja agar
orang tidak menggunakan mutex sebagai antrian.

Penting untuk diingat bahwa Lock menciptakan back pressure, jadi semakin lama waktu yang diperlukan
dari Lock ke Unlock, semakin besar kemungkinan Goroutine menunggu giliran mereka. Jika Anda lupa
memanggil Unlock, maka semua Goroutine yang menunggu akan mengalami deadlock. Inilah sebabnya mengapa
sangat penting bahwa panggilan Lock dan Unlock terjadi dalam fungsi yang sama. Pastikan Anda
melakukan sinkronisasi yang paling minimal yang diperlukan di dalam blok kode, tetapi setidaknya minimum.

Ini adalah kode yang sangat buruk di mana seseorang mencoba masuk dan keluar dari Lock
begitu cepat sehingga mereka benar-benar kehilangan sinkronisasi dan detektor data race bahkan
tidak dapat menemukan masalahnya.

    var counter int

    func main() {
        const grs = 2

        var wg sync.WaitGroup
        wg.Add(grs)

        var mu sync.Mutex

        for g := 0; g < grs; g++ {
            go func() {
                for i := 0; i < 2; i++ {
                    var value int
                    mu.Lock()              <-- Bad Use Of Mutex
                    {
                        value = counter
                    }
                    mu.Unlock()

                    value++

                    mu.Lock()              <-- Bad Use Of Mutex
                    {
                        counter = value
                    }
                    mu.Unlock()
                }
                wg.Done()
            }()
        }

        wg.Wait()
        fmt.Println("Counter:", counter)
    }

Sebagai panduan umum, jika Anda melihat panggilan Lock dari mutex yang sama dua kali
dalam fungsi yang sama, hentikan tinjauan kode. Kemungkinan ada kesalahan atau kompleksitas berlebihan.
Dalam kasus ini, panggilan untuk membaca dan menulis disinkronkan, namun, dua Goroutine dapat berakhir
pada baris kode value++. Data race masih ada, dan detektor data race tidak bisa menemukannya.

** Mutex Baca/Tulis

Ada jenis mutex kedua yang disebut mutex baca/tulis. Ini memungkinkan saya memisahkan
kunci sekitar operasi baca dan tulis. Ini penting karena membaca data tidak membahayakan
kecuali jika sebuah Goroutine mencoba menulis pada saat yang bersamaan. Jadi, jenis mutex ini
memungkinkan beberapa Goroutine untuk membaca memori yang sama pada saat yang bersamaan.
Begitu kunci untuk menulis diminta, pembacaan tidak dikeluarkan lagi, proses tulis dilakukan,
dan pembacaan dapat dimulai kembali.

    package main

    import (
        "fmt"
        "math/rand"
        "sync"
        "time"
    )

    var data []string
    var rwMutex sync.RWMutex

    func main() {
        var wg sync.WaitGroup
        wg.Add(1)

        go func() {
            for i := 0; i < 10; i++ {
                writer(i)
            }
            wg.Done()
        }()

        for i := 0; i < 8; i++ {
            go func(id int) {
                for {
                    reader(id)
                }
            }(i)
        }

        wg.Wait()
        fmt.Println("Program Complete")
    }

    func writer(i int) {
        rwMutex.Lock()
        {
            time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
            fmt.Println("****> : Performing Write")
            data = append(data, fmt.Sprintf("String: %d", i))
        }
        rwMutex.Unlock()
    }

    func reader(id int) {
        rwMutex.RLock()
        {
            time.Sleep(time.Duration(rand.Intn(10)) * time.Millisecond)
            fmt.Printf("%d : Performing Read : Length[%d]\n", id, len(data))
        }
        rwMutex.RUnlock()
    }

Anda dapat melihat penggunaan mutex baca/tulis di mana ada 8 Goroutine yang membaca
panjang slice dalam jarak 10 milidetik satu sama lain, dan 1 Goroutine yang membuat
dalam 100 milidetik untuk menambahkan nilai (menulis) ke slice tersebut.

Kuncinya adalah implementasi fungsi writer dan reader. Perhatikan bagaimana Anda menggunakan
Lock untuk writer dan RLock untuk reader. Salah satu kesalahan terbesar yang bisa Anda lakukan
adalah membingungkan panggilan Unlock dengan versi yang salah. Menggunakan Lock dengan RUnlock
tidak akan berakhir dengan baik.

    7 : Performing Read : Length[0]
    5 : Performing Read : Length[0]
    0 : Performing Read : Length[0]
    3 : Performing Read : Length[0]
    7 : Performing Read : Length[0]
    2 : Performing Read : Length[0]
    1 : Performing Read : Length[0]
    ****> : Performing Write
    0 : Performing Read : Length[1]
    5 : Performing Read : Length[1]
    3 : Performing Read : Length[1]
    6 : Performing Read : Length[1]
    7 : Performing Read : Length[1]
    4 : Performing Read : Length[1]
    1 : Performing Read : Length[1]
    2 : Performing Read : Length[1]
    ****> : Performing Write
    7 : Performing Read : Length[2]
    1 : Performing Read : Length[2]
    3 : Performing Read : Length[2]

Keluaran menunjukkan bagaimana beberapa Goroutine membaca pada saat yang sama,
tetapi semua pembacaan berhenti ketika penulisan dilakukan.

** Catatan

- Goroutine perlu dikoordinasikan dan disinkronkan.
- Ketika dua atau lebih goroutine berusaha mengakses sumber daya yang sama, bisa terjadi data race.
- Fungsi atomic dan mutex dapat memberikan dukungan yang diperlukan.

** Cache Coherency and False Sharing

Konten ini disajikan oleh Scott Meyers dari presentasinya pada tahun 2014 di Dive:

[[https://youtu.be/WDIkqP4JbkE?t=1809][CPU Caches and Why You Care (30:09-38:30)]]
[[https://github.com/ardanlabs/gotraining/blob/master/topics/go/testing/benchmarks/falseshare/README.md][Contoh Kode]]

.image /tour/ind/static/img/figure1_data_race.png

** Catatan Cache Coherency and False Sharing

- Akses memori thread penting.
- Jika algoritma Anda tidak scaling, cari masalah false sharing.

** Bacaan Tambahan

- [[http://www.drdobbs.com/parallel/eliminate-false-sharing/217500206][Eliminate False Sharing]] - Herb Sutter
- [[https://golang.org/ref/mem][The Go Memory Model]]
- [[http://blog.golang.org/race-detector][Introducing the Go Race Detector]] - Dmitry Vyukov and Andrew Gerrand
- [[https://www.ardanlabs.com/blog/2013/09/detecting-race-conditions-with-go.html][Detecting Race Conditions With Go]] - William Kennedy
- [[https://golang.org/doc/articles/race_detector.html][Data Race Detector]]

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

Diberikan program berikut, gunakan detektor data race untuk menemukan dan memperbaiki data race.

.play data_race/exercise1.go
.play data_race/answer1.go
