Mocking
Karena kompilator dapat melakukan analisis kode statis untuk menentukan apakah nilai konkret mengimplementasikan sebuah interface,
pengembang yang mendeklarasikan tipe konkret tidak perlu menyediakan interface juga.

* Mocking

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Cara terbaik untuk memanfaatkan penyematan (embedding) adalah melalui pola desain komposisional.
Ide ini adalah untuk menyusun tipe-tipe yang lebih besar dari tipe-tipe yang lebih kecil
dan fokus pada komposisi perilaku.

** Ulasan Kode

- *Contoh* *1:* Mocking

.play composition/mocking/example1.go

** Kepemilikan Interface

Salah satu hal yang berbeda dari Go dibanding bahasa pemrograman lain adalah ide konvensi daripada konfigurasi.
Hal ini sangat terlihat dalam bagaimana Go mengelola kesesuaian interface. Karena kompilator dapat melakukan
analisis kode statis untuk menentukan apakah nilai konkret mengimplementasikan sebuah interface,
pengembang yang mendeklarasikan tipe konkret tidak perlu menyediakan interface juga.

    package pubsub

    type PubSub struct {
        host string
    }

    func New(host string) *PubSub {
        return &PubSub{
            host: host,
        }
    }

    func (ps *PubSub) Publish(key string, v interface{}) error {
        // PRETEND THERE IS A SPECIFIC IMPLEMENTATION.
        return nil
    }

    func (ps *PubSub) Subscribe(key string) error {
        // PRETEND THERE IS A SPECIFIC IMPLEMENTATION.
        return nil
    }

Anda baru saja mengimplementasikan API baru yang menyediakan implementasi konkret
untuk operasi publish dan subscribe. Tidak ada interface yang disediakan karena API ini tidak memerlukannya.
Ini merupakan satu implementasi konkret.

Bagaimana jika pengembang aplikasi yang ingin menggunakan API baru ini membutuhkan sebuah interface
karena mereka perlu melakukan mocking terhadap implementasi ini selama pengujian? Di Go, pengembang tersebut
dapat mendeklarasikan interface, dan kompilator dapat mengidentifikasi kesesuaian terhadap interface tersebut.

    package main

    type publisher interface {
        Publish(key string, v interface{}) error
        Subscribe(key string) error
    }

    type mock struct{}

    func (m *mock) Publish(key string, v interface{}) error {
        // ADD MY MOCK FOR THE PUBLISH CALL.
        return nil
    }

    func (m *mock) Subscribe(key string) error {
        // ADD MY MOCK FOR THE SUBSCRIBE CALL.
        return nil
    }

Kode ini di dalam paket main mendeklarasikan sebuah interface. Interface ini mewakili
API yang digunakan oleh aplikasi dari paket pubsub. Pengembang telah mengimplementasikan i
mplementasi pubsub sendiri untuk pengujian. Kuncinya di sini adalah bahwa pengembang aplikasi ini
tidak menggunakan implementasi konkret secara langsung, tetapi memisahkan diri
melalui interface yang mereka buat sendiri.

    func main() {
        pubs := []publisher{
            pubsub.New("localhost"),
            &mock{},
        }

        for _, p := range pubs {
            p.Publish("key", "value")
            p.Subscribe("key")
        }
    }

Sebagai contoh, fungsi main membuat sebuah koleksi yang diinisialisasi dengan
implementasi pubsub dan implementasi mock. Interface publisher membolehkan hal ini.
Kemudian, dilakukan sebuah perulangan menggunakan for range untuk menunjukkan
bagaimana kode aplikasi diabstraksi dari implementasi konkret apapun.
