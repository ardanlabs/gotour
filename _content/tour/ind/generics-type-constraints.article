Tipe Data Sebagai Batasan
Ini adalah konsep baru dalam Go di mana batasan dapat didasarkan pada kumpulan tipe konkret.

* Generics - Tipe Data Sebagai Batasan

Ini adalah konsep baru dalam Go di mana batasan dapat didasarkan pada kumpulan tipe konkret.
Ini hanya berlaku pada generics.

** Video

Tontonlah presentasi yang saya berikan tentang Generik yang
akan membimbing Anda melalui semua contoh dalam bagian ini dari Tur.

.html generics-video.html

** Ulasan Kode

- *Contoh* *1*: Batasan berbasis tipe
- *Contoh* *2*: Batasan tipe yang telah dideklarasikan sebelumnya "comparable"
- *Contoh* *3*: Tipe data campuran dan batasan perilaku

.play generics/type-constraints/example1.go
.play generics/type-constraints/example2.go
.play generics/type-constraints/example3.go

** Penjelasan

Fungsi generic menciptakan tipe batasan baru yang tidak dapat dipecahkan
dengan mendeklarasikan kumpulan metode perilaku.

    func Add[T ???](v1 T, v2 T) T {
        return v1 + v2
    }

Berikut adalah fungsi generic yang ingin menerima dua nilai dari suatu tipe T, menjumlahkannya,
dan kemudian mengembalikan jumlahnya ke pemanggil. Ini adalah masalah menarik karena kompilator
perlu membatasi pemanggilan fungsi hanya untuk nilai-nilai yang dapat digunakan dalam operasi penjumlahan.
Saat ini tidak ada mekanisme untuk mendeklarasikan jenis batasan ini.

Keputusan yang diambil adalah untuk tetap menggunakan interface untuk mendeklarasikan batasan
dan menambahkan sesuatu yang baru.

    type addOnly interface {
        string | int | int8 | int16 | int32 | int64 | float64
    }

Anda dapat mendeklarasikan sebuah interface yang mendefinisikan kumpulan tipe-tipe yang membentuk batasan.
Kemudian terapkan interface ini ke fungsi generic.

    func Add[T addOnly](v1 T, v2 T) T {
        return v1 + v2
    }

Sekarang kompilator dapat memvalidasi bahwa kumpulan tipe itu sesuai dengan operasi
yang perlu dilakukan oleh fungsi terhadap nilai-nilai dari tipe-tipe tersebut.
Ketika interface menggunakan tipe-tipe bawaan, interface dapat digunakan kembali di seluruh paket.
Ketika daftar tipe mewakili tipe-tipe yang didefinisikan oleh pengguna dari paket, A
nda harus ingat bahwa fungsi generic ini terikat pada tipe-tipe paket dan tidak lebih dari itu.

Interface yang dideklarasikan dengan kumpulan tipe tidak dapat digunakan dalam fungsi polimorfik tradisional.
Ini tidak akan masuk akal, tetapi ini adalah sesuatu yang tidak terasa seperti Go dalam artian bahwa
perubahan terhadap interface ini tidak bersifat selaras.

Salah satu ide adalah memiliki identifier yang telah dideklarasikan sebelumnya untuk batasan operasi umum.

    func index[T comparable](list []T, find T) int {
        for i, v := range list {
            if v == find {
                return i
            }
        }

        return -1
    }

Batasan "comparable" dideklarasikan oleh bahasa dan menerapkan batasan bahwa tipe-tipe
harus dapat digunakan dalam pernyataan perbandingan. Dalam contoh ini, baik v maupun find
adalah variabel bertipe T dan sedang dibandingkan. Ada ide bahwa suatu paket dalam pustaka standar
juga dapat menyediakan kumpulan batasan umum.

Tidak ada pembatasan pada sebuah interface yang dideklarasikan
dengan kumpulan tipe dan set metode perilaku.

    type matcher[T any] interface {
        type person, food
        match(v T) bool
    }

    func match[T matcher[T]](list []T, find T) int {
        for i, v := range list {
            if v.match(find) {
                return i
            }
        }

        return -1
    }

Deklarasikan sebuah interface generic di mana T adalah tipe nilai yang akan diteruskan
ke dalam metode bernama match. Interface ini juga membatasi penggunaannya hanya pada nilai-nilai
dari tipe yang didefinisikan oleh pengguna, yaitu person dan food.

Ketika Anda melihat fungsi match, tidak ada kebutuhan yang jelas untuk membatasi fungsi
hanya pada tipe person dan food. Jika ini adalah kasusnya, fungsi match seharusnya menjadi
fungsi polimorfik tradisional, bukan fungsi generik. Jika ada alasan yang baik,
fungsi generic dapat digunakan untuk menerapkan jenis batasan ini.

Sebagai catatan, diragukan fungsionalitas ini perlu atau masuk akal.
Ini adalah sesuatu yang mungkin perlu diatasi oleh komunitas seiring berjalannya waktu.

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

Implementasikan fungsi generik bernama copyfy yang dibatasi hanya untuk membuat
salinan dari slice bertipe string atau int.

.play generics/type-constraints/exercise1.go
.play generics/type-constraints/answer1.go
