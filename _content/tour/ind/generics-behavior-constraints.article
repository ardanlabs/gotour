Perilaku Sebagai Batasan
Setiap tipe generic memerlukan batasan untuk dideklarasikan sehingga kompiler tahu
substitusi tipe konkret apa yang dapat diterima atau ditolak pada waktu kompilasi.

* Generics - Perilaku Sebagai Batasan

Setiap tipe generic memerlukan batasan untuk dideklarasikan sehingga kompiler tahu substitusi
tipe konkret apa yang dapat diterima atau ditolak pada waktu kompilasi. Ini diperlukan bahkan
jika tidak ada batasan nyata pada tipe generik tersebut, maka dari itu digunakanlah
identifier batasan yang telah dideklarasikan sebelumnya, yaitu "any".

** Video

Tontonlah presentasi yang saya berikan tentang Generik yang
akan membimbing Anda melalui semua contoh dalam bagian ini dari Tur.

.html generics-video.html

** Ulasan Kode

- *Contoh* *1*: Fungsi stringify konkret
- *Contoh* *2*: Fungsi stringify penegasan tipe
- *Contoh* *3*: Fungsi stringify interface
- *Contoh* *4*: Fungsi stringify generic

.play generics/behavior-constraints/example1.go
.play generics/behavior-constraints/example2.go
.play generics/behavior-constraints/example3.go
.play generics/behavior-constraints/example4.go

** Penjelasan

Cukup menarik, konsep batasan sudah ada dalam bahasa ini.

    type User struct {
        name string
    }

    func (u User) String() string {
        return u.name
    }

    type Stringer interface {
        String() string
    }

    func Concrete(u User) {
        u.String()
    }

    func Polymorphic(s Stringer) {
        s.String()
    }

Kode tersebut mendefinisikan tipe konkret bernama User dan mengimplementasikan metode
bernama String yang mengembalikan nama pengguna. Kemudian, sebuah tipe interface
dideklarasikan bernama Stringer, yang mendeklarasikan satu perilaku yaitu String,
yang mengembalikan sebuah string. Berkat metode yang dideklarasikan untuk User,
dapat dikatakan bahwa tipe konkret User mengimplementasikan interface Stringer menggunakan semantik nilai.

Fungsi Konkret hanya sekadar itu, sebuah fungsi yang menerima data konkret berdasarkan apa adanya.
Polimorfik pun demikian, sebuah fungsi yang menerima data konkret berdasarkan apa yang dapat dilakukannya.
Ini adalah perbedaan utama antara fungsi konkret dan polimorfik. Satu terbatas pada satu jenis data,
yang lain tidak. Namun, ada batasan pada data konkret yang dapat diteruskan ke dalam fungsi polimorfik.

Antarmuka Stringer menentukan batasan tersebut dengan mendeklarasikan satu set perilaku
yang harus dapat ditunjukkan oleh data konkret. Ketika digunakan sebagai tipe input,
kompilator dapat menjamin bahwa batasan perilaku terpenuhi setiap kali fungsi dipanggil.

Ada fungsi generik yang akan memerlukan jenis batasan perilaku yang sama.

    func stringify[T fmt.Stringer](slice []T) []string {
        ret := make([]string, 0, len(slice))

        for _, value := range slice {
            ret = append(ret, value.String())
        }

        return ret
    }

Berikut adalah fungsi generic stringify. Fungsi ini menerima sebuah slice dari suatu tipe T
dan mengembalikan sebuah slice dari nilai-nilai string yang berisi versi stringifikasi
dari setiap nilai dari koleksi input. Kunci untuk membuat fungsi ini berfungsi adalah
pemanggilan metode String terhadap setiap nilai dari tipe T.

Permasalahannya adalah bahwa kompilator perlu mengetahui dan memverifikasi bahwa
nilai-nilai dari tipe T memiliki metode bernama String. Ketika tipe generik T dideklarasikan,
interface fmt.Stringer disediakan sebagai batasan. Kompilator sekarang tahu untuk memeriksa
setiap substitusi tipe dan data yang diteruskan ke dalam fungsi untuk kumpulan perilaku ini.

Ini sangat bagus karena interface digunakan kembali untuk tujuan yang sama,
dan bahasa tidak memerlukan kata kunci baru.

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

Implementasikan fungsi generic bernama marshal yang dapat melakukan marshal JSON
tetapi hanya menerima nilai-nilai yang mengimplementasikan antarmuka json.Marshaler.

.play generics/behavior-constraints/exercise1.go
.play generics/behavior-constraints/answer1.go
