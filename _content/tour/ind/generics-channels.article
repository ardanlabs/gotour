Channels
Telusuri bagaimana tim Go dapat menambahkan paket pola konkurensi ke dalam pustaka standar berkat generic.

* Generics - Channels

Telusuri bagaimana tim Go dapat menambahkan paket pola konkurensi ke dalam pustaka standar berkat generic.

** Video

Tontonlah presentasi yang saya berikan tentang Generik yang
akan membimbing Anda melalui semua contoh dalam bagian ini dari Tur.

.html generics-video.html

** Ulasan Kode

- *Contoh* *1*: Work Function
- *Contoh* *2*: Pooling

.play generics/channels/example1.go
.play generics/channels/example2.go

** Penjelasan

Ini akan memerlukan deklarasi channel dan fungsi menggunakan tipe generic.

    type workFn[Result any] func(context.Context) Result

Dalam contoh ini, sebuah tipe dideklarasikan yang mewakili sebuah fungsi yang menerima suatu context
dan mengembalikan nilai tipe generik Result. Deklarasi fungsi ini menggambarkan sebuah fungsi
yang mengimplementasikan pekerjaan konkuren yang akan dilakukan dan hasil dari pekerjaan tersebut.

    func doWork[Result any](ctx context.Context, work workFn[Result]) chan Result {
        ch := make(chan Result, 1)

        go func() {
            ch <- work(ctx)
            fmt.Println("doWork : work complete")
        }()

        return ch
    }

Sekarang tulis sebuah fungsi yang diberi nama doWork yang mengeksekusi
fungsi work yang ditentukan secara konkuren dan mengembalikan sebuah channel agar
pemanggil dapat menerima hasil dari pekerjaan yang dilakukan oleh fungsi work tersebut.
Sebuah tipe generic yang diberi nama Result dideklarasikan untuk mewakili tipe pengembalian
untuk fungsi work dan tipe untuk channel.

Dalam implementasi fungsi doWork, sebuah channel berbuffer satu dibangun dengan tipe generic Result.
Itu adalah channel yang dikembalikan kepada pemanggil untuk menerima hasil dari pekerjaan konkuren.
Di tengah fungsi, sebuah gorutin dibuat untuk mengeksekusi fungsi pekerjaan secara konkuren.
Begitu fungsi pekerjaan mengembalikan nilai, argumen kembalian dikirim kembali ke pemanggil melalui channel.

Untuk menguji penggunaan fungsi doWork, buatlah sebuah program kecil.

    func main() {
        duration := 100 * time.Millisecond

        ctx, cancel := context.WithTimeout(context.Background(), duration)
        defer cancel()

        dwf := func(ctx context.Context) string {
            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
            return "work complete"
        }

        result := doWork(ctx, dwf)

        select {
            case v := <-result:
                fmt.Println("main:", v)
            case <-ctx.Done():
                fmt.Println("main: timeout")
        }
    }

Keluaran:

    doWork : work complete
    main: work complete

Program ini dimulai dengan mendeklarasikan sebuah context yang akan timeout dalam 100 milidetik.
Kemudian sebuah fungsi pekerjaan dideklarasikan yang menunggu hingga 200 milidetik
sebelum mengembalikan string, "pekerjaan selesai". Dengan context dan fungsi pekerjaan yang telah disiapkan,
pemanggilan ke doWork dilakukan dan sebuah channel dengan tipe string dikembalikan dan ditugaskan ke variabel `result`.

Kompilator mampu menentukan tipe konkret yang akan digunakan untuk tipe generic Result
dengan memeriksa tipe pengembalian dari fungsi pekerjaan literal yang diteruskan ke dalam fungsi doWork.
Ini pintar karena artinya Anda tidak perlu menyertakan tipe pada pemanggilan doWork.

Dengan channel berjenis string yang ditugaskan ke variabel result, sebuah sintaks select
digunakan untuk menunggu hasil yang dikembalikan tepat waktu atau untuk timeout terjadi.
Fungsi doWork dapat digunakan untuk melakukan pekerjaan konkuren untuk setiap tipe konkret yang diperlukan.

Ide yang sama ini dapat diterapkan pada sebuah pool goroutine yang dapat mengeksekusi pekerjaan
pada input generic dan mengembalikan hasil generic.

type workFn[Input any, Result any] func(input Input) Result

Dalam contoh ini, ubah tipe fungsi untuk menerima input generic dan mengembalikan hasil generic.

    func poolWork[Input any, Result any](size int, work workFn[Input, Result]) (chan Input, func()) {
        var wg sync.WaitGroup
        wg.Add(size)

        ch := make(chan Input)

        for i := 0; i < size; i++ {
            go func() {
                defer wg.Done()
                for input := range ch {
                    result := work(input)
                    fmt.Println("pollWork :", result)
                }
            }()
        }

        cancel := func() {
            close(ch)
            wg.Wait()
        }

        return ch, cancel
    }

Dalam fungsi poolWork, dua tipe generic yang sama dideklarasikan untuk mewakili tipe input
dan tipe pengembalian untuk fungsi work. Sebuah WaitGroup dibuat untuk mengelola siklus hidup Goroutine dalam pool.
Kemudian sebuah channel dibangun dari tipe Input generic. Channel ini digunakan oleh Goroutine dalam pool
untuk menerima data input untuk fungsi work.

Kemudian, pool Goroutine dibuat dengan setiap Goroutine menunggu dalam operasi penerimaan
menggunakan loop for-range terhadap channel. Terakhir, fungsi pembatalan dibuat untuk memungkinkan pemanggil
menonaktifkan pool dan menunggu semua Goroutine memberi sinyal bahwa mereka telah selesai.

Untuk menguji penggunaan fungsi poolWork, bangunlah sebuah program kecil kedua.

    func main() {
        size := runtime.GOMAXPROCS(0)

        pwf := func(input int) string {
            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
            return fmt.Sprintf("%d : received", input)
        }

        ch, cancel := poolWork(size, pwf)
        defer cancel()

        for i := 0; i < 4; i++ {
            ch <- i
        }
    }

Keluaran:

    pollWork : 3 : received
    pollWork : 2 : received
    pollWork : 1 : received
    pollWork : 0 : received

Ukuran pool dihitung berdasarkan jumlah Goroutine yang dapat berjalan secara parallel.
Kemudian, fungsi pekerjaan dibuat untuk tidur selama jangka waktu acak dan kemudian
mengembalikan sebuah string yang merepresentasikan input.

Dengan itu, fungsi poolWork dijalankan, dan channel serta fungsi pembatalan dikembalikan.
Dilakukan defer pada pemanggilan fungsi cancel, dan sebuah loop dibuat untuk mengirimkan 4 nilai ke dalam pool.
Keluaran akan berbeda setiap kali Anda menjalankan program karena pekerjaan ini terjadi secara konkuren.

Contoh-contoh kecil ini memberikan wawasan tentang bagaimana paket konkuren dapat diimplementasikan.
