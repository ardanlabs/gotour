Pemisahan (Decoupling)
Komposisi melampaui mekanisme tipe penyematan (embedding) dan lebih dari sekadar paradigma.

* Pemisahan (Decoupling)

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Cara terbaik untuk memanfaatkan penyematan adalah melalui pola desain komposisional.
Ini merupakan kunci untuk menjaga stabilitas perangkat lunak dengan memiliki kemampuan
untuk beradaptasi dengan perubahan data dan transformasi yang akan datang.

** Ulasan Kode

- *Contoh* *1:* Komposisi Struct
- *Contoh* *2:* Pemisahan dengan Interface
- *Contoh* *3:* Komposisi Interface
- *Contoh* *4:* Pemisahan dengan Komposisi Interface
- *Contoh* *5:* Menghilangkan Polusi Interface
- *Contoh* *6:* API yang Lebih Tepat

.play composition/decoupling/example1.go
.play composition/decoupling/example2.go
.play composition/decoupling/example3.go
.play composition/decoupling/example4.go
.play composition/decoupling/example5.go
.play composition/decoupling/example6.go

** Mekanisme Pemisahan

Ide ini adalah untuk menggabungkan tipe-tipe yang lebih besar dari tipe-tipe yang lebih kecil
dan fokus pada komposisi perilaku.

    type Xenia struct {
        Host    string
        Timeout time.Duration
    }

    func (*Xenia) Pull(d *Data) error {
        switch rand.Intn(10) {
        case 1, 9:
            return io.EOF
        case 5:
            return errors.New("Error reading data from Xenia")
        default:
            d.Line = "Data"
            fmt.Println("In:", d.Line)
            return nil
        }
    }

Tipe Xenia mewakili sistem tempat Anda akan menarik data. Implementasinya tidak penting.
Yang penting adalah bahwa metode Pull dapat berhasil, gagal, atau tidak memiliki data untuk ditarik.

    type Pillar struct {
        Host    string
        Timeout time.Duration
    }

    func (*Pillar) Store(d *Data) error {
        fmt.Println("Out:", d.Line)
        return nil
    }

Tipe Pillar mewakili sistem di mana Anda perlu menyimpan data. Yang penting sekali lagi adalah
bahwa metode Store dapat berhasil atau gagal.

Kedua tipe ini mewakili lapisan kode primitif yang menyediakan perilaku dasar yang diperlukan
untuk menyelesaikan masalah bisnis menarik data dari Xenia dan menyimpan data tersebut ke Pillar.

    func Pull(x *Xenia, data []Data) (int, error) {
        for i := range data {
            if err := x.Pull(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

    func Store(p *Pillar, data []Data) (int, error) {
        for i := range data {
            if err := p.Store(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

Lapisan kode berikutnya direpresentasikan oleh dua fungsi ini, Pull dan Store.
Mereka membangun pada lapisan kode primitif dengan menerima kumpulan nilai data
yang akan ditarik atau disimpan dalam sistem yang bersangkutan. Fungsi-fungsi ini
berfokus pada tipe konkret Xenia dan Pillar karena itulah sistem-sistem
yang program perlu tangani pada saat ini.

    func Copy(sys *System, batch int) error {
        data := make([]Data, batch)

        for {
            i, err := Pull(&sys.Xenia, data)
            if i > 0 {
                if _, err := Store(&sys.Pillar, data[:i]); err != nil {
                    return err
                }
            }

            if err != nil {
                return err
            }
        }
    }

Fungsi Copy dibangun di atas fungsi Pull dan Store untuk memindahkan semua data
yang tertunda untuk setiap eksekusi. Jika Anda perhatikan parameter pertama Copy,
itu adalah tipe yang disebut System.

    type System struct {
        Xenia
        Pillar
    }

Ide awal dari tipe System adalah menggabungkan sistem yang tahu cara Pull dan Store.
Dalam hal ini, menggabungkan kemampuan Pull dan Store dari Xenia dan Pillar.

    func main() {
        sys := System{
            Xenia: Xenia{
                Host:    "localhost:8000",
                Timeout: time.Second,
            },
            Pillar: Pillar{
                Host:    "localhost:9000",
                Timeout: time.Second,
            },
        }

        if err := Copy(&sys, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Akhirnya, fungsi utama dapat ditulis untuk membuat objek Xenia dan Pillar dalam komposisi dari sebuah System.
Kemudian, System dapat diteruskan ke fungsi Copy dan data dapat mulai mengalir antara kedua sistem tersebut.

Dengan semua kode ini, Anda sekarang memiliki konsep awal dari solusi konkret untuk masalah konkret.

** Pemisahan dengan Interface

Langkah berikutnya adalah memahami apa yang bisa berubah dalam program. Dalam hal ini,
yang dapat berubah adalah sistem-sistem itu sendiri. Hari ini mungkin Xenia dan Pillar,
besok bisa jadi Alice dan Bob. Dengan pengetahuan ini, Anda ingin memisahkan solusi konkret
yang ada dari perubahan ini. Untuk melakukannya, Anda ingin mengubah fungsi-fungsi konkret
menjadi fungsi-fungsi polimorfik.

    func Pull(p Puller, data []Data) (int, error) {
        for i := range data {
            if err := p.Pull(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

    func Store(s Storer, data []Data) (int, error) {
        for i := range data {
            if err := s.Store(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

Saat ini, fungsi Pull menerima nilai Xenia dan fungsi Store menerima nilai Pillar.
Pada akhirnya, bukan Xenia dan Pillar yang penting, yang penting adalah nilai konkret
yang tahu cara Pull dan Store. Anda dapat mengubah fungsi-fungsi konkret ini menjadi polimorfik
dengan meminta data berdasarkan apa yang dapat dilakukannya daripada tipe apa itu.

    type Puller interface {
        Pull(d *Data) error
    }

    type Storer interface {
        Store(d *Data) error
    }

Kedua interface ini menjelaskan apa yang harus dilakukan oleh data konkret dan
tipe-tipe inilah yang diganti dalam deklarasi fungsi Pull dan Store.
Sekarang fungsi-fungsi ini bersifat polimorfik.Ketika Alice dan Bob dideklarasikan
dan diimplementasikan sebagai Puller dan Storer,mereka dapat diteruskan
ke dalam fungsi-fungsi tersebut.

Ini belum selesai. Fungsi Copy juga perlu bersifat polimorfik.

    func Copy(ps PullStorer, batch int) error {
        data := make([]Data, batch)

        for {
            i, err := Pull(ps, data)
            if i > 0 {
                if _, err := Store(ps, data[:i]); err != nil {
                    return err
                }
            }

            if err != nil {
                return err
            }
        }
    }

Fungsi Copy tidak lagi meminta nilai System,
melainkan nilai konkret apa pun yang tahu cara Pull dan Store.

    type PullStorer interface {
        Puller
        Storer
    }

Interface PullStorer dideklarasikan melalui penggunaan komposisi. Ini terdiri dari antarmuka Puller dan Storer.
Berusaha untuk menggabungkan interface yang lebih besar dari yang lebih kecil.

Perhatikan bagaimana variabel PullStorer sekarang diteruskan ke dalam fungsi Pull dan Store.
Bagaimana ini bisa terjadi ketika informasi tipe berbeda?

    // func Pull(p Puller, data []Data) (int, error) {
    i, err := Pull(ps, data)

    // func Store(s Storer, data []Data) (int, error) {
    if _, err := Store(ps, data[:i]); err != nil {

Anda selalu perlu mengingat, Anda tidak pernah meneruskan nilai interface di sekitar program Anda
karena interface tidak ada dan tidak punya nilai. Anda hanya dapat meneruskan data konkret.
Jadi, data konkret yang disimpan di dalam variabel interface ps lah yang diteruskan ke Pull dan Store.
Bukankah benar, nilai konkret yang disimpan di dalam ps harus tahu cara Pull dan Store?

.image /tour/ind/static/img/comp1.png

Karena System terdiri dari Xenia dan Pillar, System mengimplementasikan interface PullStorer.
Dengan perubahan ini, Anda sekarang dapat membuat tipe konkret baru yang mengimplementasikan interface PullStorer.

    type System1 struct {
        Xenia
        Pillar
    }

    type System2 struct {
        Alice
        Bob
    }

    type System3 struct {
        Xenia
        Bob
    }

    type System4 struct {
        Alice
        Pillar
    }

Ketika Anda memikirkan ini lebih lanjut, mendeklarasikan tipe-tipe System yang berbeda
untuk semua kombinasi mungkin tidak realistis. Ini akan berfungsi, tetapi masalah pemeliharaan
memerlukan solusi yang lebih baik.

** Komposisi Interface

Bagaimana jika Anda memutuskan untuk menggabungkan tipe sistem konkret Anda dari dua tipe interface?

    type System struct {
        Puller
        Storer
    }

Ini adalah solusi yang menarik. Ini akan memungkinkan aplikasi untuk menyuntikkan Puller atau Storer konkret
ke dalam sistem saat startup aplikasi.

    func main() {
        sys := System{
            Puller: &Xenia{
                Host:    "localhost:8000",
                Timeout: time.Second,
            },
            Storer: &Pillar{
                Host:    "localhost:9000",
                Timeout: time.Second,
            },
        }

        if err := Copy(&sys, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Tipe sistem ini mengimplementasikan antarmuka PullStorer untuk semua kombinasi tipe konkret yang mungkin.

.image /tour/ind/static/img/comp2.png

Dengan perubahan ini, aplikasi sepenuhnya terpisah dari perubahan ke sistem baru
yang mungkin muncul seiring waktu.

**Ulasan yang Lebih Teliti

Pertanyaan selanjutnya yang harus diajukan adalah, apakah fungsi-fungsi polimorfik ini telah akurat?
Ini adalah bagian dari proses rekayasa yang tidak bisa dilewatkan.
Jawabannya adalah tidak, dua perubahan dapat dilakukan.

    func Copy(sys *System, batch int) error {

Fungsi Copy tidak perlu bersifat polimorfik lagi karena hanya akan ada satu tipe System.
Tipe interface PullStorer dapat dihapus dari program. Ingat, Anda memindahkan polimorfisme
ke dalam tipe ketika Anda menggunakan komposisi dengan tipe interface.

    func Copy(p Puller, s Storer, batch int) error {

Ini adalah perubahan lain yang dapat dilakukan pada fungsi Copy. Perubahan ini
membuat fungsi lebih tepat dan polimorfik lagi. Sekarang fungsi ini meminta persis
apa yang dibutuhkannya berdasarkan apa yang dapat dilakukan data konkret.

.image /tour/ind/static/img/comp3.png

Dengan perubahan tersebut, tipe struct System juga dapat dihapus dari program.

    func main() {
        x := Xenia{
            Host:    "localhost:8000",
            Timeout: time.Second,
        }

        p := Pillar{
            Host:    "localhost:9000",
            Timeout: time.Second,
        }

        if err := Copy(&x, &p, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Dengan menghapus tipe PullStorer dan System, program menjadi lebih sederhana.
Fungsi utama dapat fokus pada pembuatan nilai konkret Puller dan Storer
yang diperlukan untuk memindahkan data tersebut. Sistem tipe dan API lebih tepat.
Ide presisi ini berasal dari Edsger W. Dijkstra.

"The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise". - Edsger W. Dijkstra

** Catatan

- Ini jauh lebih dari mekanika penyematan tipe (embedding).
- Deklarasikan tipe dan implementasikan alur kerja dengan komposisi dalam pikiran.
- Pahami masalah yang ingin Anda selesaikan terlebih dahulu. Ini berarti memahami data.
- Tujuannya adalah mengurangi dan meminimalkan perubahan berantai di seluruh perangkat lunak Anda.
- Interface memberikan bentuk komposisi tertinggi.
- Jangan kelompokkan tipe berdasarkan DNA bersama tetapi berdasarkan perilaku bersama.
- Semua orang dapat bekerja sama ketika kita fokus pada apa yang kita lakukan dan bukan pada apa yang kita miliki.

** Kutipan

"A good API is not just easy to use but also hard to misuse." - JBD

"You can always embed, but you cannot decompose big interfaces once they are out there. Keep interfaces small." - JBD

"Don't design with interfaces, discover them." - Rob Pike

"Duplication is far cheaper than the wrong abstraction. - Sandi Metz

** Pedoman Desain

Belajar lebih lanjut mengenai [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#interface-and-composition-design][pedoman desain]] untuk komposisi.

** Bacaan Tambahan

- [[https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and][Repeat yourself, do more than one thing, and rewrite everything]] - tef
- [[https://golang.org/doc/effective_go.html#embedding][Embedding]]
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methods, Interfaces and Embedding]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2015/09/composition-with-go.html][Composition In Go]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2016/10/reducing-type-hierarchies.html][Reducing Type Hierarchies]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2016/10/avoid-interface-pollution.html][Avoid Interface Pollution]] - William Kennedy

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

Menggunakan templat ini, deklarasikan serangkaian tipe konkret yang mengimplementasikan
serangkaian tipe interface yang telah ditentukan. Kemudian buat nilai-nilai dari tipe-tipe tersebut
dan gunakan mereka untuk menyelesaikan serangkaian tugas yang telah ditentukan.

.play composition/decoupling/exercise1.go
.play composition/decoupling/answer1.go
