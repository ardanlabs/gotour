Batasan Slice
Mungkin ada saat-saat di mana Anda perlu membatasi tipe generic hanya menjadi sebuah slice.

* Generics - Batasan Slice

Mungkin ada saat-saat di mana Anda perlu membatasi tipe generic hanya menjadi sebuah slice.

** Video

Tontonlah presentasi yang saya berikan tentang Generik yang
akan membimbing Anda melalui semua contoh dalam bagian ini dari Tur.

.html generics-video.html

** Ulasan Kode

- *Contoh* *1*: Fungsi operate

.play generics/slice-constraints/example1.go

** Penjelasan

Di sini, tipe Numbers yang didefinisikan pengguna memiliki tipe dasar berupa slice dari bilangan bulat.

    type Numbers []int

Kompilator memungkinkan Anda mengonversi variabel berdasarkan sebuah slice dari bilangan bulat
dengan variabel berjenis Numbers. Ini biasanya baik dan sesuai dengan yang diinginkan.
Berkat fungsionalitas ini, Anda dapat menulis fungsi generic yang dapat beroperasi pada suatu slice
dengan memperhatikan tipe dasarnya.

    type operateFunc[T any] func(t T) T

    func operate[T any](slice []T, fn operateFunc[T]) []T {
        ret := make([]T, len(slice))
            for i, v := range slice {
            ret[i] = fn(v)
        }

        return ret
    }

Di sini, fungsi operate mendeklarasikan tipe generik T yang dapat menjadi apa saja.
Tipe tersebut digunakan untuk mendeklarasikan parameter bernama slice
yang menerima sebuah slice dari tipe T yang sama. Fungsi ini juga menerima sebuah fungsi generik
dari tipe T yang sama, dan mengembalikan sebuah slice dari T juga.

    type Numbers []int

    func Double(n Numbers) Numbers {
        fn := func(n int) int {
            return 2 * n
        }

        numbers := operate(n, fn)
        fmt.Printf("%T", numbers)
        return numbers
    }

Keluaran:

    []int

Fungsi Double menerima sebuah nilai bertipe Numbers dan meneruskan nilai tersebut ke dalam fungsi operate.
Dalam hal ini, kompilator memanfaatkan tipe dasar untuk tipe T, dan nilai Numbers dapat diteruskan ke dalam fungsi.
Namun, yang dikembalikan adalah sebuah slice bertipe int, seperti yang terlihat dalam keluaran.

Jika Anda perlu memastikan bahwa hanya nilai Numbers yang dapat diteruskan masuk dan dikembalikan oleh fungsi operate,
Anda dapat melakukan perubahan sebagai berikut.

    type Slice[T any] interface {
        ~ []T
    }

Interface ini mendeklarasikan sebuah batasan untuk membatasi tipe generic menjadi sebuah slice dari suatu tipe T.
Penggunaan elemen perkiraan ~ membatasi ke semua tipe yang memiliki tipe dasar T.
Dengan interface ini, Anda dapat mengubah fungsi operate.

    type operateFunc[T any] func(t T) T
    type Slice[T any] interface {
        ~ []T
    }

    // func operate[T any](slice []T, fn operateFunc[T]) []T {
    //     ret := make([]T, len(slice))
    //     for i, v := range slice {
    //         ret[i] = fn(v)
    //     }
    //     return ret
    // }

    func operate[S Slice[T], T any](slice S, fn operateFunc[T]) S {
        ret := make(S, len(slice))
        for i, v := range slice {
            ret[i] = fn(v)
        }

        return ret
    }

Sekarang ubah fungsi operate untuk mendeklarasikan dua tipe generic. Tipe S yang mewakili
nilai slice dari suatu tipe T, dan T yang merupakan tipe yang dapat menjadi apa saja.
Fungsi ini mengembalikan sebuah nilai bertipe S.

    type Numbers []int

    func Double(n Numbers) Numbers {
        fn := func(n int) int {
            return 2 * n
        }

        numbers := operate(n, fn)
        fmt.Printf("%T", numbers)

        return numbers
    }

Keluaran:

    main.Numbers

Kali ini, ketika Anda meneruskan nilai Numbers ke dalam fungsi operate, slice yang dikembalikan adalah bertipe Numbers.
Tipe dasarnya diabaikan dan tipe yang didefinisikan oleh pengguna digunakan.