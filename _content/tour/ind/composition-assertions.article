Konversi dan Pernyataan Tipe
Belajar bagaimana konversi tipe data (type conversion) dan pernyataan tipe data (type assertion) bekerja

* Konversi dan Pernyataan Tipe

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Konversi tipe memungkinkan data dari satu tipe untuk dikonversi ke tipe lain.
Pernyataan tipe memungkinkan Anda untuk menanyakan apakah ada nilai dari tipe yang diberikan
yang disimpan di dalam sebuah antarmuka (interface).

** Ulasan Kode

- *Contoh* *1:* Konversi Antarmuka
- *Contoh* *2:* Pernyataan Tipe pada Waktu Eksekusi
- *Contoh* *3:* Perubahan Perilaku

.play composition/assertions/example1.go
.play composition/assertions/example2.go
.play composition/assertions/example3.go

** Konversi Antarmuka Implisit

Seperti yang Anda lihat pada contoh terakhir, sebuah nilai antarmuka dari satu tipe
dapat diteruskan untuk tipe antarmuka yang berbeda jika nilai konkret yang disimpan
di dalam antarmuka mengimplementasikan kedua perilaku tersebut. Ini dapat dianggap
sebagai konversi antarmuka implisit, tetapi lebih baik untuk memikirkan bagaimana
data konkret dipindahkan melalui antarmuka dalam keadaan terpisah.

    type Mover interface {
        Move()
    }

    type Locker interface {
        Lock()
        Unlock()
    }

    type MoveLocker interface {
        Mover
        Locker
    }

Diberikan contoh tiga antarmuka(interface) ini, di mana MoveLocker adalah komposisi dari Mover dan Locker.

    type bike struct{}

    func (bike) Move() {
        fmt.Println("Moving the bike")
    }

    func (bike) Lock() {
        fmt.Println("Locking the bike")
    }

    func (bike) Unlock() {
        fmt.Println("Unlocking the bike")
    }

Dan diberikan tipe konkret bertipe `bike` yang mengimplementasikan ketiga antarmuka tersebut.
Apa yang dapat Anda lakukan?

    var ml MoveLocker
    var m Mover

Anda dapat membuat nilai dari tipe MoveLocker dan Mover ke dalam keadaan nilai nol.
Ini adalah nilai antarmuka yang benar-benar tidak memiliki nilai.

    ml = bike{}

Kemudian, Anda dapat membuat nilai dari tipe `bike` ke dalam keadaan nilai nol
dan menetapkan salinan ke variabel MoveLocker ml. Ini dimungkinkan karena `bike`
mengimplementasikan ketiga perilaku, dan kompiler dapat melihat bahwa implementasi tersebut ada.

    m = ml

Anda kemudian dapat menetapkan variabel MoveLocker ml ke variabel Mover m.
Ini mungkin karena saya tidak menetapkan nilai antarmuka ml
tetapi nilai konkret yang disimpan di dalam ml yang merupakan nilai bertipe `bike`.
Kompiler tahu bahwa setiap nilai konkret yang disimpan di dalam ml juga harus mengimplementasikan antarmuka Mover.

Namun, penugasan ini tidak valid.

    ml = m

Keluaran:

    cannot use m (type Mover) as type MoveLocker in assignment:
        Mover does not implement MoveLocker (missing Lock method)

Anda tidak dapat menetapkan variabel Mover m kembali ke variabel MoveLocker ml karena
kompiler hanya dapat menjamin bahwa nilai konkret yang disimpan di dalam m tahu `Move`.
Pada waktu kompilasi, tidak diketahui apakah nilai konkret juga tahu `Lock` dan `Unlock`.

** Mekanisme Pernyataan Tipe

Pernyataan tipe memungkinkan Anda pada waktu eksekusi untuk bertanya,
apakah ada nilai dari tipe yang diberikan yang disimpan di dalam sebuah antarmuka.
Anda melihat hal ini dengan sintaks m.(bike).

    b := m.(bike)
    ml = b

Dalam kasus ini, Anda bertanya apakah ada nilai bertipe `bike` yang disimpan
di dalam m pada saat kode dieksekusi. Jika ya, maka variabel b akan diberikan
salinan nilai `bike` yang disimpan. Kemudian salinan dapat disalin ke dalam variabel antarmuka ml.

Jika tidak ada nilai `bike` yang disimpan di dalam nilai antarmuka, maka program akan menyebabkan panic.
Anda menginginkan ini jika seharusnya ada nilai `bike` yang disimpan.
Bagaimana jika ada kemungkinan tidak ada dan itu valid? Maka Anda membutuhkan bentuk kedua dari pernyataan tipe.

    b, ok := m.(bike)

Dalam bentuk ini, jika ok bernilai true, ada nilai `bike` yang disimpan di dalam antarmuka.
Jika ok bernilai false, maka tidak ada, dan program tidak menyebabkan panic.
Namun, variabel b tetap bertipe `bike`, tetapi diatur ke dalam keadaan nilai nol.

    func main() {
        mvs := []fmt.Stringer{
            Car{},
            Cloud{},
        }

        for i := 0; i < 10; i++ {
            rn := rand.Intn(2)

            if v, is := mvs[rn].(Cloud); is {
                fmt.Println("Got Lucky:", v)
                continue
            }

            fmt.Println("Got Unlucky")
        }
    }

Dengan asumsi program mendeklarasikan dua tipe bernama Car dan Cloud yang masing-masing
mengimplementasikan antarmuka `fmt.Stringer`, Anda dapat membuat sebuah koleksi yang
memungkinkan Anda menyimpan nilai dari kedua Car dan Cloud. Kemudian, sebanyak 10 kali,
Anda secara acak memilih sebuah angka dari 0 hingga 1, dan melakukan pernyataan tipe
untuk melihat apakah nilai di indeks acak tersebut berisi nilai Cloud.
Karena mungkin nilai tersebut bukan tipe Cloud, bentuk kedua dari pernyataan tipe sangat penting di sini.
