Embedding
Tipe embedding (penyematan) menyediakan elemen terakhir dalam berbagi dan
menggunakan kembali status dan perilaku antar tipe.

* Embedding

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Tipe embedding memberikan bagian terakhir dari berbagi dan menggunakan kembali
status dan perilaku antar tipe. Melalui penggunaan promosi tipe bagian dalam,
atribut dan metode tipe bagian dalam dapat diakses secara langsung melalui referensi tipe luar.

** Ulasan Kode

- *Contoh* *1:* Mendeklarasikan Atribut
- *Contoh* *2:* Tipe Embedding
- *Contoh* *3:* Tipe-tipe Embedding dan Interfaces
- *Contoh* *4:* Implementasi Interface Tipe Luar dan Tipe bagian Dalam

.play embedding/example1.go
.play embedding/example2.go
.play embedding/example3.go
.play embedding/example4.go

** Mekanisme Embedding

Contoh pertama ini tidak menunjukkan embedding, hanya deklarasi dua tipe struct
yang bersatu bersama sebagai atribut dari satu tipe ke tipe lainnya.

    type user struct {
        name  string
        email string
    }

    type admin struct {
        person user        // NOT Embedding
        level  string
    }

Ini embedding.

    type user struct {
        name  string
        email string
    }

    type admin struct {
        user               // Value Semantic Embedding
        level  string
    }

Atribut "person" dihapus dan hanya nama tipe yang tersisa. Anda juga dapat
menyematkan (embed) sebuah tipe menggunakan semantik pointer.

    type user struct {
        name  string
        email string
    }

    type admin struct {
        *user              // Pointer Semantic Embedding
        level  string
    }

Dalam kasus ini, pointer dari tipe tersebut disematkan. Dalam kedua kasus tersebut,
mengakses nilai yang disematkan dilakukan melalui penggunaan nama tipe.

Cara terbaik untuk memahami embedding adalah dengan melihat tipe user sebagai tipe dalam
dan admin sebagai tipe luar. Hubungan tipe dalam/luar inilah yang memiliki keajaiban,
karena dengan embedding, semua yang terkait dengan tipe inner (baik atribut maupun metode)
dapat dipromosikan ke tipe luar.

    type user struct {
        name  string
        email string
    }

    func (u *user) notify() {
        fmt.Printf("Sending user email To %s<%s>\n",
            u.name,
            u.email)
    }

    type admin struct {
        *user              // Pointer Semantic Embedding
        level  string
    }

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        ad.user.notify()
        ad.notify() // Outer type promotion
    }

Keluaran:

    Sending user email To john smith<john@yahoo.com>
    Sending user email To john smith<john@yahoo.com>

Setelah Anda menambahkan metode bernama "notify" untuk tipe user dan kemudian sebuah fungsi main yang kecil,
Anda dapat melihat bahwa keluarannya sama, baik Anda memanggil metode "notify" melalui nilai pointer bagian dalam
secara langsung maupun melalui nilai tipe bagian luar. Metode "notify" yang dideklarasikan untuk tipe user
dapat diakses secara langsung melalui nilai tipe admin.

Meskipun ini terlihat seperti inheritance, Anda harus berhati-hati. Ini bukan tentang penggunaan kembali status,
melainkan tentang mempromosikan perilaku.

    type notifier interface {
        notify()
    }

    func sendNotification(n notifier) {
        n.notify()
    }

Sekarang Anda menambahkan sebuah interface dan fungsi polimorfik yang menerima nilai konkret apa pun
yang mengimplementasikan set metode penuh perilaku yang didefinisikan oleh interface notifier.
Yang hanya memiliki metode bernama "notify".

Karena adanya embedding dan promosi, nilai dengan tipe admin sekarang mengimplementasikan
interface notifier.

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        sendNotification(&ad)
    }

Keluaran:

    Sending user email To john smith<john@yahoo.com>

Anda dapat mengirimkan alamat nilai admin ke dalam fungsi polimorfik karena
embedding mempromosikan perilaku "notify" ke tipe admin.

    type admin struct {
        *user  // Pointer Semantic Embedding
        level  string
    }

    func (a *admin) notify() {
        fmt.Printf("Sending admin Email To %s<%s>\n",
            a.name,
            a.email)
    }

Ketika tipe yang luar mengimplementasikan metode yang sudah diimplementasikan
oleh tipe bagian dalam, promosi tidak terjadi.

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        sendNotification(&ad)
    }

Keluaran:

    Sending admin email To john smith<john@yahoo.com>

Anda dapat melihat bahwa metode tipe bagian luar sekarang dieksekusi.

** Catatan

- Tipe embedding memungkinkan kita untuk berbagi status keadaan atau perilaku antar tipe.
- Tipe bagian dalam tidak pernah kehilangan identitasnya.
- Ini bukanlah pewarisan (inheritance).
- Melalui promosi, atribut dan metode tipe bagian dalam dapat diakses melalui tipe luar.
- Tipe luar dapat menggantikan perilaku tipe bagian dalam.

** Bacaan Tambahan

- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methods, Interfaces and Embedded Types in Go]] - William Kennedy
- [[https://rakyll.org/typesystem/][Embedding is not inheritance]] - JBD

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

Edit kode dari templat ini. Tambahkan tipe baru CachingFeed yang menyematkan Feed dan mengganti metode Fetch.

.play embedding/exercise1.go
.play embedding/answer1.go
