Masalah-masalah Menarik
Bagian ini berisi beberapa tantangan yang menarik yang menampilkan beberapa kemampuan yang ditawarkan oleh Go.

* Masalah Tukang Cukur Tidur (Sleeping Barber)

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Contoh program ini menunjukkan implementasi dari masalah tukang cukur yang tertidur

- Kunjungi lebih lanjut di [[https://en.wikipedia.org/wiki/Sleeping_barber_problem][https://en.wikipedia.org/wiki/Sleeping_barber_problem]]

Ada satu tukang cukur di tempat pangkas rambut, satu kursi tukang cukur, dan `n` kursi untuk
pelanggan yang menunggu. Jika tidak ada pelanggan, tukang cukur akan duduk di kursi tukang cukur
dan tidur siang. Pelanggan yang datang harus membangunkan tukang cukur.
Pelanggan yang datang selanjutnya mengambil kursi tunggu jika ada yang kosong atau
pergi jika semua kursi sudah penuh.

*Keluaran:*

    Opening the shop
    Barber ready to work
    Customer "cust-1" entered shop
    Customer "cust-1" takes a seat and waits
    Barber servicing customer "cust-1"
    Barber finished customer "cust-1"
    Barber taking a nap
    Customer "cust-2" entered shop
    Customer "cust-2" takes a seat and waits
    Barber servicing customer "cust-2"
    Customer "cust-3" entered shop
    Customer "cust-3" takes a seat and waits
    Barber finished customer "cust-2"
    Barber servicing customer "cust-3"
    Customer "cust-4" entered shop
    Customer "cust-4" takes a seat and waits
    Closing the shop
    Barber finished customer "cust-3"
    Barber servicing customer "cust-4"
    Barber finished customer "cust-4"
    Shop closed

.play algorithms/fun/barber.go

* Masalah Frekuensi

Contoh program ini menunjukkan kepada Anda bagaimana mengimplementasikan fungsi
yang dapat menemukan frekuensi karakter(rune) tertentu yang digunakan dalam kalimat tertentu.

- Concurrent: A concurrent algorithm to perform a rune count.
- Bersamaan(Concurrent): Algoritma bersamaan untuk melakukan penghitungan karakter(rune).

.play algorithms/fun/freq_sequential.go
.play algorithms/fun/freq_concurrent.go

*  Pengkodean/penguraian kuantitas panjang variabel (Variable Length Quantity encoding/decoding)

Contoh program ini menunjukkan bagaimana Go dapat dimanfaatkan untuk mengimplementasikan pengkodean/penguraian kuantitas panjang variabel (VLQ).

- Kunjungi lebih lanjut di [[https://en.wikipedia.org/wiki/Variable-length_code][https://en.wikipedia.org/wiki/Variable-length_code]]

Singkatnya, tujuan dari pengkodean ini adalah untuk menyimpan nilai-nilai integer
dengan cara yang dapat menghemat ruang byte. Hanya 7 bit pertama dari setiap byte yang signifikan
(7 bit pertama dari kanan (right-justified); seperti byte ASCII). Jadi, jika Anda memiliki nilai 32-bit,
Anda harus membongkarnya menjadi serangkaian byte 7-bit. Tentu saja, Anda akan mendapatkan
sejumlah variabel byte tergantung pada bilangan bulat Anda. Untuk menunjukkan yang mana
adalah byte terakhir dari rangkaian, biarkan bit ke-7 kosong. Di semua
byte sebelumnya, Anda menyetel bit #7.

Jadi, jika bilangan bulat antara 0-127, maka dapat direpresentasikan sebagai satu byte.
Bilangan bulat terbesar yang diperbolehkan adalah 0FFFFFFF, yang diterjemahkan menjadi variabel panjang 4 byte.
Berikut adalah contoh waktu delta sebagai nilai 32-bit, dan variabelnya
besaran panjang yang diterjemahkan menjadi:

    NUMBER        VARIABLE QUANTITY
    00000000              00
    00000040              40
    0000007F              7F
    00000080             81 00
    00002000             C0 00
    00003FFF             FF 7F
    00004000           81 80 00
    00100000           C0 80 00
    001FFFFF           FF FF 7F
    00200000          81 80 80 00
    08000000          C0 80 80 00
    0FFFFFFF          FF FF FF 7F

Kuantitas panjang variabel (VLQ) adalah kode universal yang menggunakan sejumlah
jumlah oktet biner (byte 8bit) untuk mewakilkan bilangan bulat yang besar.
Ini didefinisikan untuk digunakan dalam format file MIDI standar[1]
guna menghemat ruang tambahan pada sistem yang terbatas sumber daya,
dan juga digunakan dalam format Extensible Music Format (XMF) yang lebih baru.
VLQ pada dasarnya adalah basis-128 representasi bilangan bulat tak bertanda dengan penambahan bit kedelapan
untuk menandai kelanjutan byte. Lihat contoh di bawah ini.


	Int:    16384
	IntHex: 0x00004000
	IntBin: 00000000 00000000 01000000 00000000
	VLQHex: 0x81 0x80 0x00
	VLQBin: 00000000 10000001 10000000 00000000

Katakanlah saya ingin merepresentasikan angka 3435 di VLQ.
3435 dalam biner adalah 110101101011.
Kita tidak dapat memuatnya dalam satu byte.
Jadi, kita akan memotongnya dari ujung dalam blok 7 bit.

    Septet	7	6	5	4	3	2	1
    #1		1	1	0	1	0	1	1
    #2		0	0	1	1	0	1	0

Sekarang kita menambahkan semua kecuali yang terakhir dengan 1-bit untuk menunjukkan bahwa itu adalah oktet
mengikuti dan menambahkan 0-bit ke bit terakhir, menandakan oktet terakhir.

    Octet   8	7	6	5	4	3	2	1
    #1      0	1	1	0	1	0	1	1
    #2      1	0	0	1	1	0	1	0

Akhirnya kami menggabungkannya, oktet paling signifikan terlebih dahulu, menjadi

Terkode: 10011010 01101011. Dalam bentuk heksadesimal: 0x9A 0x6B.

*Bacaan* *Tambahan:*

- [[https://en.wikipedia.org/wiki/Variable-length_quantity][https://en.wikipedia.org/wiki/Variable-length_quantity]]
- [[https://blogs.infosupport.com/a-primer-on-vlq/][https://blogs.infosupport.com/a-primer-on-vlq/]]

*Contoh* *sebuah* *implementasi* *yang* *bagus* *dari* *algoritma* *ini*, *lihat* *disini*:

- [[https://github.com/go-audio/midi/blob/master/varint.go][https://github.com/go-audio/midi/blob/master/varint.go]]

.play algorithms/fun/vlq.go