Dasar-Dasar
Belajar cara membuat generic dasar dengan fungsi `print`.

* Dasar-Dasar Generic

Belajar cara membuat generic dasar dengan fungsi `print`.

** Video

Tontonlah video pembahasan yang saya berikan tentang Generics
yang akan membimbing Anda melalui semua contoh dalam bagian dari Tur ini.

.html generics-video.html

** Ulasan Kode

- *Contoh* *1*: Implementasi dari fungsi `print`
- *Contoh* *2*: Implementasi Pernyataan Tipe dari fungsi `print`
- *Contoh* *3*: Implementasi Refleksi dari fungsi `print`
- *Contoh* *4*: Implementasi Generik dari fungsi `print`

.play generics/basics/example1.go
.play generics/basics/example2.go
.play generics/basics/example3.go
.play generics/basics/example4.go

** Penjelasan

Jika Anda ingin menulis fungsi `print` yang dapat mengeluarkan slice dari jenis apa pun
tanpa menggunakan `reflection`, Anda dapat menggunakan sintaks generics yang baru.

    func print[T any](slice []T) {
        fmt.Print("Generic: ")

        for _, v := range slice {
            fmt.Print(v, " ")
        }

        fmt.Print("\n")
    }

Ini adalah implementasi dari fungsi `print` tunggal yang dapat mengeluarkan slice dari jenis apa pun
menggunakan sintaks generics baru. Yang bagus dari sintaks ini adalah bahwa kode di dalam fungsi
dapat menggunakan sintaks dan fungsi bawaan yang akan berfungsi dengan tipe konkret.
Ini tidak terjadi ketika Anda menggunakan antarmuka kosong untuk menulis kode generics.

Perlu ada cara untuk memberi tahu kompiler bahwa Anda tidak akan mendeklarasikan tipe T secara eksplisit,
tetapi tipe tersebut harus ditentukan oleh kompiler saat waktu kompilasi.
Sintaks baru menggunakan tanda kurung siku untuk ini. Tanda kurung tersebut mendefinisikan
daftar pengidentifikasi tipe generik yang mewakili tipe-tipe khusus untuk fungsi yang perlu ditentukan
pada waktu kompilasi. Inilah cara Anda memberi tahu kompiler bahwa tipe-tipe dengan nama ini
tidak akan dideklarasikan sebelum program dikompilasi. Tipe-tipe ini perlu diketahui pada waktu kompilasi.

Catatan: Anda dapat memiliki beberapa pengidentifikasi tipe yang ditentukan di dalam tanda kurung,
meskipun contoh saat ini hanya menggunakan satu. Contoh: [T, S, R any]

Anda dapat memberi nama pengidentifikasi tipe ini sesuka hati untuk meningkatkan kemudahan dibaca dari kode.
Dalam hal ini, kode menggunakan huruf kapital T untuk menjelaskan bahwa sebuah slice dari tipe tertentu T
(akan ditentukan pada waktu kompilasi) akan disertakan. Ini adalah idiom untuk menggunakan huruf tunggal
yang dikapitalisasi ketika berkaitan dengan kumpulan data (collection), dan juga sebuah konvensi
yang berasal dari bahasa pemrograman yang lebih tua seperti C++ dan Java.

Ada penggunaan kata "any" di dalam tanda kurung juga. Ini mewakili suatu batasan pada jenis tipe T.
Kompiler mensyaratkan bahwa semua tipe generik memiliki batasan yang terdefinisi dengan baik.
Batasan "any" telah dideklarasikan sebelumnya oleh kompiler dan menyatakan bahwa tidak ada batasan
pada jenis tipe T dapat menjadi apa saja.

    numbers := []int{1, 2, 3}
    print[int](numbers)

    strings := []string{"A", "B", "C"}
    print[string](strings)

    floats := []float64{1.7, 2.2, 3.14}
    print[float64](floats)

Inilah cara memanggil fungsi `print` generik di mana informasi tipe untuk T secara eksplisit
diberikan di lokasi pemanggilan fungsi. Sintaks tersebut meniru ide bahwa
deklarasi fungsi `func name[T any](slice []T)` mempunyai dua set parameter.
Set pertama adalah tipe yang sesuai dengan pengidentifikasi tipe yang sesuai,
dan yang kedua adalah data yang sesuai dengan variabel input yang sesuai.

Untungnya, kompiler dapat menyimpulkan tipe dan menghilangkan kebutuhan untuk secara eksplisit
menyertakan informasi tipe di lokasi pemanggilan.

    numbers := []int{1, 2, 3}
    print(numbers)

    strings := []string{"A", "B", "C"}
    print(strings)

    floats := []float64{1.7, 2.2, 3.14}
    print(floats)

Kode ini menunjukkan bagaimana Anda dapat memanggil fungsi `print` generik
tanpa perlu menyertakan informasi tipe secara eksplisit. Di lokasi pemanggilan fungsi,
kompiler dapat mengidentifikasi tipe yang akan digunakan untuk T
dan membangun versi konkret dari fungsi untuk mendukung slice dari tipe tersebut.
Kompiler memiliki kemampuan untuk menyimpulkan tipe dengan informasi yang dimilikinya
di lokasi panggilan dari data yang sedang diproses.

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

Buatlah fungsi generiC bernama marshal yang dapat menerima nilai apa pun
dan mengonversi nilai tersebut menjadi JSON, mengembalikan JSON dan sebuah error.
Deklarasikan tipe struktur bernama User dengan dua field, Name dan Age.
Kemudian buatlah nilai dari tipe User dan lewatkan nilai tersebut ke fungsi marshal generik.

.play generics/basics/exercise1.go
.play generics/basics/answer1.go
