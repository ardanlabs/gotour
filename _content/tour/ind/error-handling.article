Error Handling
Error handling (Penanganan kesalahan) sangat penting untuk membuat program Anda dapat diandalkan, tepercaya,
dan menghormati mereka yang bergantung pada program tersebut.

* Desain Error Handling

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Integritas penting dan merupakan bagian besar dari proses rekayasa. Pada intinya,
integritas melibatkan penanganan kesalahan. Ketika berbicara tentang Go, penanganan kesalahan
bukanlah suatu pengecualian yang akan ditangani nanti atau di tempat lain dalam kode.
Ini adalah bagian dari jalur utama dan perlu menjadi fokus utama.

Pengembang memiliki tanggung jawab untuk memberikan konteks yang cukup tentang setiap kesalahan
sehingga pengguna dapat membuat keputusan yang berinformasi tentang bagaimana melanjutkan.
Penanganan kesalahan melibatkan tiga hal: mencatat kesalahan, tidak meneruskan kesalahan lebih jauh,
dan menentukan apakah Goroutine/program perlu dihentikan.

Dalam Go, tipe error hanyalah nilai sehingga mereka dapat menjadi apa saja yang Anda butuhkan.
Mereka dapat mempertahankan setiap keadaan atau perilaku.

** Ulasan Kode

- *Contoh* *1:* Nilai Error Default
- *Contoh* *2:* Variabel Error
- *Contoh* *3:* Tipe Sebagai Konteks
- *Contoh* *4:* Perilaku Sebagai Konteks
- *Contoh* *5:* Temukan Bug
- *Contoh* *6:* Membungkus Error Dengan stdlib

.play error-handling/example1.go
.play error-handling/example2.go
.play error-handling/example3.go
.play error-handling/example4.go
.play error-handling/example5.go
.play error-handling/example6.go

** Dasar-dasar Penanganan Kesalahan

Error interface sudah ada dalam bahasa Go.

    // http://golang.org/pkg/builtin/#error
    type error interface {
        Error() string
    }

Inilah sebabnya mengapa tampak sebagai identifier yang tidak diekspor. Nilai konkret apa pun
yang mengimplementasikan interface ini dapat digunakan sebagai nilai error.

Aspek penting dari Go adalah bahwa penanganan kesalahan dilakukan dalam keadaan terpisah
melalui interface ini. Alasan utama untuk ini adalah karena penanganan kesalahan merupakan
aspek aplikasi yang lebih rentan terhadap perubahan dan perbaikan. Interface ini adalah tipe
yang harus digunakan oleh aplikasi Go sebagai tipe kembalian untuk penanganan kesalahan.

    // http://golang.org/src/pkg/errors/errors.go
    type errorString struct {
        s string
    }

    // http://golang.org/src/pkg/errors/errors.go
    func (e *errorString) Error() string {
        return e.s
    }

Ini adalah nilai error yang paling umum digunakan dalam program Go. Ini dideklarasikan
dalam paket errors dari pustaka standar. Perhatikan bagaimana tipe ini tidak diekspor
dan memiliki satu atribut yang tidak diekspor yang merupakan string. Anda juga dapat melihat
bagaimana semantik pointer digunakan untuk mengimplementasikan error interface ini.
Ini berarti hanya alamat ke nilai tipe ini yang dapat dibagikan dan disimpan dalam interface.
Metodenya hanya mengembalikan string error.

Penting untuk diingat, implementasi metode Error berfungsi untuk mengimplementasikan
interface dan untuk pencatatan. Jika pengguna perlu melakukan parse string yang dikembalikan dari metode ini,
Anda gagal memberikan pengguna jumlah konteks yang tepat untuk membuat keputusan yang informatif.

    // http://golang.org/src/pkg/errors/errors.go
    func New(text string) error {
        return &errorString{text}
    }

Fungsi New adalah cara membuat error menggunakan tipe konkret errorString. Perhatikan
bagaimana fungsi mengembalikan error menggunakan error interface. Juga perhatikan
bagaimana semantik pointer digunakan.

    func main() {
        if err := webCall(); err != nil {
            fmt.Println(err)
            return
        }
        fmt.Println("Life is good")
    }

    func webCall() error {
        return New("bad request")
    }

Konteks adalah segalanya dalam penanganan kesalahan. Setiap kesalahan harus memberikan
konteks yang cukup agar pemanggil dapat membuat keputusan yang informatif tentang k
eadaan goroutine/aplikasi. Dalam contoh ini, fungsi webCall mengembalikan error dengan
pesan Bad Request. Di fungsi utama, panggilan dibuat ke webCall dan kemudian dilakukan
pemeriksaan untuk melihat apakah terjadi kesalahan pada panggilan tersebut.

    if err := webCall(); err != nil {
        fmt.Println(err)
        return
    }

Kunci dari penanganan kesalahan ini adalah dengen memeriksa `err != nil`. Apa yang dimaksud
oleh kondisi ini adalah apakah ada nilai konkret yang disimpan di dalam nilai interface err.
Ketika nilai interface menyimpan nilai konkret, maka ada kesalahan. Dalam hal ini,
konteksnya sebenarnya hanya fakta bahwa ada nilai konkret, tidak penting apa nilai konkretnya.

Bagaimana jika penting untuk mengetahui nilai kesalahan apa yang ada di dalam variabel interface err?
Maka, variabel error adalah opsi yang baik.

    var (
        ErrBadRequest = errors.New("Bad Request")
        ErrPageMoved = errors.New("Page Moved")
    )

Variabel Error menyediakan cara untuk mengidentifikasi kesalahan spesifik yang dikembalikan.
Mereka memiliki idiom yang dimulai dengan awalan Err dan didasarkan pada
tipe konkret errorString dari paket errors.

    func webCall(b bool) error {
        if b {
            return ErrBadRequest
        }
        return ErrPageMoved
    }

Dalam versi baru dari webCall ini, fungsi mengembalikan salah satu variabel error.
Ini memungkinkan pemanggil untuk menentukan kesalahan mana yang terjadi.

    func main() {
        if err := webCall(true); err != nil {
            switch err {
            case ErrBadRequest:
                fmt.Println("Bad Request Occurred")
                return

            case ErrPageMoved:
                fmt.Println("The Page moved")
                return

            default:
                fmt.Println(err)
                return
            }
        }

        fmt.Println("Life is good")
    }

Dalam aplikasi setelah panggilan ke webCall, pemeriksaan dapat dilakukan untuk melihat
apakah ada nilai konkret yang disimpan di dalam variabel interface err. Jika ada,
maka digunakan pernyataan switch untuk menentukan kesalahan mana dengan membandingkan err
dengan berbagai variabel error.

Dalam hal ini, konteks kesalahan didasarkan pada variabel error mana yang dikembalikan.
Bagaimana jika variabel error tidak memberikan konteks yang cukup? Bagaimana jika perlu
memeriksa keadaan khusus, seperti pada kesalahan jaringan? Dalam kasus-kasus tersebut,
tipe kesalahan konkret khusus adalah jawabannya.

    type UnmarshalTypeError struct {
        Value string
        Type  reflect.Type
    }

    func (e *UnmarshalTypeError) Error() string {
        return "json: cannot unmarshal " + e.Value +
            " into Go value of type " + e.Type.String()
    }

Ini adalah tipe error konkret kustom yang diimplementasikan dalam paket json.
Perhatikan bahwa nama tersebut memiliki sufiks Error dalam penamaan tipe. Juga perhatikan
penggunaan semantik pointer untuk implementasi interface error. Sekali lagi, implementasi ini
adalah untuk pencatatan dan seharusnya menampilkan informasi tentang semua atribut yang ditangkap.

    type InvalidUnmarshalError struct {
        Type reflect.Type
    }

    func (e *InvalidUnmarshalError) Error() string {
        if e.Type == nil {
            return "json: Unmarshal(nil)"
        }
        if e.Type.Kind() != reflect.Ptr {
            return "json: Unmarshal(non-pointer " + e.Type.String() + ")"
        }
        return "json: Unmarshal(nil " + e.Type.String() + ")"
    }

Ini adalah tipe error konkret kustom kedua yang ditemukan dalam paket json.
Implementasi metode Error sedikit lebih kompleks, tetapi sekali lagi hanya
untuk pencatatan dan menggunakan semantik pointer.

    func Unmarshal(data []byte, v interface{}) error {
        rv := reflect.ValueOf(v)
        if rv.Kind() != reflect.Ptr || rv.IsNil() {
            return &InvalidUnmarshalError{reflect.TypeOf(v)}
        }
        return &UnmarshalTypeError{"string", reflect.TypeOf(v)}
    }

Berikut adalah sebagian dari fungsi Unmarshal. Perhatikan bagaimana ia membuat
nilai error konkret dalam kembalian, melewatkan kembali ke pemanggil melalui interface error.
Konstruksi semantik pointer digunakan karena semantik pointer digunakan dalam deklarasi metode Error.

Konteks error di sini lebih berkaitan dengan jenis error yang disimpan di dalam interface error.
Perlu ada cara untuk menentukannya.

    func main() {
        var u user
        err := Unmarshal([]byte(`{"name":"bill"}`), u)
        if err != nil {
            switch e := err.(type) {
            case *UnmarshalTypeError:
                fmt.Printf("UnmarshalTypeError: Value[%s] Type[%v]\n",
                    e.Value, e.Type)
            case *InvalidUnmarshalError:
                fmt.Printf("InvalidUnmarshalError: Type[%v]\n", e.Type)
            default:
                fmt.Println(err)
            }
            return
        }
        fmt.Println("Name:", u.Name)
    }

Sebuah pernyataan tipe generik dalam ruang lingkup pernyataan switch adalah cara Anda
dapat menulis kode untuk menguji jenis nilai yang disimpan di dalam nilai interface error.
Tipe merupakan konteks di sini dan sekarang Anda dapat menguji dan mengambil tindakan
dengan akses ke semua status error.

Namun, ini menimbulkan satu masalah. Saya tidak lagi terpisah dari nilai konkret error.
Ini berarti jika nilai error konkret diubah, kode saya dapat rusak.
Bagian yang indah dari menggunakan interface untuk penanganan kesalahan adalah
terlepas dari perubahan yang dapat merusak.

Jika nilai error konkret memiliki set metode, maka Anda dapat menggunakan interface untuk pemeriksaan tipe.
Sebagai contoh, paket net memiliki banyak tipe error konkret yang mengimplementasikan metode berbeda.
Salah satu metode umumnya disebut Temporary. Metode ini memungkinkan pengguna menguji apakah kesalahan jaringan
bersifat kritis atau hanya sesuatu yang dapat pulih sendiri.

    type temporary interface {
        Temporary() bool
    }

    func (c *client) BehaviorAsContext() {
        for {
            line, err := c.reader.ReadString('\n')
            if err != nil {
                switch e := err.(type) {
                case temporary:
                    if !e.Temporary() {
                        log.Println("Temporary: Client leaving chat")
                        return
                    }
                default:
                    if err == io.EOF {
                        log.Println("EOF: Client leaving chat")
                        return
                    }
                    log.Println("read-routine", err)
                }
            }
            fmt.Println(line)
        }
    }

Dalam kode ini, panggilan ke ReadString dapat gagal dengan kesalahan dari paket net.
Dalam hal ini, sebuah interface dideklarasikan yang mewakili perilaku umum yang dapat
diimplementasikan oleh nilai error konkret tertentu. Kemudian, dengan pernyataan tipe generik,
Anda menguji apakah perilaku tersebut ada dan Anda dapat memanggilnya. Bagian terbaiknya,
Anda tetap berada dalam keadaan terpisah dengan penanganan kesalahan Anda.

** Selalu Gunakan Error Interface

Salah satu kesalahan yang dapat dibuat oleh pengembang Go adalah saat menggunakan
tipe error konkret dan bukan interface error sebagai tipe kembalian untuk menangani kesalahan.
Jika Anda melakukan ini, hal-hal yang tidak diinginkan dapat terjadi.

    type customError struct{}

    func (c *customError) Error() string {
        return "Find the bug."
    }

    func fail() ([]byte, *customError) {
        return nil, nil
    }

    func main() {
        var err error
        if _, err = fail(); err != nil {
            log.Fatal("Why did this fail?")
        }
        log.Println("No Error")
    }

Keluaran:

    Why did this fail?

Mengapa kode ini mengira ada error ketika fungsi fail mengembalikan nil untuk error?
Ini karena fungsi fail menggunakan tipe error konkret dan bukan interface error.
Dalam hal ini, ada nilai pointer nil dari tipe customError yang disimpan di dalam variabel err.
Itu tidak sama dengan nilai interface nil dari tipe error.

** Penanganan Kesalahan

Penanganan kesalahan lebih ke rekayasa pada tingkat makro. Di dunia saya, penanganan kesalahan
berarti kesalahan berhenti pada fungsi yang menanganinya, kesalahan dicatat dengan konteks penuh,
dan kesalahan diperiksa untuk tingkat keparahannya. Berdasarkan tingkat keparahan dan kemampuan untuk pulih,
keputusan untuk pulih, melanjutkan, atau mematikan diambil.

Salah satu masalahnya adalah bahwa tidak semua fungsi dapat menangani sebuah error.
Salah satu alasan bisa jadi karena tidak semua fungsi diizinkan untuk mencatat log.
Apa yang terjadi ketika sebuah error sedang dikirim kembali ke atas tumpukan panggilan dan
tidak dapat ditangani oleh fungsi yang menerimanya? Sebuah error perlu dibungkus dalam konteks
agar fungsi yang pada akhirnya menanganinya dapat melakukannya dengan benar.

    package main

    import (
        "errors"
        "fmt"
    )

    type AppError struct {
        State int
    }

    func (ae *AppError) Error() string {
        return fmt.Sprintf("App Error, State: %d", ae.State)
    }

    func IsAppError(err error) bool {
        var ae *AppError
        return errors.As(err, &ae)
    }

    func GetAppError(err error) *AppError {
        var ae *AppError
        if !errors.As(err, &ae) {
            return nil
        }
        return ae
    }

    func main() {
        if err := firstCall(10); err != nil {

            // Check if the error is an AppError.
            if IsAppError(err) {
                ae := GetAppError(err)
                fmt.Printf("Is AppError, State: %d\n", ae.State)
            }

            fmt.Print("\n********************************\n\n")

            // Display the error using the implementation of
            // the error interface.
            fmt.Printf("%v\n", err)
        }
    }

    func firstCall(i int) error {
        if err := secondCall(i); err != nil {
            return fmt.Errorf("secondCall(%d) : %w", i, err)
        }
        return nil
    }

    func secondCall(i int) error {
        return &AppError{99}
    }

Keluaran:

    Is AppError, State: 99

    ********************************

    secondCall(10) : App Error, State: 99

** Catatan

- Gunakan nilai error default untuk pesan yang statis dan sederhana.
- Buat dan kembalikan variabel error untuk membantu pemanggil mengidentifikasi kesalahan spesifik.
- Buat tipe error kustom ketika konteks kesalahan lebih kompleks.
- Nilai error dalam Go bukanlah sesuatu yang istimewa, mereka hanyalah nilai seperti nilai lainnya, sehingga Anda
  memiliki seluruh bahasa untuk digunakan.

** Kutipan

"Systems cannot be developed assuming that human beings will be able to write millions
of lines of code without making mistakes, and debugging alone is not an efficient way
to develop reliable systems." - Al Aho (inventor of AWK)

** Bacaan Tambahan

- [[https://go.dev/blog/error-handling-and-go][Error handling and Go]]
- [[https://go.dev/blog/go1.13-errors][Working with Errors in Go 1.13]]
- [[https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html][Error Handling In Go, Part I]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html][Error Handling In Go, Part II]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html][Design Philosophy On Logging]] - William Kennedy
- [[https://clipperhouse.com/bugs-are-a-failure-of-prediction/][Bugs are a failure of prediction]] - Matt Sherman
- [[https://dave.cheney.net/2014/12/24/inspecting-errors][Inspecting errors]] - Dave Cheney
- [[https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully][Don’t just check errors, handle them gracefully]] - Dave Cheney
- [[https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package][Stack traces and the errors package]] - Dave Cheney
- [[https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html][Error handling in Upspin]] - Rob Pike
- [[https://rauljordan.com/why-go-error-handling-is-awesome/][Why Go's Error Handling is Awesome]] - Raul Jordan

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

Buat dua variabel error, satu disebut ErrInvalidValue dan yang lain disebut ErrAmountTooLarge.
Berikan pesan statis untuk masing-masing variabel. Kemudian tulis sebuah fungsi yang disebut checkAmount
yang menerima nilai tipe float64 dan mengembalikan nilai error. Periksa apakah nilainya nol, dan jika iya,
kembalikan ErrInvalidValue. Periksa nilai untuk lebih dari $1,000, dan jika iya, kembalikan ErrAmountTooLarge.
Tulis sebuah fungsi utama untuk memanggil fungsi checkAmount dan periksa nilai error yang dikembalikan.
Tampilkan pesan yang sesuai ke layar.

.play error-handling/exercise1.go
.play error-handling/answer1.go

** Latihan 2

Buatlah tipe error kustom yang disebut appError yang berisi tiga atribut: err error, message string, dan code int.
Implementasikan interface error dengan menyediakan pesan Anda sendiri menggunakan ketiga atribut ini.
Implementasikan metode kedua bernama temporary yang mengembalikan false ketika nilai atribut code adalah 9.
Tulis sebuah fungsi bernama checkFlag yang menerima nilai bool. Jika nilai tersebut false,
kembalikan pointer dari tipe error kustom Anda yang diinisialisasi sesuai keinginan Anda.
Jika nilai tersebut true, kembalikan sebuah error default. Tulis sebuah fungsi main untuk memanggil fungsi checkFlag
dan periksa error menggunakan interface temporary.

.play error-handling/exercise2.go
.play error-handling/answer2.go
