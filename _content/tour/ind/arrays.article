Arrays
Array adalah struktur data khusus di Go yang memungkinkan kita mengalokasikan blok-blok memori berukuran tetap secara berdekatan.

* Arrays

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Array merupakan struktur data khusus dalam Go yang memungkinkan kita mengalokasikan blok-blok memori berukuran tetap secara berdekatan.
Array memiliki beberapa fitur khusus dalam Go terkait dengan cara mendeklarasikannya dan cara melihat sebagai tipe data.

** Ulasan Kode

- *Contoh* *1:* Deklarasikan, inisiasi, dan iterasi
- *Contoh* *2:* Macam-macam tipe array
- *Contoh* *3:* Alokasi memori yang berdekatan
- *Contoh* *4:* Mekanik fungsi range

.play arrays/example1.go
.play arrays/example2.go
.play arrays/example3.go
.play arrays/example4.go

** Mendeklarasikan dan Menginisiasi Nilai Array

Deklarasikan sebuah array berisi lima string yang diinisialisasi ke dalam keadaan nilai nol (zero value).

    var strings [5]string

Sebuah string adalah struktur data yang tidak dapat diubah (immutable), terdiri dari 2 satuan word,
yang terdiri dari sebuah alamat memori (pointer) ke sebuah kumpulan bytes (backing array) dan total bytes dari kumpulan data tersebut.
Karena array ini diatur ke dalam keadaan nilai nol (zero value), setiap elemennya diatur ke dalam keadaan nilai nol.
Ini berarti setiap string memiliki satuan word pertama diatur menjadi `nil` dan
satuan word kedua diatur menjadi 0.

.image /tour/ind/static/img/a1.png

** Pengisian Nilai String

Apa yang terjadi ketika sebuah string nilainya diisikan ke string lain?

    strings[0] = "Apple"

Ketika sebuah string diberikan nilainya ke string lain, nilai dari dua satuan word akan disalin,
menghasilkan dua nilai string yang berbeda tetapi keduanya berbagi backing array yang sama.

.image /tour/ind/static/img/a2.png

Biaya penyalinan string adalah sama berapa pun ukuran stringnya,
salinan dari 2 satuan word tersebut

** Melakukan Iterasi pada Kumpulan Data

Go menyediakan dua semantik berbeda untuk melakukan iterasi pada suatu koleksi.
Saya bisa melakukan iterasi menggunakan semantik nilai atau semantik penunjuk.

    // Value Semantic Iteration
    for i, fruit := range strings {
        println(i, fruit)
    }


    // Pointer Semantic Iteration
    for i := range strings {
        println(i, strings[i])
    }

Saat menggunakan iterasi semantik nilai, ada dua hal yang terjadi. Pertama,
koleksi yang sedang diiterasi akan disalin, dan Anda melakukan iterasi pada salinan tersebut.
Dalam kasus array, salinan bisa jadi mahal karena seluruh array disalin. Dalam kasus slice,
tidak ada biaya nyata karena hanya nilai irisan internal yang disalin dan bukan nilai irisannya
susunan pendukung. Kedua, Anda mendapatkan salinan dari setiap elemen yang sedang diiterasi.

Ketika menggunakan iterasi semantik pointer, Anda melakukan iterasi pada koleksi asli,
dan saya mengakses setiap elemen yang terkait dengan koleksi tersebut secara langsung.

** Iterasi Semantik Nilai

Diberikan kode dan keluaran berikut.

    strings := [5]string{"Apple", "Orange", "Banana", "Grape", "Plum"}
    for i, fruit := range strings {
        println(i, fruit)
    }

Keluaran:

    0 Apple
    1 Orange
    2 Banana
    3 Grape
    4 Plum

Variabel strings adalah sebuah array yang berisi 5 string. Perulangan melakukan iterasi
pada setiap string dalam koleksi dan menampilkan posisi indeks dan nilai string.
Karena ini adalah iterasi semantik nilai, `for range` melakukan iterasi pada salinan (shallow copy) dari array,
dan pada setiap iterasi, variabel `fruit` adalah salinan dari setiap string (struktur data dua satuan word).

Perhatikan bagaimana variabel `fruit` dikirimkan ke fungsi `print` menggunakan semantik nilai.
Fungsi print mendapatkan salinan sendiri dari nilai string juga. Pada saat string dikirimkan ke fungsi print,
ada 4 salinan dari nilai string (array, salinan dangkal, variabel `fruit`, dan salinan fungsi print).
Keempat salinan tersebut berbagi backing array yang sama.

.image /tour/ind/static/img/a3.png

Membuat salinan dari nilai string penting karena itu mencegah nilai string tersebut keluar ke heap.
Hal ini menghilangkan alokasi yang sia-sia di heap.

** Iterasi Semantik Pointer

Diberikan kode dan keluaran berikut.

    strings := [5]string{"Apple", "Orange", "Banana", "Grape", "Plum"}
    for i := range strings {
        println(i, strings[i])
    }

Keluaran:

    0 Apple
    1 Orange
    2 Banana
    3 Grape
    4 Plum

Sekali lagi, variabel `strings` adalah sebuah array yang berisi 5 string.
Perulangan melakukan iterasi pada setiap string dalam koleksi dan menampilkan posisi indeks dan nilai string.
Karena ini adalah iterasi semantik pointer, `for range` melakukan iterasi langsung pada array strings,
dan pada setiap iterasi, nilai string untuk setiap posisi indeks diakses langsung untuk pemanggilan fungsi `print`.

** Macam-macam Tipe Array

Menarik untuk melihat apa yang disediakan oleh kompilator sebagai kesalahan
ketika memberikan nilai ke array dengan tipe yang sama namun panjangnya berbeda.

    var five [5]int
    four := [4]int{10, 20, 30, 40}

    five = four

Error Kompilator:

    cannot use four (type [4]int) as type [5]int in assignment


Di sini, Anda mendeklarasikan sebuah array dari 4 dan 5 integer yang diinisialisasi ke dalam keadaan nilai nol.
Kemudian mencoba untuk saling memberikan nilai ke satu sama lain,
dan kompilator mengatakan, "cannot use four (type [4]int) as type [5]int in assignment".

Penting untuk memahami dengan jelas apa yang dikatakan oleh kompilator. Kompilator mengatakan bahwa
array dengan 4 integer dan array dengan 5 integer mewakili data dari tipe yang berbeda.
Ukuran dari sebuah array merupakan bagian dari informasi tipe data tersebut.
Dalam Go, ukuran dari sebuah array harus diketahui pada saat kompilasi.

** Konstruksi Memori Berdekatan

Anda ingin membuktikan bahwa sebuah array menyediakan susunan memori yang berdekatan.

    five := [5]string{"Annie", "Betty", "Charley", "Doug", "Bill"}

    for i, v := range five {
        fmt.Printf("Value[%s]\tAddress[%p]  IndexAddr[%p]\n",
            v, &v, &five[i])
    }

Keluaran:

    Value[Annie]     Address[0xc000010250]    IndexAddr[0xc000052180]
    Value[Betty]     Address[0xc000010250]    IndexAddr[0xc000052190]
    Value[Charley]   Address[0xc000010250]    IndexAddr[0xc0000521a0]
    Value[Doug]      Address[0xc000010250]    IndexAddr[0xc0000521b0]
    Value[Bill]      Address[0xc000010250]    IndexAddr[0xc0000521c0]

Di sini, Anda mendeklarasikan sebuah array dari 5 string yang diinisiasi dengan suatu nilai.
Kemudian menggunakan iterasi semantik nilai untuk menampilkan informasi tentang setiap string.
Output menunjukkan setiap nilai string, alamat variabel `v`, dan alamat setiap elemen dalam array.

Anda dapat melihat bagaimana array adalah blok memori yang berurutan dan bagaimana sebuah string adalah
struktur data dua satuan word atau 16 byte pada arsitektur 64-bit.
Alamat untuk setiap elemen dipisahkan dengan penambahan 16 byte.

Fakta bahwa variabel v memiliki alamat yang sama pada setiap iterasi
memperkuat pemahaman bahwa v adalah variabel lokal dengan tipe string
yang berisi salinan dari setiap nilai string selama iterasi.

** Cache pada CPU

Ada banyak perbedaan mekanis antara prosesor dan desainnya. Dalam bagian ini,
Anda akan berbicara pada tingkat tinggi tentang prosesor dan semantik yang relatif sama di antara mereka.
Pemahaman semantik ini akan memberikan Anda mental model yang baik tentang
bagaimana prosesor bekerja dan pemahaman yang dapat Anda berikan.

Setiap inti dalam prosesor memiliki cache lokal memori sendiri (L1 dan L2) dan
cache memori bersama (L3) yang digunakan untuk menyimpan/mengakses data dan instruksi.
Thread pada perangkat keras (hardware threads) di setiap intinya dapat mengakses
cache lokal L1 dan L2 mereka. Data dari L3 atau memori utama perlu disalin
ke dalam cache L1 atau L2 untuk diakses.

.image /tour/ind/static/img/a4.png

Biaya latensi dari mengakses data yang ada di berbagai cache berubah
dari yang terkecil ke yang terbesar: L1 -> L2 -> L3 -> memori utama. Seperti yang dikatakan Scott Meyers,
"Jika kinerja penting, maka jumlah total memori yang Anda miliki adalah jumlah total cache.
Memori utama sangat lambat untuk diakses, pada kenyataannya, bisa jadi sama sekali tidak ada di sana."

Kinerja saat ini berkaitan dengan seberapa efisien aliran data melalui perangkat keras.
Jika setiap data yang dibutuhkan oleh perangkat keras (pada setiap waktu tertentu) hanya ada di memori utama,
program saya akan berjalan lebih lambat dibandingkan dengan data yang sudah ada di cache L1 atau L2.

    3GHz(3 clock cycles/ns) * 4 instructions per cycle = 12 instructions per ns!

    1 ns ............. 1 ns .............. 12 instructions  (one)
    1 µs ......... 1,000 ns .......... 12,000 instructions  (thousand)
    1 ms ..... 1,000,000 ns ...... 12,000,000 instructions  (million)
    1 s .. 1,000,000,000 ns .. 12,000,000,000 instructions  (billion)

    Industry Defined Latencies
    L1 cache reference ......................... 0.5 ns ...................  6 ins
    L2 cache reference ........................... 7 ns ................... 84 ins
    Main memory reference ...................... 100 ns ................. 1200 ins

Bagaimana cara anda menulis kode yang menjamin data yang diperlukan untuk menjalankan sebuah instruksi
selalu ada di cache L1 atau L2? Anda perlu menulis kode yang bersimpati secara mekanis dengan prefetcher prosesor.
Prefetcher mencoba memprediksi data apa yang dibutuhkan sebelum instruksi
meminta data sehingga data tersebut sudah ada di cache L1 atau L2.

Ada berbagai granularitas akses memori tergantung pada lokasi aksesnya.
Kode saya dapat membaca/menulis sebuah byte memori sebagai unit memori terkecil.
Namun, dari sudut pandang sistem caching, granularitasnya adalah 64 byte.
Blok memori 64 byte ini disebut sebagai cache line.

Prefetcher berfungsi paling baik ketika instruksi yang dieksekusi membuat pola akses
yang dapat diprediksi ke memori. Salah satu cara untuk membuat pola akses yang dapat diprediksi
ke memori adalah dengan membuat blok memori yang berurutan dan
kemudian melakukan iterasi di atas memori tersebut dengan melakukan penelusuran linear
dengan langkah yang dapat diprediksi.

Array adalah struktur data yang paling penting bagi perangkat keras
karena mendukung pola akses yang dapat diprediksi. Namun, slice adalah struktur data
yang paling penting dalam Go. Slice dalam Go menggunakan array sebagai basisnya.

Setelah Anda membuat sebuah array, setiap elemennya memiliki jarak yang sama
dari elemen berikutnya atau sebelumnya. Saat Anda melakukan iterasi di atas array,
Anda mulai berjalan dari cache line ke cache line yang terhubung dengan langkah yang dapat diprediksi.
Prefetcher akan mengenali pola akses data yang dapat diprediksi ini dan mulai menarik data
secara efisien ke dalam prosesor, sehingga mengurangi biaya latensi akses data.


Bayangkan Anda memiliki matriks memori berukuran besar dan sebuah linked list dari node
yang sesuai dengan jumlah elemen dalam matriks tersebut. Jika Anda melakukan pembacaan melintasi linked list,
dan kemudian melakukan pembacaan pada matriks ke arah kedua (kolom dan baris),
bagaimana perbandingan kinerja dari pembacaan yang berbeda?

    func RowTraverse() int {
        var ctr int
        for row := 0; row < rows; row++ {
            for col := 0; col < cols; col++ {
                if matrix[row][col] == 0xFF {
                    ctr++
                }
            }
        }
        return ctr
    }

Pembacaan baris akan memiliki performa terbaik karena berjalan melalui memori,
cache line per cache line yang terhubung, yang menciptakan pola akses yang dapat diprediksi.
Cache lines dapat di-prefetch dan disalin ke dalam cache L1 atau L2 sebelum data diperlukan.

    func ColumnTraverse() int {
        var ctr int
        for col := 0; col < cols; col++ {
            for row := 0; row < rows; row++ {
                if matrix[row][col] == 0xFF {
                    ctr++
                }
            }
        }
        return ctr
    }

Pembacaan kolom adalah yang terburuk secara signifikan karena pola akses ini
melintasi batas halaman OS pada setiap akses memori. Hal ini menyebabkan ketidakpastian untuk
cache line prefetching dan pada dasarnya menjadi akses memori yang acak.

    func LinkedListTraverse() int {
        var ctr int
        d := list
        for d != nil {
            if d.v == 0xFF {
                ctr++
            }
            d = d.p
        }
        return ctr
    }

Linked list dua kali lebih lambat dibandingkan pembacaan baris utamanya karena adanya cache line misses
tetapi lebih sedikit TLB (Translation Lookaside Buffer) misses. Sebagian besar node yang terhubung
dalam daftar tersebut ada di dalam halaman OS yang sama.

    BenchmarkLinkListTraverse-16    128      28738407 ns/op
    BenchmarkColumnTraverse-16       30     126878630 ns/op
    BenchmarkRowTraverse-16         310      11060883 ns/op

** Translation Lookaside Buffer (TLB)

Setiap program yang berjalan diberikan peta memori penuh dari memori virtual oleh sistem operasi,
dan program yang berjalan menganggap bahwa mereka memiliki seluruh memori fisik pada mesin tersebut.
Namun, memori fisik perlu dibagikan dengan semua program yang berjalan. Sistem operasi membagikan
memori fisik dengan memecah memori fisik menjadi halaman-halaman dan memetakan halaman-halaman tersebut
ke dalam memori virtual untuk setiap program yang berjalan.
Setiap sistem operasi dapat memutuskan ukuran sebuah halaman, tetapi ukuran seperti
4k, 8k, 16k adalah ukuran yang masuk akal dan umum.

TLB adalah cache kecil di dalam prosesor yang membantu mengurangi latensi dalam menerjemahkan
alamat virtual ke alamat fisik dalam lingkup halaman sistem operasi dan offset di dalam halaman tersebut.
Ketika terjadi kesalahan pada TLB cache, dapat menyebabkan latensi besar karena sekarang
hardware harus menunggu sistem operasi untuk memindai tabel halamannya untuk menemukan halaman yang benar
untuk alamat virtual yang dimaksud. Jika program berjalan di mesin virtual (seperti di cloud),
maka tabel paging mesin virtual perlu dipindai terlebih dahulu.

Ingat apa yang tadi dikatakan:

Linked list dua kali lebih lambat dibandingkan dengan pembacaan baris terutama karena terjadi cache line misses,
namun terjadi lebih sedikit TLB misses (akan dijelaskan selanjutnya).
Sebagian besar node yang terhubung dalam daftar tersebut ada di dalam halaman OS yang sama.

Linked list memiliki performa yang lebih cepat seiring bertambahnya tingkatan dibandingkan
dengan pembacaan kolom karena akses TLB. Meskipun terjadi cache line misses pada pembacaan linked list,
karena sebagian besar memori untuk sekelompok node akan berada di dalam halaman yang sama,
latensi TLB tidak memengaruhi kinerja. Oleh karena itu, untuk program-program yang menggunakan jumlah memori besar,
seperti aplikasi berbasis DNA, Anda mungkin ingin menggunakan distribusi Linux
yang dikonfigurasi dengan ukuran halaman sekitar satu atau dua megabyte.

Semua yang dikatakan tersebut menunjukkan bahwa desain berbasis data sangat penting.
Menulis algoritma yang efisien harus mempertimbangkan bagaimana data diakses.
Ingatlah, kinerja saat ini berkaitan dengan seberapa efisien Anda dapat membawa data ke dalam prosesor.

- [[https://youtu.be/WDIkqP4JbkE?t=1129][CPU Caches and Why You Care (18:50-20:30)]] - Scott Meyers
- [[https://youtu.be/WDIkqP4JbkE?t=2676][CPU Caches and Why You Care (44:36-45:40)]] - Scott Meyers
- [[https://youtu.be/jEG4Qyo_4Bc?t=266][Performance Through Cache-Friendliness (4:25-5:48)]] - Damian Gryski

** Catatan mengenai CPU Cache

.html arrays/array_list.html

** Diagram Tambahan

*Latensi* *yang* *Didefinisikan* *Secara* *Industri*

    L1 cache reference ......................... 0.5 ns ...................  6 ins
    Branch mispredict ............................ 5 ns ................... 60 ins
    L2 cache reference ........................... 7 ns ................... 84 ins
    Mutex lock/unlock ........................... 25 ns .................. 300 ins
    Main memory reference ...................... 100 ns ................. 1200 ins
    Compress 1K bytes with Zippy ............. 3,000 ns (3 µs) ........... 36k ins
    Send 2K bytes over 1 Gbps network ....... 20,000 ns (20 µs) ........  240k ins
    SSD random read ........................ 150,000 ns (150 µs) ........ 1.8M ins
    Read 1 MB sequentially from memory ..... 250,000 ns (250 µs) .......... 3M ins
    Round trip within same datacenter ...... 500,000 ns (0.5 ms) .......... 6M ins
    Read 1 MB sequentially from SSD- ..... 1,000,000 ns (1 ms) ........... 12M ins
    Disk seek ........................... 10,000,000 ns (10 ms) ......... 120M ins
    Read 1 MB sequentially from disk .... 20,000,000 ns (20 ms) ......... 240M ins
    Send packet CA->Netherlands->CA .... 150,000,000 ns (150 ms) ........ 1.8B ins

*Gambar* *Latensi* *Cache*

.image /tour/ind/static/img/cache_latencies_graph.png

** Bacaan Tambahan

*Memori* *CPU* */* *Caches*

- [[https://www.youtube.com/watch?v=WDIkqP4JbkE][CPU Caches and Why You Care - Video]] - Scott Meyers
- [[https://www.youtube.com/watch?v=OFgxAFdxYAQ][A Crash Course in Modern Hardware - Video]] - Cliff Click
- [[http://frankdenneman.nl/2016/07/06/introduction-2016-numa-deep-dive-series/][NUMA Deep Dive Series]] - Frank Denneman
- [[http://www.aristeia.com/TalkNotes/codedive-CPUCachesHandouts.pdf][CPU Caches and Why You Care - Deck]] - Scott Meyers
- [[https://www.youtube.com/watch?v=MC1EKLQ2Wmg][Mythbusting Modern Hardware to Gain 'Mechanical Sympathy']] - Martin Thompson
- [[http://www.akkadia.org/drepper/cpumemory.pdf][What Every Programmer Should Know About Memory]] - Ulrich Drepper
- [[http://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips][How CPU Caches Work and Why]] - Joel Hruska
- [[http://www.lighterra.com/papers/modernmicroprocessors][Modern Microprocessors A 90 Minute Guide]] - Jason Robert Carey Patterson
- [[http://lwn.net/Articles/252125][Memory part 2: CPU caches]] - Ulrich Drepper
- [[http://www.gotw.ca/publications/concurrency-ddj.htm][The Free Lunch Is Over]] - Herb Sutter
- [[https://m.youtube.com/watch?feature=youtu.be&v=QBu2Ae8-8LM][Data Center Computers: Modern Challenges in CPU Design]] - Dick Sites
- [[https://en.wikipedia.org/wiki/Wirth%27s_law][Wirth's Law]] - Wikipedia
- [[http://www.drdobbs.com/parallel/eliminate-false-sharing/217500206][Eliminate False Sharing]] - Herb Sutter
- [[http://www.ilikebigbits.com/2014_04_21_myth_of_ram_1.html][The Myth Of Ram]] - Emil Ernerfeldt
- [[https://www.infoq.com/presentations/hardware-transactional-memory][Understanding Transaction Hardware Memory]] - Gil Gene
- [[https://youtu.be/jEG4Qyo_4Bc?t=266][Performance Through Cache-Friendliness (4:25-5:48)]] - Damian Gryski
- [[https://www.youtube.com/watch?v=2EWejmkKlxs][Going Nowhere Faster]] - Chandler Carruth

*Desain* *Berbasis* *Data*

- [[https://www.youtube.com/watch?v=rX0ItVEVjHc][Data-Oriented Design and C++]] - Mike Acton
- [[https://www.youtube.com/watch?v=fHNmRkzxHWs][Efficiency with Algorithms, Performance with Data Structures]] - Chandler Carruth
- [[https://www.youtube.com/watch?v=LrVi9LHP8Bk][Taming the performance Beast]] - Klaus Iglberger
- [[http://harmful.cat-v.org/software/OO_programming/_pdf/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf][Pitfalls of OOP]] - Tony Albrecht
- [[https://www.youtube.com/watch?v=YQs6IC-vgmo][Why you should avoid Linked Lists]] - Bjarne Stroustrup
- [[http://gamesfromwithin.com/data-oriented-design][Data-Oriented Design (Or Why You Might Be Shooting Yourself in The Foot With OOP)]] - Noel
- [[https://www.quora.com/Was-object-oriented-programming-a-failure][Was object-oriented programming a failure?]] - Quora

** Catatan

- Jika Anda tidak memahami data, Anda tidak memahami masalahnya.
- Jika Anda tidak memahami biaya penyelesaian masalah, Anda tidak dapat beralasan tentang masalah tersebut.
- Jika Anda tidak memahami perangkat keras, Anda tidak dapat beralasan tentang biaya penyelesaian masalah.
- Array adalah struktur data dengan yang tetap dan tidak dapat diubah.
- Array dengan ukuran yang berbeda dianggap sebagai tipe yang berbeda.
- Memori dialokasikan sebagai blok yang berdekatan.
- Go memberikan kontrol atas lokalitas spasial.

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

Deklarasikan sebuah array dari 5 string dengan setiap elemennya diinisialisasi ke nilai nol.
Deklarasikan array kedua dari 5 string dan inisialisasi array ini dengan nilai string literal.
Berikan nilai array kedua ke array pertama dan tampilkan hasil dari array pertama.
Tampilkan nilai string dan alamat setiap elemennya.

.play arrays/exercise1.go
.play arrays/answer1.go
