Tipe Struct
Anda dapat mendeklarasikan tipe generic menggunakan tipe struct.

* Generics - Tipe Struct

Anda dapat mendeklarasikan tipe generic dalam sebuah struct.

** Video

Tontonlah presentasi yang saya berikan tentang Generik yang
akan membimbing Anda melalui semua contoh dalam bagian ini dari Tur.

.html generics-video.html

** Ulasan Kode

- *Contoh* *1*: Linked List

.play generics/struct-types/example1.go

** Penjelasan

Bagaimana jika Anda ingin mendeklarasikan tipe generik sendiri menggunakan tipe struct?

    type node[T any] struct {
        Data T
        next *node[T]
        prev *node[T]
    }

Tipe struct ini dideklarasikan untuk mewakili node dalam linked list.
Setiap node berisi data individual yang disimpan dan dikelola oleh linked list tersebut.
Penggunaan kurung siku mendeklarasikan bahwa tipe T adalah tipe generic yang akan ditentukan pada waktu kompilasi.
Penggunaan batasan "any" menjelaskan bahwa tidak ada batasan pada jenis apa yang dapat diambil oleh tipe T.

Dengan mendeklarasikan tipe T, atribut Data sekarang dapat didefinisikan sebagai atribut bertipe T
yang akan ditentukan nanti. Atribut next dan prev perlu menunjuk ke suatu node dari tipe T yang sama.
Ini adalah pointer ke node berikutnya dan sebelumnya dalam linked list. Untuk membuat koneksi ini,
atribut-atribut tersebut dideklarasikan sebagai pointer ke suatu node yang terikat pada tipe T
melalui penggunaan kurung siku.

    type list[T any] struct {
        first *node[T]
        last *node[T]
    }

Tipe struct kedua bernama list dan mewakili kumpulan node dengan menunjuk ke node pertama dan terakhir
dalam suatu linkedlist. Atribut-atribut ini perlu menunjuk ke suatu node dari tipe T,
sama seperti atribut next dan prev dari tipe node.

Sekali lagi, identifikasi T didefinisikan sebagai tipe generic (akan ditentukan nanti)
yang dapat digantikan oleh tipe konkret apa pun. Kemudian, atribut first dan last dideklarasikan
sebagai pointer ke node dari suatu tipe T menggunakan sintaks kurung siku.

    func (l *list[T]) add(data T) *node[T] {
        n := node[T]{
            Data: data,
            prev: l.last,
        }

        if l.first == nil {
            l.first = &n
            l.last = &n
            return &n
        }

        l.last.next = &n
        l.last = &n

        return &n
    }

Ini adalah implementasi dari metode bernama add untuk tipe list. Tidak diperlukan
deklarasi formal tipe generik list (seperti pada fungsi) karena metode terikat pada list melalui receiver.
Pnerima dari metode add dideklarasikan sebagai pointer ke suatu list dari tipe T,
dan nilai kembalian dideklarasikan sebagai pointer ke node dari tipe T yang sama.

Kode setelah pembuatan suatu node akan selalu sama, terlepas dari jenis data yang disimpan dalam daftar
karena itu hanya manipulasi pointer. Hanya pembangunan node baru yang dipengaruhi oleh tipe data yang akan dikelola.
Berkat generic, pembangunan node dapat terikat pada tipe T yang akan digantikan nanti pada waktu kompilasi.

Tanpa generic, seluruh metode ini perlu diduplikasi karena pembangunan node harus dihardcode
ke tipe yang diketahui dan dideklarasikan sebelum kompilasi. Karena jumlah kode (untuk implementasi seluruh daftar)
yang perlu diubah untuk berbagai tipe data sangat kecil, kemampuan untuk mendeklarasikan node dan daftar untuk
mengelola data dari suatu tipe T mengurangi biaya duplikasi dan pemeliharaan kode.

    type user struct {
        name string
    }

    func main() {
        // Store values of type user into the list.
        var lv list[user]
        n1 := lv.add(user{"bill"})
        n2 := lv.add(user{"ale"})
        fmt.Println(n1.Data, n2.Data)

        // Store pointers of type user into the list.
        var lp list[*user]
        n3 := lp.add(&user{"bill"})
        n4 := lp.add(&user{"ale"})
        fmt.Println(n3.Data, n4.Data)
    }

Keluaran:

    {bill} {ale}
    &{bill} &{ale}

Berikut ini adalah aplikasi kecil. Sebuah tipe yang diberi nama user dideklarasikan,
dan kemudian suatu list dibuat ke keadaan nilai nol untuk mengelola nilai-nilai tipe user.
Kemudian, suatu list kedua dibuat ke keadaan nilai nol, dan list ini mengelola pointer ke nilai-nilai tipe user.
Satu-satunya perbedaan antara kedua list ini adalah satu mengelola nilai-nilai tipe user,
dan yang lainnya mengelola pointer dari tipe user.

Karena tipe user secara eksplisit ditentukan selama pembuatan tipe list,
metode add pada gilirannya menerima nilai dari tipe user. Karena pointer dari tipe user secara eksplisit
ditentukan selama pembuatan tipe list, metode add menerima penunjuk dari tipe user.

Anda dapat melihat dalam output program bahwa atribut Data untuk node dalam list tersebut sesuai
dengan semantik data yang digunakan pada saat pembuatan.

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

Deklarasikan tipe generik yang diberi nama stack yang menggunakan sebuah struct
dengan satu atribut bernama data yang dideklarasikan sebagai slice dari suatu tipe T.
Deklarasikan metode bernama push yang menerima nilai dari suatu tipe T
dan menambahkan nilai tersebut ke dalam slice tadi. Deklarasikan metode bernama pop
yang mengembalikan nilai terbaru dari suatu tipe T yang ditambahkan ke dalam slice dan suatu error.
Kemudian tulis sebuah fungsi main yang menggunakan metode-metode tersebut.

.play generics/struct-types/exercise1.go
.play generics/struct-types/answer1.go
