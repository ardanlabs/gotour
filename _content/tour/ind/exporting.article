Exporting
Exporting (Mengekspor) memberikan kemampuan untuk mendeklarasikan apakah suatu pengenal dapat diakses oleh kode di luar paket di mana pengenal itu dideklarasikan.

* Exporting

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Exporting memberikan kemampuan untuk mendeklarasikan apakah suatu pengenal dapat diakses oleh kode di luar paket
di mana pengenal itu dideklarasikan.

** Ulasan Kode

- *Contoh* *1:* Mendeklarasikan dan mengakses pengenal yang diekspor
- *Contoh* *2:* Mendeklarasikan pengenal yang tidak diekspor dan batasannya
- *Contoh* *3:* Mengakses nilai pengenal yang tidak diekspor
- *Contoh* *4:* Tipe atribut struct yang tidak diekspor
- *Contoh* *5:* Tipe yang tersematkan yang tidak diekspor

.play exporting/example1.go
.play exporting/example2.go
.play exporting/example3.go
.play exporting/example4.go
.play exporting/example5.go

** Mekanisme Exporting

Sebuah paket adalah unit dasar dari kode yang dikompilasi dalam Go.
Ini mewakili unit kode yang dikompilasi secara fisik, biasanya sebagai perpustakaan yang telah dikompilasi
pada sistem operasi. Exporting menentukan akses terhadap pengenal melintasi batas-batas paket.

    package counters

    type AlertCounter int

Dalam hal ini, karena huruf kapital digunakan untuk menamai tipe AlterCounter,
tipe tersebut diekspor dan dapat diakses secara langsung oleh kode di luar
paket counters.

    package counters

    type alertCounter int

Sekarang setelah Anda mengubah nama tipe untuk dimulai dengan huruf kecil, tipe tersebut
tidak diekspor. Ini berarti hanya kode di dalam paket counters yang dapat merujuk langsung
ke tipe ini.

    package counters

    type alertCounter int

    func New(value int) alertCounter {
        return alertCounter(value)
    }

Meskipun kode di atas adalah sintaks yang legal dan bisa dikompilasi, tidak ada nilai di dalamnya.
Mengembalikan nilai dari tipe yang tidak diekspor membingungkan,
karena pemanggil (yang kemungkinan akan berada di paket yang berbeda) tidak dapat
merujuk langsung ke nama tipe tersebut.

    package main

    import (
        "fmt"

        "github.com/ardanlabs/.../exporting/example3/counters"
    )

    func main() {
        counter := counters.New(10)
        fmt.Printf("Counter: %d\n", counter)
    }

Dalam hal ini, fungsi main di paket utama memanggil fungsi counters.New dengan sukses
dan kompilator dapat mendeklarasikan dan membuat variabel dari tipe yang tidak diekspor.
Ini bukan berarti Anda seharusnya melakukan ini, dan ini juga tidak berarti Anda
mendapatkan perlindungan nyata untuk ini. Ini sebaiknya dihindari, dan jika New akan mengembalikan nilai,
sebaiknya nilai tersebut dari tipe yang diekspor.

    package users

    type User struct {
        Name string
        ID   int

        password string
    }

Ketika menyangkut atribut dalam suatu struct, huruf pertama mendeklarasikan apakah bidang tersebut
dapat diakses oleh kode di luar paket di mana struct itu dideklarasikan. Dalam hal ini, Name
dan ID dapat diakses, tetapi password tidak dapat diakses. Ini adalah idiom untuk memisahkan
atribut yang diekspor dan yang tidak diekspor dengan cara ini ika ini adalah cara yang masuk akal
atau praktis untuk dilakukan. Biasanya, semua atribut akan menjadi salah satu dari keduanya.

    package users

    type user struct {
        Name string
        ID   int
    }

    type Manager struct {
        Title string
        user
    }

Dalam skenario ini, meskipun tipe pengguna tidak diekspor, ia memiliki dua bidang yang diekspor.
Ini berarti bahwa ketika tipe user ditanamkan dalam tipe Manajer yang diekspor,
atribut user akan dapat diakses. Umumnya, memiliki tipe yang tidak diekspor dengan atribut yang diekspor
adalah hal yang umum karena paket reflection hanya dapat beroperasi pada atribut yang diekspor.
Marshallers tidak akan berfungsi jika tidak.

Contoh tersebut menciptakan situasi buruk di mana kode di luar paket user dapat membuat
sebuah Manajer, tetapi karena tipe user yang disematkan (embedded)
atribut untuk tipe tersebut dapat diinisialisasi. Ini menciptakan masalah konstruksi parsial
yang akan menyebabkan bug. Anda perlu konsisten dengan melakukan ekspor dan tidak diekspor.

** Catatan

- Kode dalam Go dikompilasi menjadi paket dan kemudian dihubungkan bersama.
- Pengenal diekspor (atau tetap tidak diekspor) berdasarkan huruf besar atau kecil.
- Kita mengimpor paket untuk mengakses pengenal yang diekspor.
- Setiap paket dapat menggunakan nilai dari tipe yang tidak diekspor, tetapi hal ini cukup merepotkan untuk digunakan.

** Catatan Tambahan

[[https://www.ardanlabs.com/blog/2014/03/exportedunexported-identifiers-in-go.html][Exported/Unexported Identifiers In Go]] - William Kennedy

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

*Bagian* *A:* Buatlah sebuah paket yang diberi nama toy dengan satu tipe struct yang diekspor bernama Toy.
Tambahkan atribut-atribut yang diekspor, Name dan Weight. Kemudian tambahkan dua atribut yang tidak diekspor
bernama onHand dan sold. Deklarasikan sebuah fungsi factory bernama New untuk membuat nilai-nilai dari tipe toy
dan terima parameter untuk atribut-atribut yang diekspor. Kemudian deklarasikan metode-metode yang mengembalikan
dan memperbarui nilai-nilai untuk atribut-atribut yang tidak diekspor.

*Bagian* *B:* Buat program yang mengimpor paket toy. Gunakan fungsi New untuk
membuat nilai dari tipe toy. Kemudian gunakan metode-metode untuk mengatur hitungan dan menampilkan
nilai-nilai atribut dari nilai toy tersebut.

.play exporting/exercise1.go
.play exporting/answer1.go
