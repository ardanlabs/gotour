Metode (Method)
Sebuah fungsi disebut metode ketika fungsi tersebut memiliki penerima yang dideklarasikan.

* Metode

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Sebuah fungsi disebut metode ketika fungsi tersebut memiliki penerima yang dideklarasikan.
Penerima adalah parameter yang dideklarasikan di antara kata kunci `func` dan nama fungsi.

** Ulasan Kode

- *Contoh* *1:* Mendeklarasikan dan perilaku penerima
- *Contoh* *2:* Metode bertipe bernama
- *Contoh* *3:* Variabel Fungsi/Metode
- *Contoh* *4:* Tipe Fungsi
- *Contoh* *5:* Semantik Nilai dan Penunjuk(Pointer)

.play methods/example1.go
.play methods/example2.go
.play methods/example3.go
.play methods/example4.go
.play methods/example5.go

** Mendeklarasikan Metode

Ada dua jenis penerima, penerima nilai untuk mengimplementasikan semantik nilai,
dan penerima pointer untuk mengimplementasikan semantik pointer.

    type user struct {
        name  string
        email string
    }

    func (u user) notify() {
        fmt.Printf("Sending User Email To %s<%s>\n", u.name, u.email)
    }

    func (u *user) changeEmail(email string) {
        u.email = email
        fmt.Printf("Changed User Email To %s\n", email)
    }

Fungsi `notify` diimplementasikan dengan penerima nilai. Ini berarti metode tersebut
beroperasi di bawah semantik nilai dan akan beroperasi pada salinan nilai sendiri
yang digunakan untuk melakukan panggilan.

Fungsi changeEmail diimplementasikan dengan penerima pointer. Ini berarti metode tersebut
beroperasi di bawah semantik pointer dan akan beroperasi pada akses bersama ke nilai
yang digunakan untuk melakukan panggilan.

Di luar beberapa pengecualian, set metode untuk suatu tipe sebaiknya tidak berisi
campuran penerima nilai dan penerima pointer. Konsistensi semantik data sangat penting,
termasuk dalam mendeklarasikan metode.

** Pemanggilan Metode

Ketika melakukan panggilan metode, kompilator tidak peduli apakah nilai yang digunakan
untuk melakukan panggilan sesuai secara tepat dengan semantik data penerima.
Kompilator hanya menginginkan nilai atau pointer dari tipe yang sama.

    bill := user{"Bill", "bill@email.com"}
    bill.notify()
    bill.changeEmail("bill@hotmail.com")

Anda dapat melihat bahwa sebuah nilai dari tipe `user` dibangun dan ditugaskan ke variabel `bill`.
Dalam kasus pemanggilan `notify`, variabel`bill` cocok dengan tipe penerima yang menggunakan penerima nilai.
Dalam kasus pemanggilan `changeEmail`, variabel `bill `tidak cocok dengan tipe penerima yang menggunakan
penerima pointer. Namun, kompilator menerima pemanggilan metode dan berbagi variabel `bill` dengan metode tersebut.
Go akan menyesuaikan dalam melakukan pemanggilan.

Ini berfungsi dengan cara yang sama ketika variabel yang digunakan untuk melakukan panggilan adalah variabel pointer.

    bill := &user{"Bill", "bill@email.com"}
    bill.notify()
    bill.changeEmail("bill@hotmail.com")

Dalam kasus ini, variabel `bill` adalah variabel pointer ke sebuah nilai dari tipe `user`.
Sekali lagi, Go menyesuaikan untuk melakukan panggilan metode saat memanggil metode `notify`.

Jika Go tidak menyesuaikan, maka inilah yang harus Anda lakukan untuk melakukan panggilan metode yang sama.

    bill := user{"Bill", "bill@email.com"}
    (&bill).changeEmail("bill@hotmail.com")

    bill := &user{"Bill", "bill@email.com"}
    (*bill).notify()

Saya senang Anda tidak perlu melakukan itu untuk melakukan panggilan metode di Go.

**Pedoman Semantik Data untuk Tipe Internal**

Sebagai panduan, jika data yang saya kerjakan adalah tipe internal (slice, map, channel, function, interface),
maka gunakan semantik nilai untuk memindahkan data di sepanjang program. Ini termasuk mendeklarasikan
sebuah atribut pada suatu tipe. Namun, ketika membaca dan menulis, Anda perlu ingat bahwa
saya menggunakan semantik pointer.

    type IP []byte
    type IPMask []byte

Tipe-tipe ini dideklarasikan dalam paket `net` yang merupakan bagian dari pustaka standar.
Mereka dideklarasikan dengan tipe dasar yang merupakan slice dari byte.
Karena itu, tipe-tipe ini mengikuti panduan untuk tipe-tipe internal.

    func (ip IP) Mask(mask IPMask) IP {
        if len(mask) == IPv6len && len(ip) == IPv4len && allFF(mask[:12]) {
            mask = mask[12:]
        }
        if len(mask) == IPv4len && len(ip) == IPv6len &&
            bytesEqual(ip[:12], v4InV6Prefix) {
            ip = ip[12:]
        }
        n := len(ip)
        if n != len(mask) {
            return nil
        }
        out := make(IP, n)
        for i := 0; i < n; i++ {
            out[i] = ip[i] & mask[i]
        }
        return out
    }

Dengan metode Mask, semantik nilai berlaku untuk penerima, parameter, dan argumen kembalian.
Metode ini menerima salinan nilai Mask sendiri, mengubah nilai tersebut,
dan kemudian mengembalikan salinan dari mutasinya. Metode ini menggunakan mutasi semantik nilai.
Ini bukan kebetulan atau acak.

Sebuah fungsi dapat memutuskan data masukan dan keluaran apa yang diperlukan.
Yang tidak dapat diputuskan adalah semantik data untuk bagaimana data mengalir masuk atau keluar.
Data mengendalikan keputusan tersebut dan fungsi harus patuh.
Inilah mengapa Mask mengimplementasikan API mutasi semantik nilai.
Fungsi harus mematuhi bagaimana sebuah slice dirancang untuk dipindahkan di sepanjang program.

    func ipEmptyString(ip IP) string {
        if len(ip) == 0 {
            return ""
        }
        return ip.String()
    }

Fungsi `ipEmptyString` juga menggunakan semantik nilai untuk masukan dan keluaran.
Fungsi ini menerima salinan nilai IP sendiri dan mengembalikan nilai string.
Tidak ada penggunaan semantik pointer karena data menentukan semantik data, bukan fungsi.

Satu pengecualian untuk menggunakan semantik nilai adalah ketika Anda perlu berbagi
sebuah slice atau map dengan sebuah fungsi yang melakukan unmarshaling atau decoding.

** Pedoman Semantik Data untuk Tipe Struct

Sebagai panduan, jika data yang sedang saya kerjakan adalah tipe struct,
Anda harus memikirkan apa yang data tersebut wakili untuk membuat keputusan.
Aturan umum yang baik adalah bertanya apakah struct tersebut mewakili data atau API.
Jika struct tersebut mewakili data, gunakan semantik nilai.
Jika struct tersebut mewakili suatu API, gunakan semantik pointer.

    type Time struct {
        sec  int64
        nsec int32
        loc  *Location
    }

Berikut adalah tipe struct `Time` dari paket `time`. Jika Anda menganggap `Time` mewakili data,
semantik nilai seharusnya digunakan untuk struct ini.

Ketika melihat basis kode yang sudah ada dan Anda ingin mengetahui semantik data yang dipilih,
carilah fungsi pabrik (factory function). Tipe kembalian dari fungsi pabrik seharusnya menentukan
semantik data yang dipilih oleh pengembang.

    func Now() Time {
        sec, nsec := now()
        return Time{sec + unixToInternal, nsec, Local}
    }

Sekarang fungsi pabrik untuk membuat nilai-nilai `Time`. Lihat tipe kembaliannya,
itu menggunakan semantik nilai. Ini memberi tahu Anda bahwa Anda seharusnya menggunakan
semantik nilai untuk nilai-nilai `Time`, yang berarti setiap fungsi mendapatkan salinan sendiri
dari nilai `Time`, dan bidang dalam suatu struct seharusnya dideklarasikan sebagai nilai bertipe `Time`.

    func (t Time) Add(d Duration) Time {
        t.sec += int64(d / 1e9)
        nsec := int32(t.nsec) + int32(d%1e9)
        if nsec >= 1e9 {
            t.sec++
            nsec -= 1e9
        } else if nsec < 0 {
            t.sec--
            nsec += 1e9
        }
        t.nsec = nsec
        return t
    }

Metode `Add` adalah metode yang perlu melakukan operasi mutasi. Jika Anda melihat dengan seksama,
Anda akan melihat bahwa fungsi ini menggunakan mutasi semantik nilai.
Metode Add mendapatkan salinan sendiri dari nilai `Time` yang digunakan untuk melakukan panggilan,
ia mengubah salinannya sendiri, kemudian mengembalikan salinan tersebut kepada pemanggil.
Sekali lagi, ini adalah cara yang paling aman untuk melakukan operasi mutasi.

    func div(t Time, d Duration) (qmod2 int, r Duration) {}

Berikut adalah contoh lain di mana fungsi div menerima nilai bertipe Time dan Duration (int64),
kemudian mengembalikan nilai bertipe int dan Duration. Semantik nilai untuk tipe Time dan untuk semua tipe bawaan.
Duration memiliki tipe dasar int64.

    func (t *Time) UnmarshalBinary(data []byte) error {}
    func (t *Time) GobDecode(data []byte) error {}
    func (t *Time) UnmarshalJSON(data []byte) error {}
    func (t *Time) UnmarshalText(data []byte) error {}

Keempat metode dari paket Time ini tampaknya melanggar aturan konsistensi semantik data.
Mereka menggunakan semantik pointer, mengapa? Karena mereka mengimplementasikan sebuah antarmuka
di mana method signature terkunci. Karena implementasi memerlukan mutasi,
semantik pointer menjadi satu-satunya pilihan.

Berikut adalah panduan: Jika semantik nilai berlaku, Anda dapat beralih ke semantik pointer
untuk beberapa fungsi selama Anda tidak membiarkan data dalam rantai panggilan yang tersisa
beralih kembali ke semantik nilai. Setelah Anda beralih ke semantik pointer,
semua panggilan setelah dari titik itu harus tetap menggunakan semantik pointer.
Anda tidak boleh, sama sekali tidak boleh, beralih dari pointer ke nilai.
Tidak pernah aman untuk membuat salinan dari nilai yang ditunjuk oleh sebuah pointer.

    func Open(name string) (file *File, err error) {
        return OpenFile(name, O_RDONLY, 0)
    }

Fungsi `Open` dari paket `os` menunjukkan bahwa ketika menggunakan sebuah nilai bertipe File,
semantik pointer berlaku. Nilai-nilai File perlu dibagikan dan seharusnya tidak pernah disalin.

    func (f *File) Chdir() error {
        if f == nil {
            return ErrInvalid
        }
        if e := syscall.Fchdir(f.fd); e != nil {
            return &PathError{"chdir", f.name, e}
        }
        return nil
    }

Metode `Chdir` menggunakan penerima pointer meskipun metode ini tidak mengubah nilai File.
Ini karena nilai-nilai File perlu dibagikan dan tidak dapat disalin.

    func epipecheck(file *File, e error) {
        if e == syscall.EPIPE {
            if atomic.AddInt32(&file.nepipe, 1) >= 10 {
                sigpipe()
            }
        } else {
            atomic.StoreInt32(&file.nepipe, 0)
        }
    }

Fungsi `epipecheck` juga menerima nilai-nilai File menggunakan semantik pointer.

** Metode Hanyalah Fungsi

Metode sebenarnya hanyalah fungsi yang memberikan kemudahan sintaks
untuk memberikan kemampuan kepada data untuk menunjukkan perilaku.

    type data struct {
        name string
        age  int
    }

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

Sebuah tipe dan dua metode dideklarasikan. Metode `displayName` menggunakan semantik nilai,
sementara `setAge` menggunakan semantik pointer.

Catatan: Jangan mengimplementasikan setter dan getter di Go. Ini bukan API dengan tujuan,
dan dalam kasus-kasus seperti ini, lebih baik membuat atribut-atribut tersebut diekspor.

    d := data{
        name: "Bill",
    }

    d.displayName()
    d.setAge(21)

Sebuah nilai bertipe data dibuat dan panggilan metode dilakukan.

    data.displayName(d)
    (*data).setAge(&d, 21)

Karena metode sebenarnya hanya fungsi, metode dapat dieksekusi seperti fungsi.
Anda dapat melihat bahwa penerima sebenarnya adalah parameter, itu adalah parameter pertama.
Ketika Anda memanggil metode, kompilator mengonversinya ke panggilan fungsi.

Catatan: Jangan menjalankan metode seperti ini, tetapi Anda mungkin melihat sintaks ini dalam tooling messages.

** Ketahui Perilaku Kode

Jika Anda mengetahui semantik data yang berlaku, maka Anda mengetahui perilaku kode.
Jika Anda mengetahui perilaku kode, maka Anda mengetahui biaya kode tersebut.
Setelah Anda mengetahui biaya, saya melakukan rekayasa.

Diberikan tipe dan set metode ini.

    type data struct {
        name string
        age  int
    }

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

Kamu bisa menulis kode berikut ini.

    func main() {
        d := data{
            name: "Bill",
        }

        f1 := d.displayName
        f1()
        d.name = "Joan"
        f1()
    }

Keluaran:

    My Name Is Bill
    My Name Is Bill

Anda memulai dengan membuat nilai bertipe `Data` dan menetapkannya ke variabel `d`.
Kemudian Anda memanggil metode `displayName`, terikat pada `d`,
dan menetapkannya ke variabel bernama `f1`. Ini bukan panggilan metode
tetapi sebuah penugasan yang menciptakan tingkat indireksi.
Fungsi adalah nilai dalam Go dan termasuk dalam kumpulan tipe internal.

Setelah penugasan, Anda dapat memanggil metode secara tidak langsung melalui penggunaan variabel `f1`.
Itu menampilkan nama `Bill`. Kemudian Anda mengubah data sehingga nama sekarang menjadi Joan,
an memanggil metode sekali lagi melalui variabel `f1`. Anda tidak melihat perubahan tersebut.
Bill kembali menjadi output. Jadi mengapa?

.image /tour/ind/static/img/m1.png

Hal ini terkait dengan semantik data yang berlaku.
Metode `displayName` menggunakan penerima nilai sehingga semantik nilai berlaku.

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

Ini berarti bahwa variabel `f1` mempertahankan dan beroperasi terhadap salinannya sendiri dari `d`.
Jadi memanggil metode melalui variabel `f1`, akan selalu menggunakan salinan dan salinan tersebut
dilindungi dari perubahan. Ini adalah apa yang Anda inginkan dengan semantik nilai.

Sekarang Anda akan melakukan hal yang sama tetapi dengan metode setAge.

    func main() {
        d := data{
            name: "Bill",
        }

        f2 := d.setAge
        f2(45)
        d.name = "Sammy"
        f2(45)
    }

Keluaran:

    Bill Is Age 45
    Sammy Is Age 45

Kali ini metode `setAge` ditugaskan ke variabel `f2`. Sekali lagi, metode dieksekusi
secara tidak langsung melalui variabel `f2` dengan memberikan nilai 45 untuk usia Bill.
Kemudian nama Bill diubah menjadi Sammy dan variabel `f2` digunakan lagi untuk membuat panggilan.
Kali ini Anda melihat bahwa nama telah berubah.

.image /tour/ind/static/img/m2.png

Fungsi setAge menggunakan penerima pointer sehingga `setAge` tidak beroperasi
pada salinannya sendiri dari variabel d, tetapi beroperasi langsung pada variabel d.
Oleh karena itu, `f2` beroperasi dengan akses bersama dan Anda melihat perubahan tersebut.

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

Tanpa mengetahui semantik data yang berlaku, Anda tidak akan tahu perilaku kode.
Semantik data ini nyata dan memengaruhi perilaku.

** Catatan

- Metode adalah fungsi yang mendeklarasikan variabel penerima.
- Penerima mengikat suatu metode ke suatu tipe dan dapat menggunakan semantik nilai atau pointer.
- Semantik nilai berarti salinan nilai tersebut dilewati melintasi batas program.
- Semantik pointer berarti salinan alamat nilai dilewati melintasi batas program.
- Patuhi satu semantik untuk suatu tipe tertentu dan tetap konsisten.

** Kutipan

"Methods are valid when it is practical or reasonable for a piece of data to expose a capability." - William Kennedy

** Bacaan Tambahan

- [[https://golang.org/doc/effective_go.html#methods][Methods]]
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methods, Interfaces and Embedded Types in Go]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2018/01/escape-analysis-flaws.html][Escape-Analysis Flaws]] - William Kennedy

* Latihan

Gunakan templat ini sebagai awal untuk menyelesaikan latihan. Solusi telah disediakan.

** Latihan 1

Deklarasikan sebuah struktur yang mewakili seorang pemain bisbol. Sertakan `name`, `atBats`, dan `hits`.
Deklarasikan sebuah metode yang menghitung rata-rata pukulan pemain. Rumusnya adalah `Hits` / `AtBats`.
Deklarasikan sebuah slice dari tipe ini dan inisialisasi slice dengan beberapa pemain. Iterasi
lewat slice, tampilkan nama pemain dan rata-rata pukulan.

.play methods/exercise1.go
.play methods/answer1.go
