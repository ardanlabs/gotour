Channels
Channels memungkinkan goroutine untuk berkomunikasi dengan goroutine lain dengan menggunakan semantik sinyal (signal)

* Channels

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Penting untuk melihat channel bukan sebagai struktur data, tetapi sebagai mekanisme untuk memberi isyarat (signal).
Ini sejalan dengan ide bahwa Anda mengirim dan menerima dari sebuah channel, bukan membaca dan menulis.
Jika masalah yang Anda termui tidak dapat dipecahkan dengan semantik sinyal, Anda perlu mempertanyakan penggunaan channel.

** Ulasan Kode

- *Contoh* *1:* Menunggu hasil
- *Contoh* *2:* Menyebar keluar (Fan Out)
- *Contoh* *3:* Menunggu penugasan (task)
- *Contoh* *4:* Pooling
- *Contoh* *5:* Menyebarkan sinyal
- *Contoh* *6:* Pooling pekerjaan terbatas
- *Contoh* *7:* Melewatkan
- *Contoh* *8:* Pembatalan
- *Contoh* *9:* Waktu ulang
- *Contoh* *10:* Pembatalan channel

.play channels/example1.go
.play channels/example2.go
.play channels/example3.go
.play channels/example4.go
.play channels/example5.go
.play channels/example6.go
.play channels/example7.go
.play channels/example8.go
.play channels/example9.go
.play channels/example10.go

** Mekanisme Channel

Biaya memiliki jaminan pada tingkat sinyal adalah ketidakpastian latensi.
Pengirim tidak akan tahu berapa lama mereka perlu menunggu untuk penerima menerima sinyal.
Harus menunggu penerima menciptakan latensi yang memblokir. Dalam hal ini,
jumlah latency yang memblokir tidak diketahui. Pengirim harus menunggu, untuk waktu yang tidak diketahui,
sampai penerima menjadi bisa menerima sinyal lagi.

Menunggu penerima berarti secara mekanis, operasi penerimaan terjadi sebelumnya
pengiriman. Dengan channel, penerimaan terjadi beberapa nanodetik sebelumnya.
Ini berarti penerima mengambil sinyal dan kemudian pergi, mengizinkan pengirim
melanjutkan dengan pasti.

Bagaimana jika proses tidak bisa menunggu untuk waktu yang tidak diketahui? Bagaimana jika
jenis latensi tersebut tidak berfungsi? Maka jaminannya tidak dapat berada pada tingkat sinyal,
tetapi perlu berada di luar itu. Mekanisme dibalik ini bekerja kerena pengiriman sekarang
terjadi sebelum penerimaan. Pengirim dapat melakukan sinyal tanpa perlu menunggu
penerima menjadi tersedia. Jadi pengirim dapat pergi dan tidak perlu menunggu.
Pada akhirnya, diharapkan, penerima muncul dan mengambil sinyal.

Ini mengurangi latency pada pengiriman, tetapi menciptakan ketidakpastian tentang sinyal
yang diterima dan oleh karena itu mengetahui apakah ada masalah dengan penerima.
Hal ini dapat membuat proses menerima pekerjaan yang tidak pernah dimulai atau selesai.
Pada akhirnya, hal ini dapat menyebabkan back pressure besar dan sistem menjadi rusak.

Hal kedua yang perlu difokuskan adalah, apakah Anda perlu mengirim data dengan sinyal?
Jika sinyal memerlukan transmisi data, maka sinyal tersebut adalah 1 berbanding 1 dengan Goroutine.
Jika Goroutine baru juga perlu menerima sinyal, sinyal kedua harus dikirim.

Jika data tidak perlu ditransmisikan bersama dengan sinyal, maka sinyal dapat menjadi 1 banding 1
atau 1 banding banyak antara Goroutine. Sinyal tanpa data utamanya digunakan untuk pembatalan atau pemberhentian.
Ini dilakukan dengan menutup channel.

Hal ketiga yang perlu difokuskan adalah status dari channel.
Sebuah channel bisa berada pada 1 dari 3 status.

Sebuah channel dapat berada dalam keadaan nil dengan mengonstruksi channel ke nilai nol nya.
Pengiriman dan penerimaan pada channel dalam keadaan ini akan diblokir.
Ini berguna dalam situasi di mana Anda ingin menerapkan penundaan pekerjaan jangka pendek.

Sebuah channel dapat berada dalam keadaan terbuka (open state) dengan
memanggil fungsi bawaan `make`. Pengiriman dan penerimaan pada channel dalam keadaan ini
akan berhasil di bawah kondisi-kondisi berikut:

*Unbuffered* *Channels:*

- Jaminan pada tingkat sinyal dengan penerimaan terjadi sebelum pengiriman.
Goroutine pengirim dan penerima perlu bersama dalam ruang dan waktu yang sama agar sinyal dapat diproses.

*Buffered* *Channels:*

- Jaminan di luar tingkat sinyal dengan pengiriman terjadi sebelum penerimaan.
Jika buffer tidak penuh, pengiriman dapat selesai; jika penuh, mereka akan diblokir.
Jika buffer tidak kosong, penerimaan dapat selesai; jika kosong, mereka akan diblokir.

Sebuah channel dapat berada dalam status tertutup (closed state) dengan menggunakan fungsi bawaan close.
Anda tidak perlu menutup channel untuk melepaskan memori; ini digunakan untuk mengubah status.
Mengirimkan pada channel yang telah ditutup akan menyebabkan `panic`, namun menerima pada channel yang ditutup
akan mengembalikan nilai segera.

Dengan semua informasi ini, Anda dapat fokus pada pola channel. Fokus pada sinyal sangat penting.
Idenya adalah, apakah Anda memerlukan jaminan pada tingkat sinyal atau tidak, berdasarkan kekhawatiran tentang latensi.
Apakah Anda perlu mentransmisikan data bersama dengan sinyal atau tidak, berdasarkan penanganan pembatalan atau tidak.
Anda ingin mengubah sintaksis menjadi semantik ini.

** Pedoman Desain

- Belajar lebih lanjut mengenai [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#channel-design][Pedoman Desain]] untuk channels.

** Diagram

*Jaminan* *Pengiriman*

`Jaminan Pengiriman` didasarkan pada satu pertanyaan:
"Apakah saya memerlukan jaminan bahwa sinyal yang dikirim oleh goroutine tertentu telah diterima?"

.image /tour/ind/static/img/guarantee_of_delivery.png

*Sinyal* *Dengan* *atau* *Tanpa* *Data*

Ketika Anda akan memberi sinyal dengan data, ada tiga opsi konfigurasi channel
yang dapat Anda pilih tergantung pada jenis jaminan yang Anda butuhkan.

.image /tour/ind/static/img/signaling_with_data.png

Sinyal tanpa data melayani tujuan utama pembatalan. Ini memungkinkan satu goroutine
memberi sinyal kepada goroutine lain untuk membatalkan apa yang sedang mereka lakukan dan melanjutkan.
Pembatalan dapat diimplementasikan menggunakan channel yang `unbuffered` maupun `buffered`.

.image /tour/ind/static/img/signaling_without_data.png

*Status*

Perilaku sebuah channel langsung dipengaruhi oleh `State` (status) saat ini.
Status sebuah channel dapat berupa `nil`, `terbuka` (open), atau `ditutup` (closed).

.image /tour/ind/static/img/state.png

** Bacaan Tambahan

- [[https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html][The Behavior Of Channels]] - William Kennedy
- [[https://golang.org/ref/mem#tmp_7][Channel Communication]]
- [[http://blog.golang.org/share-memory-by-communicating][Share Memory By Communicating]] - Andrew Gerrand
- [[https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html][The Nature Of Channels In Go]] - William Kennedy
- [[http://matt-welsh.blogspot.com/2010/07/retrospective-on-seda.html][A Retrospective on SEDA]] - Matt Welsh
- [[https://www.youtube.com/watch?v=KBZlN0izeiY][Understanding Channels]] - Kavya Joshi

** Buffer Bloat - 2011

Berhati-hatilah dalam menggunakan buffer besar dengan tujuan mengurangi latensi.

- Buffer besar mencegah pemberitahuan tekanan balik yang tepat waktu.
- Mereka menghancurkan kemampuan Anda untuk mengurangi tekanan balik dengan cepat.
- Mereka dapat meningkatkan latensi bukan menguranginya.
- Gunakan buffered channels untuk memberikan cara mempertahankan kontinuitas.
- Jangan gunakan mereka hanya untuk masalah kinerja.
- Gunakan mereka untuk menangani burst data yang terdefinisi dengan baik.
- Gunakan mereka untuk menangani masalah kecepatan cahaya antara serah terima.

*Video*

- [[https://www.youtube.com/watch?v=qbIozKVz73g][Bufferbloat: Dark Buffers in the Internet]]
- [[http://www.bufferbloat.net/projects/cerowrt/wiki/Bloat-videos][Buffer Bloat Videos]]

* Latihan

Gunakan templat sebagai titik awal untuk menyelesaikan latihan. Solusi telah disediakan.

** Latihan 1

Tulis program di mana dua goroutine saling melewatkan integer sepuluh kali.
Tampilkan kapan setiap goroutine menerima integer. Tingkatkan integer setiap kali lewat.
Setelah integer mencapai sepuluh, akhiri program.

.play channels/exercise1.go
.play channels/answer1.go

** Latihan 2

Tulis program yang menggunakan pola fan out untuk menghasilkan 100 angka acak secara bersamaan.
Setiap goroutine menghasilkan satu angka acak dan mengembalikan angka tersebut ke goroutine utama
melalui sebuah channel yang memiliki buffer. Tetapkan ukuran buffer channel sehingga
tidak ada pengiriman yang pernah diblokir. Jangan alokasikan lebih banyak buffer dari yang Anda butuhkan.
Biarkan goroutine utama menampilkan setiap angka acak yang diterima dan kemudian mengakhiri program.

.play channels/exercise2.go
.play channels/answer2.go

** Latihan 3

Tulis program yang menghasilkan hingga 100 angka acak secara bersamaan.
Jangan kirim semua 100 nilai sehingga jumlah pengiriman/penerimaan tidak diketahui.

.play channels/exercise3.go
.play channels/answer3.go

** Latihan 4

Tulis program yang menghasilkan hingga 100 angka acak secara bersamaan menggunakan sebuah worker pool.
Tolak nilai genap. Instruksikan semua workers untuk selesai ketika sudah dikumpulkan 100 angka ganjil.

.play channels/exercise4.go
.play channels/answer4.go
