Interfaces
Interfaces memberikan struktur pada program dan mendorong desain melalui komposisi

* Interfaces

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Interfaces memberikan struktur pada program dan mendorong desain melalui komposisi.
Mereka memungkinkan dan memaksa pembagian yang bersih antara komponen-komponen.
Standarisasi dari interfaces dapat menetapkan harapan yang jelas dan konsisten.
Decoupling berarti mengurangi ketergantungan antara komponen-komponen dan tipe-tipe yang digunakan.
Hal ini mengarah pada kebenaran, kualitas, dan kemudahan pemeliharaan.

** Ulasan Kode

- *Contoh* *1:* Kode yang Berulang yang Memerlukan Polimorfisme
- *Contoh* *2:* Polimorfisme
- *Contoh* *3:* Set Metode
- *Contoh* *4:* Alamat Nilai
- *Contoh* *5:* Penyimpanan dengan Nilai
- *Contoh* *6:* Penegasan Tipe
- *Contoh* *7:* Penegasan Tipe Bersyarat
- *Contoh* *8:* Interface Kosong dan Type Switches
- *Contoh* *9:* Penyimpanan Nilai

.play interfaces/example1.go
.play interfaces/example2.go
.play interfaces/example3.go
.play interfaces/example4.go
.play interfaces/example5.go
.play interfaces/example6.go
.play interfaces/example7.go
.play interfaces/example8.go
.play interfaces/example9.go

** Semantik Interface

Interfaces memungkinkan Anda mengelompokkan data konkret bersama
berdasarkan apa yang dapat dilakukan oleh data tersebut.
Ini tentang fokus pada apa yang dapat dilakukan oleh data, bukan pada apa data tersebut.
Interfaces juga membantu kode saya mengurangi ketergantungan terhadap perubahan
dengan meminta data konkret berdasarkan kemampuannya. Ini tidak terbatas pada satu jenis data.

Anda harus berusaha memahami perubahan data apa yang akan terjadi dan menggunakan interfaces
untuk memisahkan program dari perubahan tersebut. Interfaces seharusnya mendeskripsikan perilaku dan bukan keadaan.
Mereka seharusnya berupa kata kerja dan bukan kata benda.

Interfaces yang umum dan berfokus pada perilaku adalah yang terbaik. Interfaces dengan lebih
dari satu metode memiliki lebih dari satu alasan untuk berubah. Interfaces yang berbasis pada kata benda
cenderung kurang dapat digunakan kembali, lebih rentan terhadap perubahan, dan mengalahkan tujuan dari interfaces.
Ketidakpastian tentang perubahan bukanlah untuk ditebak, tetapi merupakan petunjuk untuk BERHENTI
dan mempelajari lebih lanjut. Anda harus membedakan antara kode yang mempertahankan diri
terhadap penipuan vs melindungi dari kecelakaan.

Gunakan interface ketika:

- Pengguna API perlu menyediakan rincian implementasi.
- API memiliki beberapa implementasi yang perlu dipelihara secara internal.
- Bagian dari API yang dapat berubah telah diidentifikasi dan memerlukan pemisahan.

Jangan menggunakan interface:

- Hanya demi menggunakan interface.
- Untuk menggeneralisasi suatu algoritma.
- Ketika pengguna dapat mendeklarasikan interface mereka sendiri.
- Jika tidak jelas bagaimana interface membuat kode menjadi lebih baik.

** Interfaces Tanpa Nilai

Hal pertama yang penting untuk dipahami adalah bahwa tipe interface mendeklarasikan tipe tanpa nilai.

    type reader interface {
        read(b []byte) (int, error)
    }

Tipe `reader` bukanlah tipe struktur (struct), melainkan tipe antarmuka (interface).
Deklarasinya tidak didasarkan pada keadaan, tetapi pada perilaku.
Tipe interface mendeklarasikan satu set metode perilaku yang data konkret harus tunjukkan
untuk memenuhi interface tersebut. Tidak ada yang konkret mengenai tipe interface,
oleh karena itu, mereka tidak memiliki nilai.

    var r reader

Karena mereka tidak memiliki nilai, pembuatan variabel (seperti r) terasa aneh
karena dalam model pemrograman kita, r tidak ada, itu tidak memiliki nilai.
Tidak ada yang dapat Anda manipulasi atau ubah tentang r itu sendiri.
Ini adalah konsep yang penting untuk dipahami.
Saya tidak pernah berurusan dengan nilai interface, hanya nilai konkret.
Sebuah interface memiliki representasi kompilator (tipe internal),
tetapi dalam model pemrograman kita, interface tidak memiliki nilai.

** Implementasi Antarmuka**

Go adalah bahasa yang berfokus pada konvensi daripada konfigurasi.
Ketika menyangkut implementasi interface oleh suatu tipe konkret, tidak ada pengecualian.

    type reader interface {
        read(b []byte) (int, error)
    }

    type file struct {
        name string
    }

    func (file) read(b []byte) (int, error) {
        s := "<rss><channel><title>Going Go</title></channel></rss>"
        copy(b, s)
        return len(s), nil
    }

Kode tersebut mendeklarasikan suatu tipe bernama `file` dan kemudian mendeklarasikan
suatu metode bernama `read`. Karena kedua deklarasi ini, Anda dapat mengatakan hal berikut:

"Tipe konkret `file` sekarang mengimplementasikan interface reader menggunakan semantik nilai."

Setiap kata yang diucapkan penting. Dalam Go, yang harus Anda lakukan hanyalah mendeklarasikan
set metode penuh perilaku yang didefinisikan oleh sebuah interface untuk mengimplementasikan interface tersebut.
Dalam hal ini, itulah yang telah saya lakukan karena interface reader hanya mendeklarasikan
satu tindakan perilaku bernama `read`.

    type reader interface {
        read(b []byte) (int, error)
    }

    type pipe struct {
        name string
    }

    func (pipe) read(b []byte) (int, error) {
        s := `{name: "Bill", title: "developer"}`
        copy(b, s)
        return len(s), nil
    }

Kode ini mendeklarasikan suatu tipe bernama `pipe` dan kemudian mendeklarasikan suatu metode dengan nama `read`.
Berdasarkan kedua deklarasi ini, Anda dapat mengatakan hal berikut:

"Tipe konkret `pipe` sekarang mengimplementasikan interface reader menggunakan semantik nilai."

Sekarang Anda memiliki dua tipe konkret yang mengimplementasikan interface reader.
Dua tipe konkret masing-masing dengan implementasi tersendiri.
Satu tipe membaca sistem file dan yang lainnya jaringan.

** Polimorfisme

Polimorfisme berarti bahwa suatu potongan kode mengubah perilakunya tergantung pada data konkret
yang sedang dioperasikan. Hal ini dikatakan oleh Tom Kurtz, yang merupakan penemu BASIC.
Ini adalah definisi yang akan kita gunakan ke depan.

    // retrieve can read any device and process the data.
    func retrieve(r reader) error {
        data := make([]byte, 100)

        len, err := r.read(data)
        if err != nil {
            return err
        }

        fmt.Println(string(data[:len]))
        return nil
    }

Lihatlah tipe data yang diterima oleh fungsi ini. Fungsi ini menginginkan nilai bertipe reader.
Ini tidak mungkin karena reader adalah sebuah interface dan interface adalah tipe tanpa nilai.
Fungsi ini tidak bisa meminta nilai reader, karena nilai tersebut tidak ada.

Jika fungsi tersebut tidak meminta nilai reader, maka apa yang diminta oleh fungsi tersebut?
Fungsi tersebut meminta satu-satunya hal yang dapat dimintanya, yaitu data konkret.

Fungsi retrieve adalah sebuah fungsi polimorfik karena ia meminta data konkret
bukan berdasarkan apa data tersebut (tipe konkret), melainkan berdasarkan
apa yang dapat dilakukan oleh data tersebut (tipe interface).

    f := file{"data.json"}
    p := pipe{"cfg_service"}

    retrieve(f)
    retrieve(p)

Anda dapat membuat dua nilai konkret, satu dengan tipe file dan satu dengan tipe pipe.
Kemudian, Anda dapat meneruskan salinan dari masing-masing nilai ke fungsi polimorfik ini.
Hal ini karena setiap nilai ini mengimplementasikan set metode penuh perilaku
yang didefinisikan oleh interface reader.

Ketika nilai konkret tipe file diteruskan ke retrieve, nilai tersebut disimpan
di dalam tipe internal dua satuan word yang mewakili nilai interface.

.image /tour/ind/static/img/i1.png

Satuan word kedua dari nilai interface menunjuk ke nilai yang disimpan.
Dalam hal ini, itu adalah salinan dari nilai file karena semantik nilai sedang berlaku.
Satuan word pertama menunjuk ke struktur data khusus yang disebut iTable.

iTable memiliki dua tujuan:

- Menjelaskan tipe nilai yang disimpan. Dalam kasus saya, itu adalah nilai file.
- Menyediakan pointer fungsi ke implementasi konkret dari set metode untuk tipe nilai yang disimpan.

Ketika panggilan read dilakukan terhadap nilai interface, pencarian iTable dilakukan
untuk menemukan implementasi konkret dari metode read yang terkait dengan tipe tersebut.
Kemudian panggilan metode dilakukan terhadap nilai yang disimpan dalam satuan word kedua.

Anda dapat mengatakan bahwa retrieve adalah fungsi polimorfik karena nilai konkret pipe
dapat diteruskan ke retrieve, dan sekarang panggilan ke read terhadap nilai interface mengubah perilakunya.
Kali ini panggilan ke read sedang membaca jaringan bukan membaca file.

** Aturan Set Metode

Mengimplementasikan sebuah interface menggunakan semantik pointer menerapkan
beberapa batasan pada kepatuhan interface.

    type notifier interface {
        notify()
    }

    type user struct {
        name  string
        email string
    }

    func (u *user) notify() {
        fmt.Printf("Sending User Email To %s<%s>\n", u.name, u.email)
    }

    func sendNotification(n notifier) {
        n.notify()
    }

    func main() {
        u := user{"Bill", "bill@email.com"}
        sendNotification(u)
    }

Interface notifier diimplementasikan menggunakan semantik pointer.
Ketika semantik nilai digunakan untuk melakukan panggilan polimorfik, pesan kompilator berikut dihasilkan.

    "cannot use u (type user) as type notifier in argument to sendNotification:
    user does not implement notifier (notify method has pointer receiver)"

Hal ini disebabkan oleh adanya seperangkat aturan khusus dalam spesifikasi mengenai set metode.
Aturan-aturan ini menentukan metode mana yang terlampir pada nilai dan pointer dari suatu tipe.
Aturan-aturan ini diterapkan untuk menjaga tingkat integritas tertinggi dalam program.

Ini adalah aturan-aturan yang didefinisikan dalam spesifikasi:

- Untuk setiap nilai tipe T, hanya metode yang diimplementasikan dengan penerima nilai untuk tipe tersebut termasuk dalam set metode dari nilai tersebut.
- Untuk alamat tipe T, semua metode yang diimplementasikan untuk tipe tersebut termasuk dalam set metode dari nilai tersebut.

Dengan kata lain, ketika bekerja dengan suatu alamat (pointer), semua metode yang diimplementasikan
terlampir dan tersedia untuk dipanggil. Ketika bekerja dengan suatu nilai, hanya metode yang diimplementasikan
dengan penerima nilai yang terlampir dan tersedia untuk dipanggil.

Pada pelajaran sebelumnya tentang metode, Anda dapat memanggil metode terhadap suatu data konkret
tanpa memperhatikan semantik data yang dinyatakan oleh penerima. Ini karena kompilator dapat menyesuaikan
untuk melakukan panggilan tersebut. Dalam kasus ini, sebuah nilai disimpan dalam sebuah interface dan metode harus ada.
Tidak ada penyesuaian yang dapat dilakukan.

Pertanyaannya sekarang menjadi: Mengapa metode yang diimplementasikan dengan penerima pointer
tidak dapat terlampir pada nilai tipe T? Apa masalah integritas di sini?

Salah satu alasan adalah karena Anda tidak dapat menjamin bahwa setiap nilai tipe T dapat diakses dengan alamat.
Jika suatu nilai tidak memiliki alamat, maka nilai tersebut tidak dapat dibagikan.

    type duration int

    func (d *duration) notify() {
            fmt.Println("Sending Notification in", *d)
    }

    func main() {
        duration(42).notify()
    }

Error Kompilator:

    cannot call pointer method on duration(42)
    cannot take the address of duration(42)

Dalam contoh ini, nilai 42 adalah konstanta bertipe int. Meskipun nilai tersebut dikonversi
menjadi nilai bertipe duration, tetapi tidak disimpan dalam suatu variabel.
Ini berarti nilai tersebut tidak pernah berada di stack atau heap. Tidak ada alamatnya.
Konstanta hanya ada selama waktu kompilasi.

Alasan kedua adalah alasan yang lebih besar. Kompilator memberi tahu Anda bahwa Anda
tidak diizinkan menggunakan semantik nilai jika Anda telah memilih menggunakan semantik pointer.
Dengan kata lain, Anda dipaksa untuk berbagi nilai dengan interface karena tidak aman membuat salinan nilai
yang ditunjuk oleh pointer. Jika Anda memilih untuk mengimplementasikan metode dengan semantik pointer,
Anda menyatakan bahwa nilai tipe ini tidak aman untuk disalin.

    func main() {
        u := user{"Bill", "bill@email.com"}
        sendNotification(&u)
    }


Untuk memperbaiki pesan kompilator, Anda harus menggunakan semantik pointer pada panggilan fungsi polimorfik
dan berbagi u. Jawabannya bukan untuk mengubah metode untuk menggunakan semantik nilai.

** Slice dari Interface

Ketika Anda mendeklarasikan slice dari tipe interface, saya dapat mengelompokkan berbagai nilai konkret
bersama berdasarkan apa yang dapat mereka lakukan. Inilah mengapa Go tidak memerlukan konsep sub-typing.
Ini bukan tentang DNA yang sama, tetapi tentang perilaku yang sama.

    type printer interface {
        print()
    }

    type canon struct {
        name string
    }

    func (c canon) print() {
        fmt.Printf("Printer Name: %s\n", c.name)
    }

    type epson struct {
        name string
    }

    func (e *epson) print() {
        fmt.Printf("Printer Name: %s\n", e.name)
    }

    func main() {
        c := canon{"PIXMA TR4520"}
        e := epson{"WorkForce Pro WF-3720"}

        printers := []printer{
            c,
            &e,
        }
        c.name = "PROGRAF PRO-1000"
        e.name = "Home XP-4100"

        for _, p := range printers {
            p.print()
        }
    }

Keluaran:

    Printer Name: PIXMA TR4520
    Printer Name: Home XP-4100

Kode tersebut menunjukkan bagaimana sebuah slice dari tipe interface printer memungkinkan saya
membuat koleksi dari berbagai tipe konkret printer. Melakukan iterasi pada koleksi dan memanfaatkan polimorfisme
karena panggilan ke `p.print` mengubah perilakunya tergantung pada nilai konkret yang sedang dioperasikan oleh kode.

Contoh ini juga menunjukkan bagaimana pilihan semantik data mengubah perilaku program. Saat menyimpan data
menggunakan semantik nilai, perubahan terhadap nilai asli tidak terlihat. Ini karena salinan disimpan di dalam interface.
Saat semantik pointer digunakan, perubahan apapun terhadap nilai asli terlihat.

** Catatan

- Set metode untuk sebuah nilai hanya mencakup metode yang diimplementasikan dengan penerima nilai.
- Set metode untuk sebuah pointer mencakup metode yang diimplementasikan baik dengan penerima pointer maupun penerima nilai.
- Metode yang dideklarasikan dengan penerima pointer hanya mengimplementasikan interface dengan nilai pointer.
- Metode yang dideklarasikan dengan penerima nilai mengimplementasikan interface baik dengan nilai maupun pointer sebagai penerima.
- Aturan-aturan dari set metode berlaku untuk tipe interface.
- Interface adalah tipe referensi, jangan dibagikan dengan pointer.
- Inilah cara kita membuat perilaku polimorfik di Go.

** Kutipan

"Polymorphism means that you write a certain program and it behaves differently depending on the data that it operates on." - Tom Kurtz (inventor of BASIC)

"The empty interface says nothing." - Rob Pike

"Design is the art of arranging code to work today, and be changeable forever." - Sandi Metz

"A proper abstraction decouples the code so that every change doesn’t echo throughout the entire code base." - Ronna Steinburg

** Bacaan Tamabahan

- [[https://golang.org/doc/effective_go.html#interfaces][Interfaces]]
- [[https://blog.golang.org/laws-of-reflection][The Laws of Reflection]] - Rob Pike
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methods, Interfaces and Embedded Types in Go]] - William Kennedy
- [[https://rakyll.org/interface-pollution/][Interface Pollution]] - JBD
- [[https://bravenewgeek.com/abstraction-considered-harmful/][Abstraction Considered Harmful]] - Tyler Treat
- [[https://www.ardanlabs.com/blog/2018/03/interface-values-are-valueless.html][Interface Values Are Valueless]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2017/07/interface-semantics.html][Interface Semantics]] - William Kennedy
- [[https://www.hyrumslaw.com/][Hyrum's Law]] - Hyrum
- [[https://www.youtube.com/watch?v=Pjz9WrXeOW0][Engineering Innovation - Why Constraints Are Critical]] - André Eriksson (MUST WATCH)

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

*Bagian* *A:* Deklarasikan sebuah interface bernama speaker dengan sebuah metode bernama speak.
Deklarasikan sebuah struct bernama english yang mewakili seseorang yang berbicara dalam bahasa Inggris,
dan mendeklarasikan sebuah struct bernama chinese untuk seseorang yang berbicara dalam bahasa Cina.
Mengimplementasikan interface speaker untuk masing-masing struct dengan menggunakan penerima nilai
dan string literal "Hello World" dan "你好世界". Mendeklarasikan sebuah variabel bertipe speaker dan
memberikan alamat dari suatu nilai bertipe english, dan memanggil metodenya.
Lakukan hal yang sama untuk nilai bertipe chinese.

*Bagian* *B:* Tambahkan fungsi baru bernama sayHello yang menerima suatu nilai bertipe speaker.
Mengimplementasikan fungsi tersebut untuk memanggil metode speak pada nilai interface.
Kemudian membuat nilai baru untuk setiap tipe dan menggunakan fungsi tersebut.

.play interfaces/exercise1.go
.play interfaces/answer1.go
