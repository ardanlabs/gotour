Slices
Slices adalah struktur data yang sangat penting dalam Go. Mereka menjadi dasar cara kita mengelola dan memanipulasi data dengan cara yang fleksibel, efisien, dan dinamis. Sangat bermanfaat bagi semua programmer Go untuk memahami bagaimana slices bekerja, dan bagaimana menggunakannya.

* Slices

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Slices adalah struktur data yang sangat penting dalam Go. Mereka menjadi dasar
bagaimana kita mengelola dan memanipulasi data dengan cara yang fleksibel, efisien, dan dinamis. 
Sangat bermanfaat bagi semua programmer Go untuk memahami bagaimana slices bekerja, dan bagaimana menggunakannya.

.image /tour/ind/static/img/sl1.png

** Tinjauan Kode

- *Contoh* *1:* Deklarasi dan Panjang
- *Contoh* *2:* Tipe Referensi
- *Contoh* *3:* Menambahkan slices
- *Contoh* *4:* Mengambil slices dari slices
- *Contoh* *5:* Slices dan Referensi
- *Contoh* *6:* String dan slices
- *Contoh* *7:* Fungsi Variadik
- *Contoh* *8:* Mekanika Range
- *Contoh* *9:* Traversals yang Efisien
- *Contoh* *10:* Slices tiga indeks

.play slices/example1.go
.play slices/example2.go
.play slices/example3.go
.play slices/example4.go
.play slices/example5.go
.play slices/example6.go
.play slices/example7.go
.play slices/example8.go
.play slices/example9.go 
.play slices/example10.go

** Pembuatan Slice

Membuat slice dapat dilakukan dengan beberapa cara.

    // Slice string diatur ke keadaan nol value-nya.
    var slice []string

    // Slice string diatur ke keadaan kosongnya.
    slice := []string{}

    // Slice string diatur dengan panjang dan kapasitas 5.
    slice := make([]string, 5)

    // Slice string diatur dengan panjang 5 dan kapasitas 8.
    slice := make([]string, 5, 8)

    // Slice string diatur dengan nilai dengan panjang dan kapasitas 5.
    slice := []string{"A", "B", "C", "D", "E"}

Anda dapat melihat bahwa fungsi bawaan "make" memungkinkan untuk mengalokasikan 
sekaligus dengan panjang dan kapasitas untuk array yang mendukungnya. Jika kompilator tahu 
ukurannya saat proses kompilasi, array yang mendukungnya dapat dibangun di stack.


** Panjang vs Kapasitas Slice

Panjang slice mewakili jumlah elemen yang dapat dibaca dan
ditulis. Kapasitas mewakili jumlah total elemen yang ada
di dalam array penyangga dari posisi pointer tersebut.

Dikarenakan syntaks yang dipermudah, slices terlihat dan terasa seperti array.

    slice := make([]string, 5)
    slice[0] = "Apple"
    slice[1] = "Orange"
    slice[2] = "Banana"
    slice[3] = "Grape"
    slice[4] = "Plum"

Anda dapat membedakan antara konstruksi slice dan array karena array memiliki 
ukuran yang diketahui saat kompilasi dan slice tidak.

Jika Anda mencoba mengakses elemen di luar panjang slice, Anda akan mendapatkan error saat runtime.

    slice := make([]string, 5)
    slice[5] = "Raspberry"

Error Kompilator:

    Error: panic: runtime error: index out of range slice[5] = "Runtime error"

Pada contoh ini, panjang slice adalah 5 dan saya mencoba mengakses elemen ke-6, 
yang tidak ada.

** Pedoman Semantik Data Untuk Slices

Sebagai panduan, jika data yang saya kerjakan adalah slice, maka gunakan nilai semantik
untuk memindahkan data di dalam program. Ini termasuk mendeklarasikan field pada suatu tipe.

    func Foo(data []byte) []byte

    type Foo struct {
        X []int
        Y []string
        Z []bool
    }

Ini berlaku untuk semua struktur data internal Go (slices, maps, channels, interfaces, dan functions).

Salah satu alasan untuk beralih ke semantik pointer adalah jika Anda perlu membagikan slice 
untuk operasi penguraian atau unmarshaling. Menggunakan pointer untuk jenis operasi ini
boleh-boleh saja, tetapi dokumentasikan jika tidak jelas.

** Layout Memori Beruntun

Ide di balik slice adalah memiliki array, yang merupakan struktur data yang paling efisien
berkaitan dengan perangkat keras. Namun, Anda masih memerlukan kemampuan untuk menjadi
dinamis dan efisien dengan jumlah data yang Anda butuhkan saat runtime dan penambahan data mendatang.

    func main() {
        slice := make([]string, 5, 8)
        slice[0] = "Apple"
        slice[1] = "Orange"
        slice[2] = "Banana"
        slice[3] = "Grape"
        slice[4] = "Plum"

        inspectSlice(slice)
    }

    func inspectSlice(slice []string) {
        fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
        for i := range slice {
            fmt.Printf("[%d] %p %s\n", i, &slice[i], slice[i])
        }
    }

Keluaran:

    Length[5] Capacity[8]
    [0] 0xc00007e000 Apple
    [1] 0xc00007e010 Orange
    [2] 0xc00007e020 Banana
    [3] 0xc00007e030 Grape
    [4] 0xc00007e040 Plum

Fungsi inspectSlice menunjukkan bagaimana slice memiliki array penyangga yang berurutan
dengan langkah yang dapat diprediksi. Ini juga menunjukkan bagaimana slice memiliki panjang 
dan kapasitas yang mungkin berbeda. Perhatikan bagaimana fungsi print hanya berulang sesuai
panjang slice.

** Menambahkan Data Pada Slices

Bahasa ini menyediakan fungsi bawaan bernama append untuk menambahkan nilai ke
slice yang ada.

    var data []string

    for record := 1; record <= 102400; record++ {
        data = append(data, fmt.Sprintf("Rec: %d", record))
    }

Fungsi append bekerja dengan slice bahkan ketika slice diinisialisasi dengan
keadaan nilai nolnya. Yang menarik dari desain API append adalah karena menggunakan
mutasi nilai semantik. Append mendapatkan salinan nilai slice dari slice itu sendiri, 
ia mengubah salinanannya sendiri, lalu mengembalikan salinan kembali ke pemanggil.

Mengapa API ini dirancang seperti ini? Ini karena idiomnya adalah menggunakan nilai semantik
untuk memindahkan nilai slice di seluruh program. Ini harus tetap diperhatikan bahkan dengan 
operasi mutasi. Plus, mutasi nilai semantik adalah cara yang paling aman untuk melakukan mutasi
karena mutasi dilakukan pada salinan data dalam fungsi itu sendiri secara terisolasi.

Append selalu menjaga blok memori berurutan untuk array penyangga slice,
bahkan setelah pertumbuhan. Ini penting untuk perangkat keras.

.image /tour/ind/static/img/sl2.png

Setiap kali fungsi append dipanggil, fungsi tersebut memeriksa apakah panjang dan
kapasitas slice sama atau tidak. Jika sama, itu berarti tidak ada
ruang lagi dalam array penyangga untuk nilai baru. Dalam hal ini, append membuat
array penyangga baru (melipatgandakan atau bertambah 25%) dan kemudian menyalin nilai dari
array lama ke yang baru. Kemudian nilai baru dapat ditambahkan.

.image /tour/ind/static/img/sl3.png

Jika kapasitas slice tidak sama dengan panjangnya, itu berarti ada elemen kapasitas 
ekstra yang ada untuk ditambahkan. Sebuah elemen diambil dari kapasitas dan ditambahkan 
ke panjang slice. Ini membuat operasi append sangat efisien.

Ketika array penyangga memiliki kapasitas 1024 elemen atau kurang, array penyangga baru
dibangun dengan menggandakan ukuran array yang ada. Setelah array penyangga
membesar melebihi 1024 elemen, pertumbuhan terjadi sebesar 25%.

*CATATAN:* *Bagaimana* *fungsi* *append* *mengembangkan* *kapasitas* *array* *pendukung*
*telah* *berubah* *sejak* *Go* *1.18.*

- [[https://tip.golang.org/doc/go1.18#runtime][https://tip.golang.org/doc/go1.18#runtime]]

** Memotong Slices

Slice memberikan kemampuan untuk menghindari salinan tambahan dan alokasi heap dari 
array penyangga saat perlu mengisolasi elemen-elemen tertentu dari array penyangga untuk 
operasi yang berbeda.

Sintak pemotongan mewakili notasi daftar [a:b), yang berarti, sertakan
elemen dari indeks a hingga b, tetapi tidak termasuk b.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]

Variabel slice2 adalah nilai slice baru yang sekarang berbagi array penyangga
yang sama dengan slice1. Namun, slice2 hanya memungkinkan Anda mengakses 
elemen-elemen di indeks 2 dan 3 (C dan D) dari array penyangga slice asli. Panjang 
slice2 adalah 2 dan bukan 5 seperti pada slice1 dan kapasitasnya adalah 3 karena 
sekarang terdapat 3 elemen dari posisi pointer tersebut.

.image /tour/ind/static/img/sl4.png

Cara terbaik untuk memikirkan tentang pemotongan adalah fokus pada panjang menggunakan 
notasi ini [a:a+len] indeks a hingga a ditambah panjang. Ini akan mengurangi kesalahan 
dalam menghitung slice baru.

Dengan menggunakan fungsi inspeksi ini.

    func inspectSlice(slice []string) {
        fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
        for i, s := range slice {
            fmt.Printf("[%d] %p %s\n",
                i,
                &slice[i],
                s)
        }
    }

Anda dapat melihat bagaimana fungsi tersebut beraksi.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    inspectSlice(slice1)
    inspectSlice(slice2)

Keluaran:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[3]
    [0] 0xc00007e020 C     <-- SAMA SEPERTI INDEKS 2 PADA SLICE 1
    [1] 0xc00007e030 D     <-- SAMA SEPERTI INDEKS 3 PADA SLICE 1

Perhatikan bagaimana dua slice yang berbeda berbagi array penyangga yang sama. Anda dapat
melihat ini dengan membandingkan alamatnya.

Hal yang bagus di sini adalah tidak ada alokasi tambahan. Kompilator tahu ukuran
array penyangga slice1 saat kompilasi. Mengirimkan salinan nilai slice ke
fungsi inspectSlice menjaga semua di stack.

** Mutasi Terhadap array penyangga

Ketika Anda menggunakan slice2 untuk mengubah nilai string di indeks 0, setiap 
nilai slice yang berbagi array penyangga yang sama (di mana alamat untuk indeks 
tersebut adalah bagian dari panjang slice itu sendiri) akan melihat perubahan tersebut.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    slice2[0] = "CHANGED"
    inspectSlice(slice1)
    inspectSlice(slice2)

Keluaran:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 CHANGED
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[3]
    [0] 0xc00007e020 CHANGED
    [1] 0xc00007e030 D

Anda harus selalu memerhatikan ketika Anda mengubah nilai pada posisi indeks jika
array penyangga dibagi dengan slice lain.

.image /tour/ind/static/img/sl5.png

Bagaimana jika Anda menggunakan fungsi bawaan append?

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    slice2 = append(slice2, "CHANGED")
    inspectSlice(slice1)
    inspectSlice(slice2)

Keluaran:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 CHANGED
    Length[3] Capacity[3]
    [0] 0xc00007e020 C
    [1] 0xc00007e030 D
    [2] 0xc00007e040 CHANGED

Fungsi append menciptakan efek samping yang sama, tetapi tersembunyi. Dalam hal ini,
membawa lebih banyak panjang dari kapasitas slice2 menyebabkan nilai pada alamat
0xc00007e040 berubah. Sayangnya, slice1 sudah memiliki alamat ini sebagai
bagian dari panjangnya.

.image /tour/ind/static/img/sl6.png

Salah satu cara untuk menghindari efek samping adalah dengan menggunakan slice tiga indeks 
saat membuat slice2 sehingga panjang dan kapasitasnya sama dengan 2.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4:4]
    inspectSlice(slice1)
    inspectSlice(slice2)

Keluaran:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[2]
    [0] 0xc00007e020 C
    [1] 0xc00007e030 D

Sintaks untuk slice tiga indeks adalah [a:b:c] ketika b dan c seharusnya sama
karena [a-b] menetapkan panjang dan [a-c] menetapkan kapasitas. Sekarang panjang dan
kapasitas slice2 sama.

Sekarang Anda menggunakan fungsi bawaan append lagi seperti sebelumnya.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4:4]
    slice2 = append(slice2, "CHANGED")
    inspectSlice(slice1)
    inspectSlice(slice2)

Keluaran:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[3] Capacity[4]
    [0] 0xc000016080 C
    [1] 0xc000016090 D
    [2] 0xc0000160a0 CHANGED

Perhatikan setelah fung append dipanggil, slice2 memiliki array penyangga baru.

.image /tour/ind/static/img/sl7.png

Ini dapat dilihat dengan membandingkan alamat masing-masing slice. Dalam hal ini,
mutasi terhadap slice2 tidak menyebabkan efek samping terhadap slice1.

** Menyalin Slices Secara Manual

Ada fungsi bawaan bernama copy yang memungkinkan untuk menyalin slice secara dangkal. 
Karena string memiliki array penyangga byte yang tidak berubah, itu
dapat digunakan sebagai sumber tetapi tidak pernah sebagai tujuan.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice3 := make([]string, len(slice1))
    copy(slice3, slice1)

    inspectSlice(slice1)
    inspectSlice(slice3)

Keluaran:

    Length[5] Capacity[5]
    [0] 0xc00005c050 A
    [1] 0xc00005c060 B
    [2] 0xc00005c070 C
    [3] 0xc00005c080 D
    [4] 0xc00005c090 E
    Length[5] Capacity[5]
    [0] 0xc00005c0a0 A
    [1] 0xc00005c0b0 B
    [2] 0xc00005c0c0 C
    [3] 0xc00005c0d0 D
    [4] 0xc00005c0e0 E

Selama slice tujuan memiliki tipe dan panjang yang tepat, fungsi bawaan
copy dapat melakukan salinan dangkal.

** Slices Menggunakan Mutasi Semantik Pointer

Penting untuk diingat bahwa meskipun Anda menggunakan nilai semantik untuk memindahkan 
slice dalam program, saat membaca dan menulis slice, Anda menggunakan semantik pointer. 
Berbagi elemen individu dari slice dengan bagian yang berbeda dari program yang dimiliki 
dapat menyebabkan efek samping yang tidak diinginkan.

    // Membuat slice yang terdiri dari 1 user, mengatur pointer ke user tersebut,
    // menggunakan pointer untuk memperbarui jumlah likes.

    users := make([]user, 1)
    ptrUsr0 := &users[0]
    ptrUsr0.likes++

    for i := range users {
        fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
    }

Keluaran:

    User: 0 Likes: 1

Sebuah slice digunakan untuk memelihara koleksi user. Kemudian sebuah pointer 
diatur ke user pertama dan digunakan untuk memperbarui jumlah likes. Hasilnya 
menunjukkan bahwa menggunakan pointer berhasil.

.image /tour/ind/static/img/sl8.png
 
Kemudian user baru ditambahkan ke koleksi tersebut, dan pointer 
digunakan lagi untuk menambahkan likes pada pengguna pertama.

    // Menambahkan user baru ke koleksi. Menggunakan pointer lagi
    // untuk memperbarui jumlah likes.

    users = append(users, user{})
    ptrUsr0.likes++

    for i := range users {
        fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
    }

Keluaran:

    User: 0 Likes: 1
    User: 1 Likes: 0

Namun, karena fungsi append menggantikan array penyangga dengan yang baru,
pointer mengupdate array penyangga yang lama, dan jumlah likes hilang. Hasilnya
menunjukkan bahwa jumlah likes untuk user pertama tidak meningkat.

.image /tour/ind/static/img/sl9.png

Anda harus berhati-hati untuk mengetahui apakah operasi append akan digunakan pada slice selama 
program berjalan. Bagaimana Anda berbagi slice perlu dipertimbangkan. Berbagi indeks 
individu mungkin bukan ide terbaik. Berbagi nilai slice secara keseluruhan juga mungkin 
tidak berfungsi ketika append sedang berjalan. Mungkin menggunakan slice sebagai field dalam 
sebuah tipe data struct, dan berbagi nilai dari tipe data struct tersebut adalah cara yang lebih baik.

** Efisiensi Traversal Linear
Kelebihan slice adalah kemampuannya untuk memungkinkan traversasi linear yang 
bersifat mekanik sambil berbagi data dengan menggunakan nilai semantik untuk 
meminimalkan alokasi heap.

    x := []byte{0x0A, 0x15, 0x0e, 0x28, 0x05, 0x96, 0x0b, 0xd0, 0x0}

    a := x[0]
    b := binary.LittleEndian.Uint16(x[1:3])
    c := binary.LittleEndian.Uint16(x[3:5])
    d := binary.LittleEndian.Uint32(x[5:9])

    println(a, b, c, d)

Kode ini melakukan traversasi linear dengan membuat nilai slice yang membaca
bagian-bagian berbeda dari array byte dari awal hingga akhir.

.image /tour/ind/static/img/sl10.png

Semua data dalam kode ini tetap ada di stack. Tidak ada salinan ekstra dari data di dalam
byte slice yang disalin.

** Catatan

- Slice seperti array dinamis dengan fungsi khusus dan terintegrasi.
- Ada perbedaan antara panjang dan kapasitas slice, dan keduanya memiliki tujuan yang berbeda.
- Slice memungkinkan adanya beberapa "tampilan" dari array yang sama di bawahnya.
- Slice dapat tumbuh melalui penggunaan fungsi bawaan append.

** Bacaan Tambahan

- [[https://blog.golang.org/go-slices-usage-and-internals][Go Slices: usage and internals]] - Andrew Gerrand    
- [[https://blog.golang.org/strings][Strings, bytes, runes and characters in Go]] - Rob Pike    
- [[https://blog.golang.org/slices][Arrays, slices (and strings): The mechanics of 'append']] - Rob Pike        
- [[https://www.ardanlabs.com/blog/2013/08/understanding-slices-in-go-programming.html][Understanding Slices in Go Programming]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/08/collections-of-unknown-length-in-go.html][Collections Of Unknown Length in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/09/iterating-over-slices-in-go.html][Iterating Over Slices In Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/09/slices-of-slices-of-slices-in-go.html][Slices of Slices of Slices in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/12/three-index-slices-in-go-12.html][Three-Index Slices in Go 1.2]] - William Kennedy    
- [[https://github.com/golang/go/wiki/SliceTricks][SliceTricks]]    
- [[https://go-review.googlesource.com/c/go/+/347917][runtime: Make slice growth formula a bit smoother]] - Go Team 
			 
* Latihan

Gunakan templat sebagai titik awal untuk menyelesaikan latihan. Solusi telah disediakan.

** Latihan 1

*Bagian* *A:* Deklarasikan slice interger yang kosong (nil). Buat perulangan yang menambahkan 10 nilai
ke dalam slice. Iterasi slice tersebut dan tampilkan setiap nilai.

*Bagian* *B:* Deklarasikan slice berisi lima string dan inisialisasi slice tersebut dengan nilai string 
literal. Tampilkan semua elemennya. Ambil slice indeks satu dan dua dan tampilkan posisi 
indeks dan nilai masing-masing elemen di slice baru tersebut.

.play slices/exercise1.go		  
.play slices/answer1.go
