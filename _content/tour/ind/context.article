Paket Context
Paket context mendefinisikan tipe Context, yang membawa batas waktu, sinyal pembatalan, dan nilai-nilai lain yang terkait dengan permintaan melintasi batas API dan antar proses.

* Paket Context

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Paket context mendefinisikan tipe Context, yang membawa batas waktu, sinyal pembatalan, dan nilai-nilai lain
yang terkait dengan permintaan melintasi batas API dan antar proses.

** Ulasan Kode

"Nilai-nilai context digunakan untuk data yang bersifat cakupan permintaan dan melewati program-program
dalam sistem terdistribusi."

- *Example* *1:* Store / Retrieve Values
- *Example* *2:* WithCancel
- *Example* *3:* WithDeadline
- *Example* *4:* WithTimeout
- *Example* *5:* Request/Response
- *Example* *6:* Cancellation

.play context/example1.go
.play context/example2.go
.play context/example3.go
.play context/example4.go
.play context/example5.go
.play context/example6.go

** Semantik Context

Bahasa pemrograman Go memiliki kata kunci bawaan `go` untuk membuat goroutine,
tetapi tidak memiliki kata kunci atau dukungan langsung untuk menghentikan goroutine.
Dalam layanan dunia nyata, kemampuan untuk mengatur waktu dan menghentikan goroutine adalah hal kritis
untuk menjaga kesehatan dan operasi suatu layanan. Tidak ada permintaan atau tugas yang boleh berjalan selamanya,
sehingga mengidentifikasi dan mengelola latensi adalah tanggung jawab setiap pemrogram.

Sebuah solusi yang diberikan oleh tim Go untuk menyelesaikan masalah ini adalah paket Context.
Paket ini ditulis dan diperkenalkan oleh Sameer Ajmani pada konferensi Gotham Go tahun 2014.
Beliau juga menulis sebuah pos blog untuk blog Go.

Presentasi: [[https://talks.golang.org/2014/gotham-context.slide#1][https://talks.golang.org/2014/gotham-context.slide#1]]

Tulisan Blog: [[https://blog.golang.org/context][https://blog.golang.org/context]]

Melalui karya yang dipublikasikan ini dan percakapan dengan Sameer selama bertahun-tahun,
sejumlah semantik telah berkembang.

*Permintaan* *masuk* *ke* *server* *harus* *membuat* *Context*

Waktu untuk membuat Context selalu sesegera mungkin dalam pengolahan permintaan atau task.
Bekerja dengan Context pada awal siklus pengembangan akan memaksa Anda untuk merancang API
agar menerima Context sebagai parameter pertama. Meskipun Anda tidak yakin 100% bahwa
suatu fungsi membutuhkan Context, lebih mudah untuk menghapus Context dari beberapa fungsi
daripada mencoba menambahkan Context nanti.

    75 // Handle is our mechanism for mounting Handlers for a given HTTP verb and path
    76 // pair, this makes for really easy, convenient routing.
    77 func (a *App) Handle(verb, path string, handler Handler, mw ...Middleware) {
    ...
    85     // The function to execute for each request.
    86     h := func(w http.ResponseWriter, r *http.Request, params map[string]string) {
    87         ctx, span := trace.StartSpan(r.Context(), "internal.platform.web")
    88         defer span.End()
    ...
    106    // Add this handler for the specified verb and route.
    107    a.TreeMux.Handle(verb, path, h)
    108 }

Anda melihat kode yang diambil dari proyek layanan yang kami ajarkan di Ardan Labs.
Baris 86 mendefinisikan fungsi handler yang terikat ke semua rute seperti yang ditunjukkan pada baris 107.
Fungsi inilah yang mulai memproses setiap permintaan masuk. Pada baris 87, sebuah span dibuat untuk permintaan
yang mengambil Context sebagai parameter pertamanya. Ini adalah pertama kalinya dalam kode layanan
sebuah Context diperlukan.

Hal yang bagus di sini adalah bahwa nilai http.Request sudah mengandung Context.
Ini ditambahkan dalam versi 1.7 dari Go. Ini berarti kode tidak perlu membuat Context tingkat atas secara manual.
Jika kita menggunakan versi 1.8 dari Go, maka Anda perlu membuat Context kosong sebelum panggilan ke StartSpan
dengan menggunakan fungsi context.Background.

    https://golang.org/pkg/context/#Background

    87         ctx := context.Background()
    88         ctx, span := trace.StartSpan(ctx, "internal.platform.web")
    89         defer span.End()

Inilah tampilan kode yang akan terlihat pada versi 1.8 dari Go.
Seperti yang dijelaskan dalam dokumentasi paket,

Background mengembalikan Context yang tidak nil, Context kosong. Itu tidak pernah dibatalkan,
tidak memiliki nilai, dan tidak memiliki batas waktu. Ini biasanya digunakan oleh fungsi main,
inisialisasi, dan pengujian, serta sebagai Context tingkat atas untuk permintaan masuk.

Merupakan idiom dalam Go untuk menggunakan nama variabel ctx untuk semua nilai Context.
Karena Context adalah sebuah interface, tidak seharusnya menggunakan semantik pointer.

    https://golang.org/pkg/context/#Context

    type Context interface {
        Deadline() (deadline time.Time, ok bool)
        Done() <-chan struct{}
        Err() error
        Value(key interface{}) interface{}
    }

Setiap fungsi yang menerima Context seharusnya mendapatkan salinan nilai interface itu sendiri.

*Panggilan* *keluar* *ke* *server* *harus* *menerima* *Context.*

Ide di balik semantik ini adalah bahwa panggilan tingkat yang lebih tinggi perlu
memberi tahu panggilan tingkat lebih rendah berapa lama mereka bersedia menunggu.
Contoh bagus dari hal ini adalah dengan paket http dan perubahan pada versi 1.7
pada metode Do untuk mematuhi batas waktu pada suatu permintaan.

    01 package main
    02
    03 import (
    04     "context"
    05     "io"
    06     "log"
    07     "net/http"
    08     "os"
    09     "time"
    10 )
    11
    12 func main() {
    13
    14     // Create a new request.
    15     req, err := http.NewRequest("GET", "https://www.ardanlabs.com/blog/post/index.xml", nil)
    16     if err != nil {
    17         log.Println("ERROR:", err)
    18         return
    19     }
    20
    21     // Create a context with a timeout of 50 milliseconds.
    22     ctx, cancel := context.WithTimeout(req.Context(), 50*time.Millisecond)
    23     defer cancel()
    24
    25     // Bind the new context into the request.
    26     req = req.WithContext(ctx)
    27
    28     // Make the web call and return any error. Do will handle the
    29     // context level timeout.
    30     resp, err := http.DefaultClient.Do(req)
    31     if err != nil {
    32       log.Println("ERROR:", err)
    33       return
    34     }
    35
    36     // Close the response body on the return.
    37     defer resp.Body.Close()
    38
    39     // Write the response to stdout.
    40     io.Copy(os.Stdout, resp.Body)
    41 }

Program ini mengeluarkan permintaan untuk feed blog rss Ardan dengan batas waktu 50 milidetik.
Pada baris 15-19, permintaan dibuat untuk melakukan panggilan GET terhadap URL yang disediakan.
Baris 22-23 membuat Context dengan batas waktu 50 milidetik. API baru yang ditambahkan pada
nilai Request pada versi 1.7 adalah metode WithContext. Metode ini memungkinkan
nilai atribut Konteks dari Request diperbarui. Pada baris 26, itulah yang dilakukan oleh kode.

Pada baris 30, permintaan sebenarnya dibuat menggunakan metode Do dari nilai DefaultClient paket http.
Metode Do akan mematuhi nilai batas waktu 50 milidetik yang sekarang diatur di dalam Context dari Request.
Yang Anda lihat adalah kode (fungsi tingkat lebih tinggi) memberi tahu metode Do (fungsi tingkat lebih rendah)
berapa lama kita bersedia menunggu agar operasi Do selesai.

*Jangan* *Menyimpan* *Contexts* *dalam* *struct*

Sebaliknya, lewatkan Context secara eksplisit ke setiap fungsi yang membutuhkannya.
Pada dasarnya, setiap fungsi yang melakukan I/O seharusnya menerima nilai Context
sebagai parameter pertamanya dan mematuhi batas waktu atau tenggat waktu yang dikonfigurasi oleh pemanggil.
Dalam kasus Request, ada masalah kompatibilitas yang perlu dipertimbangkan. Jadi, alih-alih mengubah API-nya,
mekanisme yang ditunjukkan dalam bagian terakhir diimplementasikan.

Ada pengecualian untuk setiap aturan. Namun, dalam lingkup tulisan ini dan setiap API
dari pustaka standar yang menggunakan Context, idiomanya adalah memiliki parameter pertama menerima nilai Context.

.image /tour/ind/static/img/context_figure1.png

Gambar tersebut menunjukkan contoh dari paket net di mana parameter pertama
dari setiap metode mengambil Context sebagai parameter pertama dan menggunakan idiom nama variabel ctx.

*Rantai* *panggilan* *fungsi* *di* *antara* *mereka* *harus* *meneruskan* *Konteks*

Ini adalah aturan penting karena Context bersifat berdasarkan permintaan atau task.
Anda ingin Context dan semua perubahan yang dibuat padanya selama pengolahan
permintaan atau task untuk diwariskan dan dipatuhi.

    23 // List returns all the existing users in the system.
    24 func (u *User) List(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    25     ctx, span := trace.StartSpan(ctx, "handlers.User.List")
    26     defer span.End()
    27
    28     users, err := user.List(ctx, u.db)
    29     if err != nil {
    30         return err
    31     }
    32
    33     return web.Respond(ctx, w, users, http.StatusOK)
    34 }

Dalam daftar ini, Anda melihat fungsi handler yang disebut List yang dieksekusi ketika
seorang pengguna membuat permintaan HTTP untuk endpoint ini. Handler ini menerima Context
sebagai parameter pertamanya, karena bagian dari permintaan dan akan melakukan I/O.
Anda dapat melihat pada baris 25, 28, dan 33 bahwa nilai Context yang sama dilanjutkan panggilan lain.

Sebuah nilai Context baru tidak dibuat karena fungsi ini tidak memerlukan perubahan kepadanya.
Jika nilai Context tingkat atas baru dibuat oleh fungsi ini, informasi Context yang ada
dari panggilan tingkat lebih tinggi yang terkait dengan permintaan ini akan hilang.
Ini bukan yang kita inginkan.

    33 // List retrieves a list of existing users from the database.
    34 func List(ctx context.Context, db *sqlx.DB) ([]User, error) {
    35     ctx, span := trace.StartSpan(ctx, "internal.user.List")
    36     defer span.End()
    37
    38     users := []User{}
    39     const q = `SELECT * FROM users`
    40
    41     if err := db.SelectContext(ctx, &users, q); err != nil {
    42         return nil, errors.Wrap(err, "selecting users")
    43     }
    44
    45     return users, nil
    46 }

Anda melihat deklarasi metode List yang dipanggil pada baris 28. Sekali lagi,
metode ini menerima Context sebagai parameter pertamanya. Nilai ini kemudian dilanjutkan
ke pemanggilan fungsi lain sekali lagi pada baris 35 dan 41. Karena baris 41 adalah panggilan database, f
ungsi itu seharusnya mematuhi informasi batas waktu yang diatur dalam Context dari pemanggil apa pun di atasnya.

*Gantilah* *sebuah* *Context* *menggunakan* *WithCancel,* *WithDeadline,* *WithTimeout,* *atau* *WithValue.*

Karena setiap fungsi dapat menambahkan/memodifikasi Context untuk kebutuhan khusus mereka,
dan perubahan tersebut tidak boleh memengaruhi fungsi apa pun yang dipanggil sebelumnya, Context menggunakan semantik nilai.
Ini berarti setiap perubahan pada nilai Context membuat nilai Context baru yang kemudian diteruskan ke depan.

    01 func main() {
    02
    03     // Set a duration.
    04     duration := 150 * time.Millisecond
    05
    06     // Create a context that is both manually cancellable and will signal
    07     // cancel at the specified duration.
    08     ctx, cancel := context.WithTimeout(context.Background(), duration)
    09     defer cancel()
    10
    11     // Create a channel to receive a signal that work is done.
    12     ch := make(chan data, 1)
    13
    14     // Ask the goroutine to do some work for us.
    15     go func() {
    16
    17         // Simulate work.
    18         time.Sleep(50 * time.Millisecond)
    19
    20         // Report the work is done.
    21         ch <- data{"123"}
    22     }()
    23
    24     // Wait for the work to finish. If it takes too long, move on.
    25     select {
    26         case d := <-ch:
    27             fmt.Println("work complete", d)
    28
    29         case <-ctx.Done():
    30             fmt.Println("work cancelled")
    31     }
    32 }

Ini adalah program kecil yang menunjukkan sifat semantik nilai dari fungsi WithTimeout.
Pada baris 08, panggilan ke WithTimeout mengembalikan nilai Context baru dan fungsi pembatalan.
Karena panggilan fungsi memerlukan Context induk, kode menggunakan fungsi Background untuk
membuat Context kosong tingkat atas. Inilah guna fungsi Background.

Kedepannya nilai Context yang dibuat oleh fungsi WithTimeout digunakan. Jika fungsi-fungsi
di kedepannya dalam rantai panggilan memerlukan batas waktu atau tenggat waktu spesifik mereka sendiri,
mereka juga harus menggunakan fungsi With yang sesuai dan nilai Context baru ini sebagai awalan.

Sangat penting bahwa setiap fungsi pembatalan yang dikembalikan dari fungsi With dieksekusi
sebelum fungsi tersebut mengembalikan nilai. Inilah mengapa idiomnya adalah menggunakan
kata kunci defer tepat setelah panggilan With, seperti yang Anda lihat pada baris 26.
Tidak melakukan ini akan menyebabkan kebocoran memori dalam program Anda.

*Ketika* *sebuah* *Context* *dibatalkan,* *semua* *Context* *yang* *berasal* *darinya* *juga* *dibatalkan*

Penggunaan semantik nilai untuk API Context berarti setiap nilai Context baru diberikan segala sesuatu
yang dimiliki oleh Context sebelumnya ditambah dengan perubahan baru. Ini berarti jika Context sebelumnya dibatalkan,
semua Context yang berasal dari Context awal tersebut juga dibatalkan.

    01 func main() {
    02
    03     // Create a Context that can be cancelled.
    04     ctx, cancel := context.WithCancel(context.Background())
    05     defer cancel()
    06
    07     // Use the Waitgroup for orchestration.
    08     var wg sync.WaitGroup
    09     wg.Add(10)
    10
    11     // Create ten goroutines that will derive a Context from
    12     // the one created above.
    13     for i := 0; i < 10; i++ {
    14         go func(id int) {
    15             defer wg.Done()
    16
    17             // Derive a new Context for this goroutine from the Context
    18             // owned by the main function.
    19             ctx := context.WithValue(ctx, key, id)
    20
    21             // Wait until the Context is cancelled.
    22             <-ctx.Done()
    23             fmt.Println("Cancelled:", id)
    24         }(i)
    25     }
    26
    27     // Cancel the Context and any derived Context's as well.
    28     cancel()
    29     wg.Wait()
    30 }

Program ini membuat nilai Context yang dapat dibatalkan pada baris 04. Kemudian
pada baris 13-25, sepuluh goroutine dibuat. Setiap goroutine menempatkan id unik mereka
di dalam  nilai Context mereka sendiri pada baris 19. Panggilan ke WithValue diberikan
nilai Context fungsi utama sebagai awalan. Kemudian pada baris 22, setiap goroutine
menunggu hingga Context mereka dibatalkan.

Pada baris 28, goroutine utama membatalkan nilai Context-nya dan kemudian menunggu
pada baris 29 agar semua sepuluh goroutine menerima sinyal sebelum menutup program.
Begitu fungsi pembatalan dipanggil, semua sepuluh goroutine pada baris 41 akan dibebaskan
dari pemblokiran dan menampilkan pesan bahwa mereka telah dibatalkan.
Satu panggilan pembatalan untuk membatalkan semuanya.

Ini juga menunjukkan bahwa Context yang sama dapat diteruskan ke fungsi yang berjalan
dalam goroutine yang berbeda. Sebuah Context aman untuk digunakan secara simultan oleh beberapa goroutine.

Jangan melewatkan Context yang nil, meskipun sebuah fungsi mengizinkannya. Gunakan Context TODO
jika Anda tidak yakin tentang Context mana yang akan digunakan. Salah satu bagian favorit saya
dari paket Context adalah fungsi TODO. Saya sangat yakin bahwa seorang pemrogram selalu membuat draf kode.
Ini tidak berbeda dengan seorang penulis yang membuat versi artikel. Anda tidak pernah tahu segalanya
saat Anda menulis kode, tetapi semoga Anda tahu cukup untuk melanjutkan hal ini. Pada akhirnya,
Anda terus belajar, melakukan refaktor, dan mengujinya sepanjang proses.

Terkadang saya tahu saya memerlukan Context tetapi tidak yakin dari mana itu akan datang.
Saya tahu saya tidak bertanggung jawab untuk membuat Context tingkat atas,
jadi menggunakan fungsi Background tidak mungkin. Saya memerlukan Context tingkat atas
sementara sampai saya tahu dari mana Context sebenarnya berasal. Inilah saatnya
Anda seharusnya menggunakan fungsi TODO daripada fungsi Background.

*Gunakan* *nilai* *Konteks* *hanya* *untuk* *data* *yang* *berkaitan* *dengan* *permintaan*

Jangan menggunakan Context untuk melewatkan parameter opsional ke fungsi. Ini mungkin adalah
semantik yang paling penting dari semuanya. Jangan menggunakan nilai Context untuk melewatkan data
ke dalam fungsi ketika data itu diperlukan oleh fungsi untuk menjalankan kodenya dengan benar.
Dengan kata lain, sebuah fungsi seharusnya dapat menjalankan prosesnya dengan nilai Context yang kosong.
Dalam kasus di mana sebuah fungsi memerlukan informasi yang ada dalam Context, jika informasi tersebut hilang,
program seharusnya gagal dan memberi sinyal untuk memberhentikan aplikasi.

Contoh klasik dari penyalahgunaan melewatkan data ke panggilan fungsi menggunakan Context
adalah dengan koneksi basis data. Sebagai aturan umum, Anda ingin mengikuti urutan ini
saat memindahkan data di sekitar program Anda.

Lewatkan data sebagai parameter fungsi. Ini adalah cara yang paling jelas untuk memindahkan data
di sekitar program tanpa menyembunyikannya.

Lewatkan data melalui penerima. Jika fungsi yang membutuhkan data tidak dapat mengubah signature-nya,
maka gunakan metode dan lewati data melalui penerima.

Contoh kecil menggunakan penerima

Penangan permintaan (request handler) adalah contoh klasik dari aturan kedua. Karena fungsi penanganan
terikat pada deklarasi spesifik, signature dari penanganan tidak dapat diubah.

    23 // List returns all the existing users in the system.
    24 func (u *User) List(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    25     ctx, span := trace.StartSpan(ctx, "handlers.User.List")
    26     defer span.End()
    27
    28     users, err := user.List(ctx, u.db)
    29     if err != nil {
    30         return err
    31     }
    32
    33     return web.Respond(ctx, w, users, http.StatusOK)
    34 }

Di sini Anda melihat metode penangan List dari proyek layanan. Tanda tangan dari metode-metode
ini terikat pada apa yang didefinisikan oleh kerangka kerja web dan tidak dapat diubah.
Namun, untuk melakukan panggilan bisnis pada baris 28, diperlukan koneksi basis data.
Kode ini menggunakan pool koneksi bukan dari nilai Konteks yang diteruskan, tetapi dari penerima.

    15 // User represents the User API method handler set.
    16 type User struct {
    17     db            *sqlx.DB
    18     authenticator *auth.Authenticator
    19
    20 // ADD OTHER STATE LIKE THE LOGGER AND CONFIG HERE.
    21 }

Anda melihat deklarasi tipe penerima. Segala sesuatu yang dibutuhkan oleh penangan permintaan
didefinisikan sebagai atribut. Ini memungkinkan informasi tidak disembunyikan dan untuk
lapisan bisnis berfungsi dengan nilai Context yang kosong.

    14 // API constructs an http.Handler with all application routes defined.
    15 func API(shutdown chan os.Signal, log *log.Logger, db *sqlx.DB, authenticator *auth.Authenticator) http.Handler {
    16
    ...
    26     // Register user management and authentication endpoints.
    27     u := User{
    28         db:            db,
    29         authenticator: authenticator,
    30     }
    31
    32     app.Handle("GET", "/v1/users", u.List)

Kode ini membuat nilai User dan kemudian mengikat metode List ke rute.
Sekali lagi, karena tanda tangan fungsi penangan tidak dapat diubah,
menggunakan penerima dan metode adalah cara terbaik berikutnya
untuk melewatkan data tanpa menyembunyikannya.

*Data* *debugging* *atau* *tracing* *bersifat* *aman* *untuk* *dilewatkan* *dalam* *Context*

Data yang dapat disimpan dan diterima dari nilai Context adalah informasi debugging dan tracing.

    23 // Values represent state for each request.
    24 type Values struct {
    25     TraceID    string
    26     Now        time.Time
    27     StatusCode int
    28 }

Berikut adalah deklarasi tipe yang dibuat dan disimpan di dalam setiap nilai Context
yang dibuat untuk permintaan baru. Tiga atribut ini menyediakan informasi tracing dan debugging
untuk permintaan. Informasi ini dikumpulkan seiring dengan berjalannya proses permintaan.

    75 // Handle is our mechanism for mounting Handlers for a given HTTP verb and path
    76 // pair, this makes for really easy, convenient routing.
    77 func (a *App) Handle(verb, path string, handler Handler, mw ...Middleware) {
    78
    ...
    79     // The function to execute for each request.
    80     h := func(w http.ResponseWriter, r *http.Request, params map[string]string) {
    …
    84     // Set the context with the required values to
    85     // process the request.
    86     v := Values{
    87         TraceID: span.SpanContext().TraceID.String(),
    88         Now:     time.Now(),
    89     }
    90     ctx = context.WithValue(ctx, KeyValues, &v)

Lihat bagaimana tipe Values dibangun pada baris 86 dan kemudian disimpan
di dalam Context pada baris 90. Middleware logging adalah hal yang paling
membutuhkan sebagian besar informasi ini.

    20 // Create the handler that will be attached in the middleware chain.
    21 h := func(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    ...
    25     // If the context is missing this value, request the service
    26     // to be shutdown gracefully.
    27     v, ok := ctx.Value(web.KeyValues).(*web.Values)
    28     if !ok {
    29         return web.NewShutdownError("web value missing from context")
    30     }
    ...
    34     log.Printf("%s : (%d) : %s %s -> %s (%s)",
    35         v.TraceID, v.StatusCode,
    36         r.Method, r.URL.Path,
    37         r.RemoteAddr, time.Since(v.Now),
    38     )

Konsekuensi dari melewatkan informasi melalui Context ditunjukkan dalam kode pada baris 27-30.
Kode berusaha untuk mengambil data Values dari Context dan memeriksa apakah data tersebut ada.
Jika data tidak ada, maka ada masalah integritas dan layanan perlu dihentikan. Ini dilakukan
dalam kode layanan dengan mengirimkan nilai kesalahan khusus kembali melalui aplikasi.

Jika Anda melewatkan koneksi basis data atau informasi pengguna ke lapisan bisnis menggunakan Context, Anda memiliki dua masalah:

- Anda perlu memeriksa integritas dan Anda memerlukan mekanisme untuk mematikan layanan dengan cepat.
- Pengujian dan debugging menjadi lebih sulit dan rumit. Anda meninggalkan kejelasan dan keberbacaan yang lebih baik dalam kode Anda.

** Catatan

- Permintaan yang masuk ke server harus membuat Context.
- Panggilan keluar ke server harus menerima Context.
- Rantai panggilan fungsi di antara keduanya harus mengirimkan Context.
- Gantilah sebuah Context menggunakan WithCancel, WithDeadline, WithTimeout, atau WithValue.
- Ketika sebuah Context dibatalkan, semua Context yang berasal darinya juga dibatalkan.
- Jangan menyimpan Context di dalam tipe struct; sebaliknya, lewatkan Context secara eksplisit ke setiap fungsi yang membutuhkannya.
- Jangan melewatkan Context nil, bahkan jika suatu fungsi mengizinkannya. Gunakan context.TODO
  jika Anda tidak yakin tentang Context mana yang akan digunakan.
- Gunakan nilai Context hanya untuk data yang berkaitan dengan permintaan yang melewati proses dan API,
  bukan untuk melewatkan parameter opsional ke fungsi.
- Context yang sama dapat diteruskan ke fungsi yang berjalan dalam goroutine yang berbeda; Context aman untuk digunakan secara simultan oleh beberapa goroutine.

** Bacaan Tambahan

- [[https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html][Context Package Semantics In Go]] - William Kennedy
- [[https://golang.org/pkg/context][Package context]] - Go Team
- [[https://blog.golang.org/context][Go Concurrency Patterns: Context]] - Sameer Ajmani
- [[https://rakyll.org/leakingctx/][Using contexts to avoid leaking goroutines]] - JBD

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

Gunakan templat ini dan ikuti petunjuk. Anda akan menulis penangan web yang melakukan panggilan basis data tiruan
tetapi akan berakhir sesuai waktu berdasarkan context jika panggilan tersebut memakan waktu terlalu lama.
Anda juga akan menyimpan status ke dalam context.

.play context/exercise1.go
.play context/answer1.go
