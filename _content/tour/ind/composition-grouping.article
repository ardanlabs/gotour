Pengelompokan dengan Tipe Data
Penting untuk diingat bahwa dalam Go, konsep sub-typing atau sub-classing sebenarnya tidak ada,
dan pola desain ini seharusnya dihindari.

* Pengelompokan dengan Tipe Data

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Penting untuk diingat bahwa dalam Go, konsep sub-typing atau sub-classing sebenarnya tidak ada,
dan pola desain ini seharusnya dihindari.

** Ulasan Kode

- *Contoh 1:* Pengelompokan Berdasarkan Status
- *Contoh 2:* Pengelompokan Berdasarkan Perilaku

.play composition/grouping/example1.go
.play composition/grouping/example2.go

** Mengelompokkan Berbagai Jenis Data

Penting untuk diingat bahwa dalam Go, konsep sub-typing atau sub-classing sebenarnya tidak ada,
dan pola desain ini seharusnya dihindari.

Berikut adalah anti-pola yang seharusnya tidak diikuti atau diimplementasikan.

    type Animal struct {
        Name string
        IsMammal bool
    }

Tipe Animal dideklarasikan sebagai tipe dasar yang mencoba mendefinisikan data yang umum untuk semua hewan.
Anda juga mencoba memberikan beberapa perilaku umum untuk hewan.

    func (a *Animal) Speak() {
        fmt.Println("UGH!",
        "My name is", a.Name, ", it is", a.IsMammal, "I am a mammal")
    }

Sebagian besar hewan memiliki kemampuan berbicara dengan cara atau cara lain.
Namun, mencoba menerapkan perilaku umum ini hanya pada hewan tidak masuk akal.
Pada titik ini, Anda tidak tahu suara apa yang dihasilkan oleh hewan ini, sehingga Anda menuliskan UGH.

    type Dog struct {
        Animal
        PackFactor int
    }

Sekarang masalah yang sebenarnya dimulai. Saya mencoba menggunakan penyematan (embedding)
untuk membuat Dog memiliki semua yang dimiliki Animal dan lebih banyak lagi.
Pada awalnya, ini mungkin tampak berhasil, tetapi akan ada masalah.
Meskipun demikian, seekor anjing memiliki cara khusus dalam berbicara.

    func (d *Dog) Speak() {
        fmt.Println("Woof!",
            "My name is", d.Name,
            ", it is", d.IsMammal,
            "I am a mammal with a pack factor of", d.PackFactor)
    }

Dalam implementasi metode Speak, Anda dapat mengganti UGH dengan Woof.
Ini spesifik untuk cara berbicara anjing.

    type Cat struct {
        Animal
        ClimbFactor int
    }

Jika saya akan memiliki Dog yang mewakili Animal, maka Anda harus memiliki Cat.
Dengan menggunakan penyematan, Cat adalah segalanya yang dimiliki Animal dan lebih banyak lagi.

    func (c *Cat) Speak() {
        fmt.Println("Meow!",
            "My name is", c.Name,
            ", it is", c.IsMammal,
            "I am a mammal with a climb factor of", c.ClimbFactor)
    }

Dalam implementasi metode Speak, Anda dapat mengganti UGH dengan Meow.
Ini spesifik untuk cara berbicara kucing.

Semuanya tampak baik dan terlihat seperti penyematan (embedding)
seperti inheritance pada bahasa pemrograman lain. Kemudian Anda mencoba untuk
mengelompokkan anjing dan kucing berdasarkan fakta bahwa mereka memiliki DNA bersama sebagai Animal.

    animals := []Animal{
        Dog{
            Animal: Animal{
                Name: "Fido",
                IsMammal: true,
            },
            PackFactor: 5,
        },

        Cat{
            Animal: Animal{
                Name: "Milo",
                IsMammal: true,
            },
            ClimbFactor: 4,
        },
    }

    for _, animal := range animals {
        animal.Speak()
    }

Ketika Anda mencoba melakukan ini, kompilator mengeluh bahwa Dog dan Cat bukan Animal dan ini benar.
Embedding tidak sama dengan inheritance dan pola ini seharusnya dihindari. Sebuah Dog adalah Dog,
sebuah Cat adalah Cat, dan sebuah Animal adalah Animal. Anda tidak dapat meneruskan Dog dan Cat
seolah-olah mereka adalah Animal karena mereka bukanlah itu.

Mekanisme semacam ini juga tidak sangat fleksibel. Ini memerlukan konfigurasi oleh pengembang
dan kecuali Anda memiliki akses ke kode, Anda tidak dapat melakukan perubahan konfigurasi dari waktu ke waktu.

Jika ini bukan cara kita dapat membuat kumpulan Dog dan Cat, bagaimana kita bisa melakukannya di Go?
Ini bukan tentang pengelompokan melalui DNA yang umum, tetapi tentang pengelompokan melalui perilaku yang umum.
Perilaku adalah kunci.

    type Speaker interface {
        Speak()
    }

Jika Anda menggunakan interface, maka Anda dapat menentukan kumpulan metode perilaku umum
yang ingin Anda kelompokkan ke berbagai jenis data.

    speakers := []Speaker{
        &Dog{
            Animal: Animal{
                Name: "Fido",
                IsMammal: true,
            },
            PackFactor: 5,
        },
        &Cat{
            Animal: Animal{
                Name: "Milo",
                IsMammal: true,
            },
            ClimbFactor: 4,
        },
    }

    for _, speaker := range speakers {
        speaker.Speak()
    }

Dalam kode yang baru, Anda sekarang dapat mengelompokkan Dogs dan Cats bersama
berdasarkan kumpulan perilaku umum mereka, yaitu kenyataan bahwa Dogs dan Cats dapat berbicara.

Sebenarnya, tipe Animal adalah polusi tipe karena mendeklarasikan tipe
hanya untuk berbagi kumpulan keadaan umum adalah hal yang tidak baik dan seharusnya dihindari.

    type Dog struct {
        Name string
        IsMammal bool
        PackFactor int
    }

    type Cat struct {
        Name string
        IsMammal bool
        ClimbFactor int
    }

Dalam kasus ini, Anda lebih suka melihat tipe Animal dihapus dan attributnya disalin
dan ditempelkan ke dalam tipe Dog dan Cat. Nanti, Anda akan memiliki catatan tentang
pola yang lebih baik yang menghilangkan skenario semacam ini.

Berikut adalah beberapa masalah dalam kode sebelumnya:

- Tipe Animal menyediakan lapisan abstraksi dari keadaan yang dapat digunakan kembali.
- Program tidak pernah perlu membuat atau hanya menggunakan nilai tipe Animal.
- Implementasi metode Speak untuk tipe Animal bersifat umum.
- Metode Speak untuk tipe Animal tidak akan pernah dipanggil.

Pedoman seputar mendeklarasikan tipe:

- Deklarasikan tipe yang mewakili sesuatu yang baru atau unik.
- Jangan membuat alias hanya untuk kemudahan keterbacaan.
- Validasi bahwa sebuah nilai dari setiap tipe dibuat atau digunakan secara mandiri.
- Sematkan tipe bukan karena Anda memerlukan statusnya, tetapi karena Anda memerlukan perilaku.
- Jika Anda tidak memikirkan tentang perilaku, Anda mengunci diri dalam desain yang tidak dapat berkembang di masa depan tanpa perubahan kode yang bertahap.
- Pertanyakan tipe-tipe yang merupakan alias atau abstraksi dari tipe yang sudah ada.
- Pertanyakan tipe-tipe yang tujuannya hanya untuk berbagi kumpulan keadaan yang sama.

** Jangan Merancang Dengan Interfaces

Sayangnya, terlalu banyak pengembang mencoba memecahkan masalah secara abstrak terlebih dahulu.
Mereka langsung fokus pada interface dan hal ini mengakibatkan polusi interface. Sebagai seorang
pengembang, Anda berada dalam satu dari dua mode: seorang pembuat program dan kemudian seorang insinyur.

Ketika Anda sedang membuat program, Anda berfokus pada membuat potongan kode berfungsi. Mencoba
untuk memecahkan masalah dan meruntuhkan batasan. Membuktikan bahwa ide awal saya berfungsi. Itu
satu-satunya yang Anda pedulikan. Pemrograman ini seharusnya dilakukan secara konkret dan tidak pernah
siap produksi.

Setelah Anda memiliki prototipe kode yang dapat menjawab masalah, Anda perlu beralih ke
mode rekayasa. Anda perlu fokus pada cara menulis kode pada tingkat mikro untuk
semantik data dan keterbacaan, kemudian pada tingkat makro untuk model mental dan
kemudahan perawatan. Anda juga perlu fokus pada kesalahan dan keadaan kegagalan.

Pekerjaan ini dilakukan dalam siklus refaktor. Refaktor untuk keterbacaan, efisiensi,
abstraksi, dan untuk pengujian. Abstraksi hanya satu dari beberapa refaktor yang perlu
dilakukan. Ini berfungsi dengan baik saat Anda memulai dengan potongan kode konkret
dan kemudian MENEMUKAN interface yang diperlukan. Jangan menerapkan abstraksi kecuali
jika benar-benar diperlukan.

Setiap masalah yang Anda selesaikan dengan kode adalah masalah data yang memerlukan
saya untuk menulis transformasi data. Jika Anda tidak memahami data, Anda tidak memahami masalah.
Jika Anda tidak memahami masalah, Anda tidak dapat menulis kode. Memulai dengan solusi konkret
yang didasarkan pada struktur data konkret adalah kritis. Seperti yang dikatakan oleh Rob Pike,

"Data dominates. If you've chosen the right data structures and organized things
well, the algorithms will almost always be self-evident". - Rob Pike

Kapan abstraksi diperlukan? Ketika Anda melihat suatu tempat dalam kode di mana data
dapat berubah dan Anda ingin meminimalkan efek perubahan kode yang akan terjadi. Saya
mungkin menggunakan abstraksi untuk membantu membuat kode dapat diuji, tetapi Anda
seharusnya mencoba menghindari hal ini jika memungkinkan. Fungsi yang paling baik untuk diuji
adalah fungsi yang mengambil data mentah dan mengirimkan data mentah keluar.
Seharusnya tidak masalah dari mana data berasal atau kemana data tersebut pergi.

Pada akhirnya, mulailah dengan solusi konkret untuk setiap masalah. Bahkan jika sebagian besar
hanyalah pemrograman. Kemudian temukan interface yang benar-benar diperlukan
untuk kode saat ini.

"Donâ€™t design with interfaces, discover them". - Rob Pike
