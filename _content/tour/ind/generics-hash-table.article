Hash Tables
Sebuah Hash table adalah contoh klasik dari tipe kontainer data yang dapat sangat menguntungkan dari generic.

* Generics - Hash Tables

Sebuah Hash table adalah contoh klasik dari tipe kontainer data yang dapat sangat menguntungkan dari generic.
Implementasi ini dibuat oleh Matt Layher (@mdlayer) dalam sebuah tulisan blog yang ditulisnya.
Ini adalah contoh bagus dari apa yang mungkin dengan generic.

** Video

Tontonlah presentasi yang saya berikan tentang Generik yang
akan membimbing Anda melalui semua contoh dalam bagian ini dari Tur.

.html generics-video.html

** Ulasan Kode

- *Contoh* *1*: Hash Table

.play generics/hash-table/example1.go

** Penjelasan

Kode ini sedikit lebih kompleks daripada yang telah Anda lihat sejauh ini.
Ini adalah contoh dari apa yang dapat Anda harapkan dari implementasi dunia nyata.
Sepanjang bagian ini, Anda akan melihat dua tampilan kode, satu sebelum dan
satu setelah menerapkan sintaks baru untuk generic.

    type hashFunc func(key K, buckets int) int

Tipe ini mendeklarasikan signature fungsi hash yang digunakan oleh hash table untuk
menghitung posisi bucket untuk penyimpanan dan pengambilan data. Pengguna harus
mengimplementasikan dan menyediakan fungsi ini saat membuat hash table.
Fungsi ini menerima key dan jumlah bucket yang dapat dipilih.
Karena Anda ingin sistem ini menjadi generic dalam hal jenis yang digunakan untuk kunci dan nilai,
Anda mendeklarasikan parameter bernama key dengan tipe huruf besar tunggal K.

Selanjutnya, Anda membuat sintaks generic untuk membuat K menjadi tipe generic sebenarnya.

    type hashFunc[K comparable] func(key K, buckets int) int <-- CHANGED

Setelah nama tipe, tambahkan kurung siku dengan tipe generic K dan batasan comparable.
Karena nilai dari tipe key perlu digunakan dalam operasi pembandingan, mendokumentasikan
ini sekarang masuk akal, meskipun implementasi fungsi hash tidak memerlukannya.
Konsistensi adalah segalanya dalam hal keberbacaan, pemahaman, dan keberlanjutan dari waktu ke waktu.

Tipe ini mewakili pasangan data key/value yang akan disimpan oleh hash table.

    type keyValuePair struct {
        Key K
        Value V
    }

Tugas dari tipe ini adalah untuk menyimpan data sebenarnya dengan kunci yang sesuai.
Selanjutnya, kode mendeklarasikan atribut key dengan tipe K, dan atribut Value dengan tipe V.

Sekarang Anda dapat menerapkan sintaks generic untuk membuat K dan V menjadi tipe generic sebenarnya.

    type keyValuePair[K comparable, V any] struct { <-- CHANGED
        Key K
        Value V
    }

Setelah nama tipe, tambahkan kurung siku dengan tipe generic K dan V. Dalam deklarasi ini,
K mewakili key seperti sebelumnya, dan V mewakili value, yang dapat menjadi apa saja.

Tipe ini mewakili hash table yang mengelola fungsi hash dan seperangkat bucket
untuk penyimpanan data key/value.

    type Table struct {
        hashFunc hashFunc
        buckets int
        data [][]keyValuePair
    }

Tipe Table memiliki tiga atribut, sebuah fungsi hash, jumlah bucket, dan data yang direpresentasikan
sebagai potongan dari potongan pasangan key/value. Potongan luar mewakili bucket, dan potongan dalam
mewakili pasangan key/value yang disimpan di dalam sebuah bucket.

Sekarang terapkan sintaks generic untuk mendeklarasikan tipe generic Key dan Value,
dan terapkan pada deklarasi atribut.

    type Table[K comparable, V any] struct { <-- CHANGED
        hashFunc hashFunc[K] <-- CHANGED
        buckets int
        data [][]keyValuePair[K, V] <-- CHANGED
    }

Setelah nama tipe, tambahkan kurung siku dengan tipe generik K dan V. Deklarasi tipe hashFunc
memerlukan informasi tentang tipe konkret yang akan digunakan untuk Key. Deklarasi tipe keyValuePair
memerlukan informasi tentang tipe konkret untuk Key dan Value.

Ini adalah fungsi pabrik (factory function) yang dapat membuat Tabel untuk digunakan.

    func New(
        buckets int,
        hf hashFunc
    ) *Table {

        return &Table{
            hashFunc: hf,
            buckets: buckets,
            data: make([][]keyValuePair, buckets),
        }
    }

Fungsi pabrik menerima jumlah bucket yang akan dikelola dan fungsi hash untuk memilih bucket
untuk penyimpanan dan pencarian data. Ketika sebuah nilai Tabel dibuat, jumlah bucket digunakan
untuk membuat potongan, mengatur panjang potongan luar sesuai dengan jumlah bucket yang akan digunakan.

Sekarang terapkan sintaks generic untuk mendeklarasikan tipe generic Key dan Value,
dan terapkan pada tipe-tipe yang perlu dibuat.

    func New[K comparable, V any]( <-- CHANGED
        buckets int,
        hf hashFunc[K],            <-- CHANGED
    ) *Table[K, V] {               <-- CHANGED

        return &Table[K, V]{       <-- CHANGED
            hashFunc: hf,
            buckets: buckets,
            data: make([][]keyValuePair[K, V], buckets), <-- CHANGED
        }
    }

Setelah nama tipe, tambahkan kurung siku dan tipe generic K dan V. Kemudian, K diterapkan pada
parameter input hf untuk melengkapi deklarasi tipe hashFunc. Tipe K dan V diterapkan pada tipe Tabel
yang dibuat dan dikembalikan. Akhirnya, inisialisasi atribut data memerlukan penerapan K dan V pada
sintaks konstruksi tipe keyValuePair.

Ini adalah metode yang dapat memasukkan nilai ke dalam hash table berdasarkan tipe key yang ditentukan.

    type Table[K comparable, V any] struct {
        hashFunc hashFunc[K]
        buckets int
        table [][]keyValuePair[K, V]
    }

    func (t *Table) Insert(key K, value V) {
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.table[bucket] {
            if key == kvp.Key {
                t.table[bucket][idx].Value = value
                return
            }
        }

        kvp := keyValuePair{
            Key: key,
            Value: value,
        }
        t.table[bucket] = append(t.table[bucket], kvp)
    }

Metode Insert dideklarasikan untuk menerima key dan value dari jenis generic yang sama
yang dideklarasikan dengan tipe Tabel. Langkah pertama dari penyisipan adalah
mengidentifikasi bucket yang akan digunakan untuk penyimpanan. Ini dilakukan dengan memanggil
fungsi hash dengan key yang ditentukan. Fungsi hash mengembalikan nilai bilangan bulat
yang mewakili bucket yang akan digunakan.

Kemudian fungsi memeriksa apakah key yang ditentukan sudah digunakan untuk
menyimpan nilai di bucket yang dipilih. Ini dilakukan dengan melakukan iterasi
pada set yang terdapat dari pasangan key/value di dalam bucket. Jika key sudah ada,
value untuk kunci tersebut diperbarui. Jika key tidak ditemukan, maka nilai pasangan
key/value yang baru dibuat, diinisialisasi, dan ditambahkan ke bucket yang dipilih.

Sekarang terapkan sintaks generic untuk mendeklarasikan tipe generic key dan value,
dan terapkan pada tipe-tipe yang perlu dibuat.

    func (t *Table[K, V]) Insert(key K, value V) { <-- CHANGED
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.table[bucket] {
            if key == kvp.Key {
                t.table[bucket][idx].Value = value
                return
            }
        }

        kvp := keyValuePair[K, V]{                 <-- CHANGED
            Key: key,
            Value: value,
        }
        t.table[bucket] = append(t.table[bucket], kvp)
    }

Setelah nama tipe di receiver, tambahkan kurung siku dan tipe generic K dan V.
Satu-satunya perubahan lain adalah menerapkan K dan V pada sintaks konstruksi tipe keyValuePair.

Ini adalah metode yang dapat mengambil nilai dari hash table berdasarkan key yang ditentukan.

    func (t *Table) Retrieve(key K) (V, bool) {
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.data[bucket] {
            if key == kvp.Key {
                return t.data[bucket][idx].Value, true
            }
        }

        var zero V
        return zero, false
    }

Metode Retrieve dideklarasikan untuk menerima key dan mengembalikan salinan value
yang disimpan untuk key tersebut. Langkah pertama dari pengambilan adalah mengidentifikasi
bucket yang digunakan untuk penyimpanan. Ini dilakukan dengan memanggil fungsi hash
dengan key yang ditentukan. Fungsi hash mengembalikan nilai bilangan bulat
yang mewakili bucket yang akan dilihat.

Kemudian fungsi melakukan iterasi pada kumpulan pasangan key/value yang disimpan di dalam bucket,
mencari key yang ditentukan satu per satu. Jika key ditemukan, salinan nilai dikembalikan dan
true diberikan kepada pemanggil. Jika key tidak ditemukan, nilai nol dikembalikan
dan false diberikan kepada pemanggil.

Sekarang terapkan sintaks generic untuk mendeklarasikan tipe generic key dan value,
dan terapkan pada tipe-tipe yang perlu dibuat.

    func (t *Table[K, V]) Get(key K) (V, bool) { <-- CHANGED
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.data[bucket] {
            if key == kvp.Key {
                return t.data[bucket][idx].Value, true
            }
        }

        var zero V
        return zero, false
    }

Setelah nama tipe di receiver, tambahkan kurung siku dan tipe generic K dan V.
Tidak ada perubahan kode lain yang diperlukan.

Ini adalah program kecil untuk menguji implementasi hash table.

    func main() {
        const buckets = 8
        . . .
    }

Mulailah dengan sebuah konstanta yang mendefinisikan jumlah bucket yang akan digunakan dalam hash table.

    import (
        "hash/fnv"
    )

    func main() {
        . . .

        hashFunc1 := func(key string, buckets int) int {
            h := fnv.New32()
            h.Write([]byte(key))
            return int(h.Sum32()) % buckets
        }

        . . .
    }

Selanjutnya, deklarasikan sebuah fungsi hash yang mendeklarasikan sebuah string untuk key.
Implementasi menggunakan paket fnv dari pustaka standar yang mengimplementasikan fungsi
hash non-kriptografis FNV-1 dan FNV-1a yang dibuat oleh Glenn Fowler, Landon Curt Noll, dan Phong Vo.
FNV adalah singkatan dari fungsi hash Fowler-Noll-Vo.

Operasi modulus dengan nilai buckets memaksa nilai akhir jatuh dalam rentang jumlah bucket.

    import (
        "hash/fnv"
    )

    func main() {
        . . .

        table1 := New[/*key*/ string, /*value*/ int](buckets, hashFunc1)

        . . .
    }

Selanjutnya, buat sebuah hash table, dengan menyatakan secara eksplisit bahwa key akan
memiliki tipe string dan value tipe int. Tidak ada dalam parameter masukan yang dapat
membantu kompilator menyimpulkan informasi ini.

Untuk menunjukkan sifat generic dari hash table, definisikan fungsi hash dan tabel kedua.

    import (
        "hash/fnv"
    )

    func main() {
        . . .

        hashFunc2 := func(key int, buckets int) int {
            return key % buckets
        }

        table2 := New[/*key*/ int, /*value*/ string](buckets, hashFunc2)

        . . .
    }

Fungsi hash ini mendeklarasikan sebuah integer untuk key dan melakukan operasi modulus
sederhana dengan nilai bucket terhadap key. Kemudian, sebuah tabel baru dibuat di mana key
dijelaskan sebagai integer dan nilai sebagai string. Kebalikan dari tabel pertama.


    import (
        "hash/fnv"
    )

    func main() {
        . . .

        words := []string{"foo", "bar", "baz"}
        for i, word := range words {
            table1.Insert(word, i)
            table2.Insert(i, word)
        }

        for i, s := range append(words, "nope!") {
            v1, ok1 := table1.Retrieve(s)
            fmt.Printf("t1.Rtr(%v) = (%v, %v)\n", s, v1, ok1)

            v2, ok2 := table2.Retrieve(i)
            fmt.Printf("t2.Rtr(%v) = (%v, %v)\n", i, v2, ok2)
        }
    }

Keluaran:

    t1.Rtr(foo) = (0, true)
    t2.Rtr(0) = (foo, true)
    t1.Rtr(bar) = (1, true)
    t2.Rtr(1) = (bar, true)
    t1.Rtr(baz) = (2, true)
    t2.Rtr(2) = (baz, true)
    t1.Rtr(nope!) = (0, false)
    t2.Rtr(3) = (, false)

Akhirnya, tulis beberapa kode untuk menyimpan dan mengambil nilai dari dua tabel yang berbeda.
