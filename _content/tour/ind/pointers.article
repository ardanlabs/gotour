Tipe Data Pointer
Pointer memiliki tujuan untuk berbagi nilai di seluruh batasan program.

* Tipe Data Pointer

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Tonton Video]]
- Perlu bantuan finansial, Isi [[https://www.ardanlabs.com/scholarship/][Formulir Beasiswa]]

Pointer memiliki tujuan untuk berbagi nilai melintasi batas-batas program.
Ada beberapa jenis batasan program. Yang paling umum adalah antara pemanggilan fungsi.
Ada juga batasan antara Goroutines yang akan dipelajari lebih lanjut nanti.

** Ulasan Kode

- *Contoh* *1:* Pemberian Nilai
- *Contoh* *2:* Berbagi Nilai I
- *Contoh* *3:* Berbagi Nilai II
- *Contoh* *4:* Escape Analysis
- *Contoh* *5:* Pertumbuhan Stack

.play pointers/example1.go
.play pointers/example2.go
.play pointers/example3.go
.play pointers/example4.go
.play pointers/example5.go

Ketika program Go dimulai, Go runtime membuat sebuah Goroutine.
Goroutine adalah sebuah unit pemrosesan tingkat aplikasi yang ringan dengan banyak kesamaan
yang sama seperti unit pemrosesan pada sistem operasi. Tugas mereka adalah untuk mengelola eksekusi fisik
dari satu set instruksi yang berbeda. Setiap program Go memiliki setidaknya 1 Goroutine yang disebut Goroutine utama.

Setiap Goroutine diberikan blok memori sendiri yang disebut stack.
Setiap stack dimulai dengan alokasi sebesar 2048 byte (2k).
Meskipun ukurannya sangat kecil, tumpukan dapat tumbuh seiring berjalannya waktu.

.image /tour/ind/static/img/p1.png

Setiap kali sebuah fungsi dipanggil, sebagian blok dari stack diambil untuk membantu Goroutine
menjalankan instruksi yang terkait dengan fungsi tersebut. Setiap blok memori individual disebut sebagai frame.

Ukuran frame untuk suatu fungsi tertentu dihitung pada saat kompilasi.
Tidak ada nilai yang dapat dibangun di atas tumpukan kecuali kompiler mengetahui
ukuran nilai tersebut pada saat kompilasi. Jika kompiler tidak mengetahui ukuran suatu nilai pada saat kompilasi,
nilai tersebut harus dibangun di atas heap.

Setiap kali Anda melakukan panggilan fungsi, dan suatu frame memori dialokasikan,
memori untuk frame tersebut diinisialisasi, itulah cara stack membersihkan dirinya sendiri.
Pada saat fungsi mengembalikan nilai, memori untuk frame dibiarkan begitu saja karena tidak diketahui
apakah memori tersebut akan dibutuhkan lagi. Akan tidak efisien untuk menginisialisasi memori saat pengembalian.

*Pemberian* *dengan* *Nilai*

Semua data berpindah di sepanjang program dengan nilai.
Ini berarti saat data dilewatkan melintasi batasan program,
setiap fungsi atau Goroutine diberikan salinan tersendiri dari data tersebut.
Ada dua tipe data yang akan Anda kerjakan, nilai itu sendiri (tipe data int,
string, user) atau alamat dari nilai tersebut. Alamat adalah data yang perlu disalin
dan disimpan melintasi batas-batas program.

Kode berikut mencoba menjelaskan hal diatas lebih lanjut.

    func main() {

        // Deklarasikan variabel bertipe int dengan nilai 10.
        count := 10

        // Untuk mendapatkan alamat suatu nilai, gunakan operator &.
        println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

        // Berikan salinan dari nilai yang terkandung dalam variable `count` (apa yang ada di dalam kotak)
        // ke fungsi inkremen1.
        increment1(count)

        // Cetak "nilai" dan "alamat" dari variabel count.
        // Nilai dari variabel count tidak akan berubah setelah pemanggilan fungsi.
        println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

        // Berikan salinan "alamat" dari variabel count (tempat kotaknya)
        // ke fungsi inkremen2. Ini masih dianggap pemberian dengan nilai
        // dan bukan pemberian referensi karena alamat adalah nilai.
        increment2(&count)

        // Cetak "nilai" dan "alamat" dari variabel count.
        // Nilai variabel count telah berubah setelah pemanggilan fungsi.
        println(
            "count:\tValue Of[",
            count, "]\tAddr Of[", &count, "]")
    }

    // increment1 mendeklarasikan fungsi untuk menerima salinan sendiri dari
    // nilai integer.
    func increment1(inc int) {

        // Menambah salinan lokal dari nilai int pemanggil.
        inc++
        println("inc1:\tValue Of[", inc, "]\tAddr Of[", &inc, "]")
    }

    // increment2 mendeklarasikan fungsi untuk menerima salinan sendiri dari
    // alamat yang menunjuk ke nilai integer.
    // Variabel pointer adalah tipe literal dan dideklarasikan menggunakan *.
    func increment2(inc *int) {

        // Menambah nilai int pemanggil melalui pointer.
        *inc++
        println(
            "inc2:\tValue Of[",
            inc, "]\tAddr Of[", &inc,
            "]\tPoints To[", *inc, "]")
    }

Keluaran:

    count:  Value Of[ 10 ]  Addr Of[ 0xc000050738 ]
    inc1:   Value Of[ 11 ]  Addr Of[ 0xc000050730 ]
    count:  Value Of[ 10 ]  Addr Of[ 0xc000050738 ]
    inc2:   Value Of[ 0xc000050738 ] Addr Of[ 0xc000050748 ] Points To[ 11 ]
    count:  Value Of[ 11 ]  Addr Of[ 0xc000050738 ]

** Catatan

- Gunakan pointer untuk berbagi data.
- Nilai dalam Go selalu dilewatkan dengan nilai.
- "Nilai" adalah apa yang ada di dalam kotak. "Alamat" ( & ), adalah dimana dimana kotak berada dalam memori.
- Operator ( * ) mendeklarasikan variabel penunjuk (pointer) dan "Nilai yang ditunjuk oleh penunjuk".

** Escape Analysis

Algoritma yang digunakan oleh kompilator (compiler) untuk menentukan apakah sebuah nilai
harus dibuat di dalam stack atau heap disebut "escape analysis".
Nama algoritma ini membuatnya terdengar seperti nilai-nilai dibuat di dalam stack terlebih dahulu,
lalu "melarikan diri" (atau dipindahkan) ke heap ketika diperlukan.
Tapi tidak demikian. Konstruksi nilai hanya terjadi sekali, dan algoritma "escape analysis" menentukan
di mana itu akan terjadi (stack atau heap). Hanya konstruksi di heap yang disebut sebagai "allocation" (alokasi) dalam Go.


Memahami "escape analysis" adalah tentang memahami kepemilikan nilai.
Ide nya adalah ketika sebuah nilai dibuat dalam cakupan sebuah fungsi,
maka fungsi tersebut yang memiliki nilai tersebut. Dari situ, pertanyaannya adalah,
apakah nilai yang sedang dibuat masih harus ada ketika fungsi yang memiliki nilai tersebut mengembalikan nilainya?
Jika jawabannya adalah tidak, maka nilai tersebut dapat dibuat di dalam stack.
Jika jawabannya adalah ya, maka nilai tersebut harus disimpan di dalam heap.

Catatan: Aturan kepemilikan adalah aturan dasar yang baik untuk mengidentifikasi kode yang menyebabkan alokasi.
Namun, Anda harus mengetahui bahwa escape analysis memiliki kekurangan yang dapat menghasilkan alokasi yang tidak jelas.
Selain itu, algoritma ini memanfaatkan peluang untuk memanfaatkan optimisasi kompiler guna menghemat alokasi.

    // variabel user mewakili pengguna dalam suatu sistem
    type user struct {
        name  string
        email string
    }

    func stayOnStack() user {
        u := user{
            name:  "Bill",
            email: "bill@email.com",
        }

        return u
    }


Fungsi stayOnStack menggunakan semantik nilai untuk mengembalikan nilai user kembali ke pemanggil.
Dengan kata lain, pemanggil mendapatkan salinan sendiri dari nilai pengguna yang sedang dibuat.

Ketika fungsi stayOnStack dipanggil dan mengembalikan nilai, nilai user yang dibangun di dalamnya tidak perlu ada lagi,
karena pemanggil mendapatkan salinan sendiri. Oleh karena itu,
konstruksi nilai pengguna di dalam stayOnStack dapat terjadi di dalam stack.
Tidak ada alokasi

    type user struct {
        name  string
        email string
    }

    func escapeToHeap() *user {
        u := user{
            name:  "Bill",
            email: "bill@email.com",
        }

        return &u
    }

Fungsi escapeToHeap menggunakan semantik nilai bertipe pointer untuk mengembalikan nilai user kepada pemanggil.
Dengan kata lain, pemanggil mendapatkan akses bersama (sebuah alamat) ke nilai pengguna yang sedang dibuat.

Ketika fungsi escapeToHeap dipanggil dan mengembalikan nilai, nilai pengguna yang dibuat olehnya
memang masih perlu ada, karena pemanggil mendapatkan akses bersama ke nilai tersebut.
Oleh karena itu, konstruksi nilai user di dalam escapeToHeap tidak dapat terjadi di dalam stack,
melainkan harus terjadi di dalam heap. Ini mengakibatkan alokasi.

Pikirkan apa yang akan terjadi jika nilai user dalam contoh terakhir dibangun di dalam stack
ketika menggunakan semantik pointer pada pengembalian.

.image /tour/ind/static/img/p2.png

Pemanggil akan mendapatkan salinan alamat stack dari frame di bawahnya dan integritas akan hilang.
Begitu kendali kembali ke fungsi pemanggil, memori di stack di mana nilai user ada dapat digunakan kembali.
Saat fungsi pemanggil membuat panggilan fungsi lain, frame baru dibuat dan memori akan ditimpa,
menghapus nilai bersama.

Ini sebabnya Anda memikirkan stack sebagai sesuatu yang membersihkan dirinya sendiri.
Inisialisasi nilai nol membantu membersihkan setiap frame stack yang Anda butuhkan tanpa menggunakan GC (Garbage Collection).
Stack membersihkan dirinya sendiri karena satu frame diambil dan diinisialisasi untuk eksekusi setiap panggilan fungsi.
Stack dibersihkan selama panggilan fungsi dan bukan pada saat pengembalian,
karena kompiler tidak tahu apakah memori di stack akan dibutuhkan lagi.

Escape analysis menentukan apakah sebuah nilai dibuat di dalam stack (nilai default)
atau di dalam heap (nilai yang melarikan diri). Dengan fungsi stayOnStack, saya mengembalikan salinan nilai ke pemanggil,
jadi aman untuk menyimpan nilai tersebut di dalam stack.
Dengan fungsi escapeToHeap, saya mengembalikan salinan alamat nilai ke pemanggil (berbagi melalui stack),
jadi tidak aman untuk menyimpan nilai tersebut di dalam stack.

Ada banyak detail kecil yang terkait dengan escape analysis, jadi untuk mempelajari lebih lanjut,
bacalah bacaan dalam bab 14 yang berjudul "Escape Analysis Mechanics".

Catatan: Mulai dari versi 1.17, Go mengubah ABI (application binary interface) untuk menerapkan
cara baru dalam melewatkan argumen masukan dan keluaran fungsi dengan menggunakan register daripada memori di stack.
Ini bisa digunakan untuk Linux, MacOS, dan Windows pada arsitektur x86 64-bit.
Ini berarti beberapa argumen fungsi tidak akan disalin di stack,
tetapi beberapa mungkin tergantung pada kelayakan penggunaan register.
Ini tidak mengubah semantik yang dijelaskan dalam bab ini.

** Catatan

- Ketika suatu nilai dapat direferensikan setelah fungsi yang membangun nilai tersebut mengembalikan nilai.
- Ketika kompilator menentukan bahwa sebuah nilai terlalu besar untuk muat di dalam stack.
- Ketika kompilator tidak mengetahui ukuran sebuah nilai pada saat kompilasi.
- Ketika sebuah nilai diuraikan melalui penggunaan fungsi atau nilai antarmuka.

** Garbage Collection Semantics

Setelah sebuah nilai dibangun di dalam heap, Garbage Collector (GC) harus terlibat.
Bagian terpenting dari GC adalah algoritma pemacuannya. Ini menentukan frekuensi/laju
di mana GC harus berjalan untuk menjaga ukuran heap yang paling kecil seiring dengan throughput aplikasi yang terbaik.

- [[https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html][Garbage Collection Semantics Part I]] - William Kennedy

** Stack vs Heap

"The stack is for data that needs to persist only for the lifetime of the function
that constructs it, and is reclaimed without any cost when the function exits. The
heap is for data that needs to persist after the function that constructs it exits,
and is reclaimed by a sometimes costly garbage collection." - Ayan George

** Pertumbuhan Stack

Ukuran setiap frame untuk setiap fungsi dihitung pada waktu kompilasi.
Ini berarti jika kompilator tidak mengetahui ukuran sebuah nilai pada waktu kompilasi,
nilai tersebut harus dibangun di dalam heap.
Contoh dari hal ini adalah penggunaan fungsi bawaan "make" untuk membuat sebuah slice
yang ukurannya bergantung pada sebuah variabel.

    b := make([]byte, size) // Backing array allocates on the heap.

Go menggunakan implementasi stack yang berkelanjutan untuk menentukan bagaimana stack tumbuh dan menyusut.
Salah satu alternatif yang bisa digunakan oleh Go adalah implementasi stack yang tersegmentasi,
yang digunakan oleh beberapa sistem operasi.

Setiap panggilan fungsi dilengkapi dengan sebuah perkenalan kecil yang bertanya,
"Apakah ada cukup ruang di stack untuk frame baru ini?". Jika ya, maka tidak ada masalah,
dan frame tersebut diambil dan diinisialisasi.
Jika tidak, maka sebuah stack yang lebih besar harus dibangun,
dan memori di stack yang ada harus disalin ke yang baru.
Ini memerlukan perubahan pada pointer yang merujuk ke memori di stack.
Keuntungan dari memori yang berkelanjutan dan penelusuran linear dengan perangkat keras modern
adalah pengorbanan untuk biaya penyalinan.

Karena penggunaan stack yang berkelanjutan, tidak ada Goroutine yang dapat memiliki pointer ke stack Goroutine lain.
Hal ini akan menghasilkan overhead yang terlalu besar bagi runtime
untuk melacak setiap pointer ke setiap stack dan menyesuaikan kembali pointer tersebut ke lokasi baru.

** Bacaan Tambahan

**Mekanisme* *Pointer*

- [[https://golang.org/doc/effective_go.html#pointers_vs_values][Pointers vs. Values]]
- [[https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html][Language Mechanics On Stacks And Pointers]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2014/12/using-pointers-in-go.html][Using Pointers In Go]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2013/07/understanding-pointers-and-memory.html][Understanding Pointers and Memory Allocation]] - William Kennedy

*Stacks*

- [[https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub][Contiguous Stack Proposal]]

*Escape* *Analysis* *and* *Inlining*

- [[https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw][Go Escape Analysis Flaws]]
- [[https://github.com/golang/go/wiki/CompilerOptimizations][Compiler Optimizations]]

*Garbage* *Collection*

- [[http://gchandbook.org/][The Garbage Collection Handbook]]
- [[https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md][GC Pacer Redesign - 2021]] - Michael Knyszek
- [[https://en.wikipedia.org/wiki/Tracing_garbage_collection][Tracing Garbage Collection]]
- [[https://blog.golang.org/go15gc][Go Blog - 1.5 GC]]
- [[https://www.youtube.com/watch?v=aiv1JOfMjm0&index=16&list=PL2ntRZ1ySWBf-_z-gHCOR2N156Nw930Hm][Go GC: Solving the Latency Problem]]
- [[http://rubinius.com/2013/06/22/concurrent-garbage-collection][Concurrent garbage collection]]
- [[https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit][Go 1.5 concurrent garbage collector pacing]]
- [[https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md][Eliminating Stack Re-Scanning]]
- [[https://groups.google.com/forum/m/#!topic/golang-nuts/KJiyv2mV2pU][Why golang garbage-collector not implement Generational and Compact gc?]] - Ian Lance Taylor
- [[https://blog.golang.org/ismmkeynote][Getting to Go: The Journey of Go's Garbage Collector]] - Rick Hudson
- [[https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html][Garbage Collection In Go : Part I - Semantics]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html][Garbage Collection In Go : Part II - GC Traces]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html][Garbage Collection In Go : Part III - GC Pacing]] - William Kennedy
- [[https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/][Go memory ballast: How I learnt to stop worrying and love the heap]] - Ross Engers

*Static* *Single* *Assignment* *Optimizations*

- [[https://www.youtube.com/watch?v=D2-gaMvWfQY][GopherCon 2015: Ben Johnson - Static Code Analysis Using SSA]]
- [[https://godoc.org/golang.org/x/tools/go/ssa][Package SSA]]
- [[https://www.youtube.com/watch?v=FnGCDLhaxKU][Understanding Compiler Optimization]]

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

*Bagian* *A:* Mendeklarasikan dan menginisialisasi variabel bertipe int dengan nilai 20.
Menampilkan "alamat dari" (address of) dan "nilai dari" (value of) variabel tersebut.

*Bagian* *B:* Deklarasikan sebuah variabel baru dengan tipe float32 dan inisialisasikan variabel tersebut
Mendeklarasikan dan menginisialisasi variabel pointer bertipe int yang menunjuk ke variabel terakhir yang baru saja
Anda buat. Menampilkan "alamat dari" (address of), "nilai dari" (value of),
dan "nilai yang ditunjuk oleh pointer" (value that the pointer points to).

** Latihan 2

Deklarasikan tipe data struct dan buatlah sebuah nilai dari tipe data tersebut.
Deklarasikan sebuah fungsi yang dapat mengubah nilai dari salah satu atribut dalam tipe data struct ini.
Tampilkan nilai sebelum dan setelah panggilan ke fungsi tersebut.

.play pointers/exercise1.go
.play pointers/answer1.go
.play pointers/exercise2.go
.play pointers/answer2.go
