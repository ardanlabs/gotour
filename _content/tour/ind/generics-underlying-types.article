Underlying Types
Anda dapat mendeklarasikan tipe generic menggunakan tipe yang mendasarinya.

* Generics - Underlying Types

Anda dapat mendeklarasikan tipe generic menggunakan tipe yang mendasarinya.

** Video

Tontonlah presentasi yang saya berikan tentang Generik yang
akan membimbing Anda melalui semua contoh dalam bagian ini dari Tur.

.html generics-video.html

** Ulasan Kode

- *Contoh* *1*: Tipe konkret vector
- *Contoh* *2*: Tipe interface vector
- *Contoh* *3*: Tipe vector generic

.play generics/underlying-types/example1.go
.play generics/underlying-types/example2.go
.play generics/underlying-types/example3.go

** Penjelasan

Bagaimana jika Anda ingin mendeklarasikan tipe generic sendiri
menggunakan tipe yang mendasarinya?

    type vector[T any] []T

    func (v vector[T]) last() (T, error) {
        var zero T

        if len(v) == 0 {
            return zero, errors.New("empty")
        }

        return v[len(v)-1], nil
    }

Contoh ini menunjukkan tipe vector generic yang membatasi konstruksi vector
ke satu jenis data. Penggunaan kurung siku mendeklarasikan bahwa tipe T adalah tipe
generic yang akan ditentukan pada saat kompilasi. Penggunaan batasan "any" menjelaskan
bahwa tidak ada batasan pada apa yang dapat menjadi tipe T.

Metode terakhir dideklarasikan dengan penerima nilai dari tipe vector[T] untuk mewakili
sebuah nilai tipe vector dengan slice sebagai nilai yang mendasari dari tipe T.
Metode mengembalikan sebuah nilai dari tipe T yang sama.

    func main() {
        fmt.Print("vector[int] : ")

        vGenInt := vector[int]{10, -1}

        i, err := vGenInt.last()
        if err != nil {
            fmt.Print("ERROR:", err)
            return
        }

        if i < 0 {
            fmt.Print("negative integer: ")
        }

        fmt.Printf("value: %d\n", i)

        // -------------------------------------------------------------------------

        fmt.Print("vector[string] : ")

        vGenStr := vector[string]{"A", "B", string([]byte{0xff})}

        s, err := vGenStr.last()
        if err != nil {
            fmt.Print("ERROR:", err)
            return
        }

        if !utf8.ValidString(s) {
            fmt.Print("non-valid string: ")
        }

        fmt.Printf("value: %q\n", s)
    }

Keluaran:

    vector[int] : negative integer: value: -1
    vector[string] : non-valid string: value: "\xff"

Inilah cara untuk membuat sebuah nilai tipe vector dengan tipe dasar int ketika saya
akan mengatur nilai-nilai di dalam vector saat pembuatan. Aspek penting dari kode ini adalah
pemanggilan konstruksi.

    // Zero Value Construction
    var vGenInt vector[int]
    var vGenStr vector[string]

    // Non-Zero Value Construction
    vGenInt := vector{10, -1}
    vGenStr := vector{"A", "B", string([]byte{0xff})}

Ketika saat membuat tipe generic ini menjadi nilai nol mereka, tidak
mungkin bagi kompilator untuk menyimpulkan tipe. Namun, dalam kasus di mana ada
inisialisasi selama konstruksi, kompilator dapat menyimpulkan tipenya.

Ada aspek dari spesifikasi yang berfokus pada konstruksi tipe generic menjadi nilai nolnya.

    type vector[T any] []T

    func (v vector[T]) last() (T, error) {
        var zero T

        if len(v) == 0 {
            return zero, errors.New("empty")
        }

        return v[len(v)-1], nil
    }

Anda perlu fokus pada deklarasi metode untuk metode terakhir dan bagaimana metode
mengembalikan nilai dari tipe generic T. Pada pengembalian pertama adalah situasi di mana Anda perlu
mengembalikan nilai nol untuk tipe T. Implementasi saat ini memberikan dua solusi untuk menulis
kode ini. Solusi pertama yang sudah Anda lihat. Sebuah variabel bernama zero dibuat menjadi
keadaan nilai nolnya dari tipe T dan kemudian variabel tersebut digunakan untuk pengembalian.

Pilihan lainnya adalah menggunakan fungsi bawaan new dan mendereferensikan pointer yang dikembalikan
dalam pernyataan pengembalian.

    type vector[T any] []T

    func (v vector[T]) last() (T, error) {
        if len(v) == 0 {
            return *new(T), errors.New("empty")
        }

        return v[len(v)-1], nil
    }

Versi dari metode terakhir ini menggunakan fungsi bawaan new untuk konstruksi nilai nol
dan mendereferensikan pointer yang dikembalikan untuk memenuhi tipe kembalian T.

Catatan: Anda mungkin berpikir mengapa tidak menggunakan T{} untuk melakukan konstruksi nilai nol?
Masalahnya adalah sintaks ini tidak berfungsi dengan semua tipe, seperti tipe skalar (int,
string, bool). Jadi itu bukanlah pilihan.

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

Deklarasikan tipe generic bernama keymap yang menggunakan tipe dasar dari map
dengan key tipe string dan value dari beberapa tipe T. Deklarasikan metode
dengan nama set yang menerima key tipe string dan value tipe T. Deklarasikan
metode dengan nama get yang menerima key tipe string dan mengembalikan value
tipe T dan true atau false jika key ditemukan. Lalu tulis sebuah fungsi main
yang menggunakan metode-metode tersebut.

.play generics/underlying-types/exercise1.go
.play generics/underlying-types/answer1.go
