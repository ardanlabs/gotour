Goroutines
Goroutines adalah fungsi-fungsi yang dibuat dan dijadwalkan untuk dijalankan secara independen oleh suatu sistem penjadwalan di Go.

* Goroutines

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Watch The Video]]
- Need Financial Assistance, Use Our [[https://www.ardanlabs.com/scholarship/][Scholarship Form]]

Goroutines adalah fungsi-fungsi yang dibuat dan dijadwalkan untuk dijalankan secara independen oleh sistem penjadwalan di Go.
Penjadwal Go bertanggung jawab atas pengelolaan dan eksekusi goroutines

** Ulasan Kode

- *Contoh* *1:* Goroutine dan Konkurensi
- *Contoh* *2:* Peralihan konteks goroutine
- *Contoh* *3:* Goroutine dan Paralelisme

.play goroutines/example1.go
.play goroutines/example2.go
.play goroutines/example3.go

** Semantik Sistem Penjadwalan

Ketika program Go dimulai, runtime Go menanyakan kepada mesin (virtual atau fisik)
berapa banyak thread sistem operasi yang dapat berjalan secara paralel.
Hal ini didasarkan pada jumlah inti (core) yang tersedia untuk program.
Untuk setiap thread yang dapat berjalan secara paralel, runtime membuat sebuah thread sistem operasi (M)
dan mengaitkannya ke struktur data yang mewakili prosesor logis (P) di dalam program.
P dan M ini mewakili daya komputasi atau konteks eksekusi untuk menjalankan program Go.

Selain itu, sebuah Goroutine awal (G) dibuat untuk mengelola eksekusi instruksi pada M atau P yang dipilih.
Sama seperti M yang mengelola eksekusi instruksi pada perangkat keras, G mengelola eksekusi instruksi pada M.
Hal ini menciptakan lapisan abstraksi baru di atas sistem operasi, tetapi memindahkan kendali eksekusi
ke tingkat aplikasi.

.image /tour/ind/static/img/gor1.png

Karena sistem penjadwalan Go berada di atas sistem penjadwalan sistem operasi,
penting untuk memiliki pemahaman semantik tentang penjadwal sistem operasi dan
batasan-batasan yang diterapkannya pada penjadwal Go dan aplikasi.

Sistem penjadwalan pada sistem operasi memiliki tugas menciptakan ilusi bahwa
beberapa bagian pekerjaan sedang dieksekusi secara bersamaan. Walaupun secara fisik tidak mungkin.
Ini memerlukan beberapa kompromi dalam desain sistem penjadwalan. Sebelum saya melangkah lebih jauh,
penting untuk mendefinisikan beberapa kata.

*Work*: Seperangkat instruksi yang akan dieksekusi untuk aplikasi yang sedang berjalan.
Ini dilakukan melalui thread, dan sebuah aplikasi dapat memiliki 1 hingga banyak thread.

*Thread*: Sebuah jalur eksekusi yang dijadwalkan dan dijalanjan.
Thread bertanggung jawab atas eksekusi instruksi pada perangkat keras.

*Thread* *States*: Sebuah thread dapat berada dalam satu dari tiga status:
Running, Runnable, atau Waiting. Running berarti thread sedang mengeksekusi instruksi
yang telah ditugaskan pada perangkat keras dengan memiliki G yang ditempatkan pada M.
Runnable berarti thread ingin waktu pada perangkat keras untuk mengeksekusi instruksi
yang telah ditugaskan dan sedang menunggu di antrian pelaksanaan. Waiting berarti thread
sedang menunggu sesuatu sebelum dapat melanjutkan pekerjaannya. Thread yang sedang menunggu
bukan menjadi perhatian dari penjadwal.

*Konkurensi (Concurrency)*: Ini berarti eksekusi yang tidak terdefinisi dan tidak berurutan. Dengan kata lain,
diberikan seperangkat instruksi yang akan dieksekusi sesuai urutan yang diberikan,
instruksi tersebut dieksekusi dalam urutan yang berbeda dan tidak terdefinisi, tetapi semuanya dieksekusi.
Kuncinya adalah, hasil dari mengeksekusi seluruh set instruksi dalam urutan yang tidak terdefinisi
menghasilkan hasil yang sama. Anda akan mengatakan pekerjaan dapat dilakukan secara bersamaan ketika
urutan eksekusi pekerjaan tidak penting, selama semua pekerjaan diselesaikan.

*Parallelism:*: Ini berarti melakukan banyak hal sekaligus. Agar ini menjadi pilihan,
Anda perlu kemampuan untuk secara fisik menjalankan dua atau lebih thread sistem operasi
pada saat yang bersamaan pada perangkat keras.

*CPU* *Bound* *Work:* Ini adalah pekerjaan yang tidak menyebabkan thread secara alami beralih ke status menunggu.
Menghitung angka Fibonacci akan dianggap sebagai CPU-Bound Work.

*I/O* *Bound* *Work:* Ini adalah pekerjaan yang menyebabkan thread secara alami beralih ke status menunggu.
Mengambil data dari berbagai URL akan dianggap sebagai pekerjaan I/O-Bound.

*Synchronization:* Ketika dua atau lebih Goroutine perlu mengakses lokasi memori yang sama
pada saat yang mungkin bersamaan, mereka perlu disinkronkan dan bergantian.
Jika sinkronisasi ini tidak terjadi, dan setidaknya satu Goroutine melakukan penulisan,
dan Anda akan menghadapi kondisi data race. Data race adalah penyebab bug korupsi data yang sulit ditemukan.

*Orkestrasi (Orchestration):* Ketika dua atau lebih Goroutine perlu memberi sinyal satu sama lain,
dengan atau tanpa data, orkestrasi adalah mekanisme yang diperlukan. Jika orkestrasi tidak terjadi,
jaminan pekerjaan konkuren yang dilakukan dan diselesaikan akan terlewat. Ini dapat menyebabkan
berbagai jenis bug korupsi data.

Ada banyak detail kecil terkait semantik penjadwalan, jadi untuk mempelajari lebih lanjut,
baca tiga tulisan dalam bab 14 yang berjudul, Penjadwalan dalam Go (Scheduling In Go).

** Dasar-dasar Konkurensi (Concurrency)

Mulai dengan masalah dasar konkurensi yang membutuhkan orkestrasi.

    func init() {
        runtime.GOMAXPROCS(1)
    }

Pemanggilan GOMAXPROCS digunakan untuk menjalankan program Go sebagai program Go dengan thread tunggal.
Program ini akan berjalan dalam satu thread dan memiliki satu P/M untuk mengeksekusi semua Goroutine.
Fungsi ini ditulis dalam kapital karena juga merupakan variable environment.
Meskipun panggilan fungsi ini akan menimpa nilai variabel tersebut.

    g := runtime.GOMAXPROCS(0)

Fungsi ini adalah fungsi penting saat Anda menetapkan kuota CPU untuk konfigurasi kontainer.
Ketika melewatkan nilai 0, jumlah thread yang akan digunakan oleh program Go dilaporkan.
Anda harus memastikan bahwa jumlah tersebut sesuai dengan jumlah thread sistem operasi
yang tersedia di lingkungan kontainer saya. Jika angkanya tidak sama, program Go mungkin
tidak berjalan sebaik yang seharusnya. Anda mungkin ingin menggunakan variabel lingkungan
atau panggilan ini untuk menyamakan hal-hal tersebut.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        fmt.Println("Waiting To Finish")
        wg.Wait()

        fmt.Println("\nTerminating Program")
    }

Program ini harus menyelesaikan masalah orkestrasi. Goroutine utama tidak boleh membiarkan
fungsi utama selesai hingga ada jaminan bahwa kedua Goroutine yang dibuat menyelesaikan
pekerjaan mereka terlebih dahulu. `WaitGroup` adalah alat yang sempurna untuk masalah orkestrasi
yang tidak memerlukan pengiriman data antara Goroutine. Sinyal di sini dilakukan melalui API
yang memungkinkan sebuah Goroutine menunggu Goroutine lain memberi sinyal bahwa mereka telah selesai.

Dalam kode ini, sebuah WaitGroup dibuat dalam keadaan nilai nol dan kemudian metode `Add`
egera dipanggil untuk mengatur WaitGroup menjadi 2, yang akan sesuai dengan
jumlah Goroutine yang akan dibuat. Ketika Anda tahu berapa banyak Goroutine yang akan dibuat sebelumnya,
Anda harus memanggil Add sekali sesuai jumlah tersebut. Ketika Anda tidak tahu (seperti dalam layanan streaming),
maka memanggil Add(1) dapat diterima.

Pada akhir fungsi `main` terdapat panggilan ke `Wait`. `Wait` menahan Goroutine utama agar
tidak menyebabkan fungsi ini selesai. Ketika fungsi utama selesai, program Go akan ditutup dengan sangat tegas.
Inilah mengapa mengelola orkestrasi dengan jaminan yang tepat sangat penting.
Panggilan `Wait` akan diblokir sampai `WaitGroup` diatur kembali menjadi 0.

Di tengah program, Anda membuat dua Goroutine.

    func main() {
        . . .

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        . . .
    }

Fungsi literal dideklarasikan dan dieksekusi dengan menggunakan kata kunci `go`.
Pada titik ini, Anda memberi tahu penjadwal Go untuk mengeksekusi fungsi-fungsi ini secara konkuren.
Mengeksekusinya dalam urutan yang tidak terdefinisi. Di dalam implementasi setiap Goroutine,
terdapat panggilan ke `Done`. Panggilan tersebut yang mengurangkan nilai WaitGroup sebanyak 1.
Begitu kedua panggilan ke `Done` dilakukan, `WaitGroup` akan berubah dari 2 menjadi 0,
dan kemudian Goroutine utama akan diizinkan untuk dibebaskan dari panggilan ke `Wait`, mengakhiri program.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            wg.Done()
        }()

        . . .
    }

Bagian penting dari pola orkestrasi ini adalah menjaga panggilan`Add` dan `Done`
berada dalam garis pandang yang sama. Cobalah untuk tidak meneruskan `WaitGroup`
sebagai parameter fungsi di mana panggilannya hilang. Ini akan membantu mengurangi bug.

    Keluaran:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    Terminating Program

Ketika Anda membuat dan menjalankan program ini, Anda akan melihat bagaimana
program ini berjalan secara konkuren. Goroutine kedua yang dibuat dijadwalkan terlebih dahulu.
Ia berhasil menyelesaikan pekerjaannya dan kemudian Goroutine lainnya berjalan.
Keduanya berjalan hingga selesai sebelum program berakhir. Saat Anda menjalankan program ini lagi,
tidak ada jaminan bahwa Anda akan melihat output yang sama.
Satu-satunya jaminan dalam program ini adalah bahwa program tidak akan berakhir sampai kedua Goroutine selesai.

Meskipun Anda menjalankan program ini 100 kali dan melihat output yang sama,
tidak ada jaminan bahwa itu akan terjadi lagi. Mungkin sangat mungkin, tetapi tidak dijamin.
Terutama tidak dijamin di seluruh versi program, sistem operasi, dan arsitektur yang berbeda.

    func main() {
        . . .

        fmt.Println("Waiting To Finish")
        // wg.Wait()                           <-- CHANGED

        fmt.Println("\nTerminating Program")
    }

Jika Anda mengomentari pemanggilan `Wait`, apa yang akan terjadi ketika
Anda menjalankan program ini? Sekali lagi, tidak ada jaminan sama sekali
dengan apa yang akan terjadi, tetapi ada berbagai kemungkinan.

Program bisa berperilaku seperti sebelumnya karena pemanggilan `Println`
adalah panggilan sistem yang memungkinkan penjadwal untuk membuat peralihan konteks.
Program bisa mengeksekusi salah satu dari dua Goroutine atau mungkin langsung berakhir.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            // wg.Done()               <-- CHANGED
        }()

        . . .
    }

Apa yang terjadi jika Anda lupa memanggil `Done` di salah satu Goroutine?
Dalam kasus ini, program akan mengalami deadlock karena `WaitGroup` tidak dapat kembali ke 0.
Panggilan `Wait` akan diblokir selamanya.

    Keluaran:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    fatal error: all goroutines are asleep - deadlock!

    goroutine 1 [semacquire]:
    sync.runtime_Semacquire(0xc00001a0a8)
        /usr/local/go/src/runtime/sema.go:56 +0x45
    sync.(*WaitGroup).Wait(0xc00001a0a0)
        /usr/local/go/src/sync/waitgroup.go:130 +0x65
    main.main()
        concurrency/goroutines/example1/example1.go:42 +0x145
    exit status 2

Anda dapat melihat bagaimana Go Runtime mengidentifikasi bahwa program terjebak deadlock pada baris 42
di mana panggilan Wait terjadi. Anda sebaiknya tidak terlalu bersemangat tentang deteksi deadlock
karena setiap Goroutine harus terblokir tanpa jalan keluar. Ini menunjukkan mengapa
menjaga panggilan `Add` dan `Done` bersama-sama begitu penting.

    func main() {
        var wg sync.WaitGroup
        wg.Add(1)              <-- CHANGED, Number Too Small

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        . . .
    }

Apa yang terjadi jika Anda tidak memberikan jumlah Goroutine yang benar kepada WaitGroup untuk menunggu?
Jika jumlahnya terlalu besar, Anda akan mengalami deadlock lain. Jika jumlahnya terlalu kecil,
tidak ada jaminan bahwa pekerjaan selesai sebelum program melanjutkan. Output program menjadi tidak terdefinisi.

** Pencegahan pada Sistem Penjadwalan

Meskipun sistem penjadwalan berjalan dalam lingkup aplikasi,
penting untuk melihat bagaimana penjadwalannya bersifat berhati-hati.
Ini berarti Anda tidak dapat memprediksi kapan peralihan konteks akan terjadi
dan hal ini akan berubah setiap kali Anda menjalankan program.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            printHashes("A")
            wg.Done()
        }()

        go func() {
            printHashes("B")
            wg.Done()
        }()

        fmt.Println("Waiting To Finish")
        wg.Wait()

        fmt.Println("\nTerminating Program")
    }

Dengan menggunakan pola orkestrasi yang sama seperti sebelumnya, program ini membuat
setiap Goroutine melakukan pekerjaan yang lebih banyak. Pekerjaan yang tidak akan
diberikan penjadwal kepada Goroutine cukup waktu untuk menyelesaikannya sepenuhnya dalam suatu waktu.

    func printHashes(prefix string) {
        for i := 1; i <= 50000; i++ {
            num := strconv.Itoa(i)
            sum := sha1.Sum([]byte(num))
            fmt.Printf("%s: %05d: %x\n", prefix, i, sum)
        }
        fmt.Println("Completed", prefix)
    }

Fungsi ini sedang melakukan banyak pekerjaan yang terikat pada I/O (IO-bound)
yang memiliki potensi untuk mengalami peralihan konteks.

    $ ./example2 | cut -c1 | grep '[AB]' | uniq
    B
    A
    B
    A
    B
    A
    B
    A
    B
    A  9 Context Switches

    $ ./example2 | cut -c1 | grep '[AB]' | uniq
    B
    A
    B
    A  3 Context Switches

Seperti yang dapat Anda lihat, setiap kali Anda menjalankan program, ada jumlah peralihan konteks yang berbeda.
Ini adalah hal yang baik karena penjadwal tidak seharusnya dapat diprediksi.
Konkurensi perlu tetap tidak terdefinisi, dan Anda harus ingat hal itu ketika
menggunakan konkurensi untuk memecahkan masalah kinerja.

    func init() {
        runtime.GOMAXPROCS(2)
    }

Apa yang terjadi jika Anda kembali ke program asli tetapi mengubah GOMAXPROCS sehingga program berjalan sebagai program Go dengan dua thread?

    Keluaran:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N a b c d e f g h i j k l m n o O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    Terminating Program

Apa yang Anda lihat adalah konkurensi program kini lebih terperinci.
Keluaran menjadi tidak terdefinisi dan tidak berurutan.

** Catatan

- Goroutine adalah fungsi yang dijadwalkan untuk dijalankan secara independen.
- Kita harus selalu menjaga jalannya goroutine dan mematikannya dengan baik.
- Konkurensi bukanlah paralelisme.

- Konkurensi berkaitan dengan menangani banyak hal sekaligus.
- Paralelisme berkaitan dengan melakukan banyak hal sekaligus.

"Parallelism is about physically doing two or more things at the same time. Concurrency is about undefined, out of order, execution." - William Kennedy

"By default, goroutines shouldn't outlive the function they were created from. this forces you into a extremely good design posture." - Peter Bourgon

** Pedoman Desain

- Belajar mengenai [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#concurrent-software-design][pedoman desain]] untuk konkurensi.

** Bacaan Tambahan

- [[https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html][Scheduling In Go - Part I]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html][Scheduling In Go - Part II]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html][Scheduler Tracing In Go]] - William Kennedy
- [[https://blog.golang.org/advanced-go-concurrency-patterns][Advanced Go Concurrency Patterns]] - Sameer Ajmani
- [[https://blog.golang.org/context][Go Concurrency Patterns: Context]] - Sameer Ajmani
- [[https://blog.golang.org/concurrency-is-not-parallelism][Concurrency is not parallelism]] - Rob Pike
- [[https://talks.golang.org/2013/distsys.slide][Go, for Distributed Systems]] - Russ Cox
- [[https://docs.google.com/document/d/1At2Ls5_fhJQ59kDK2DFVhFu3g5mATSXqqV5QrxinasI/edit][Go 1.5 GOMAXPROCS Default]]
- [[https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html][Concurrency, Goroutines and GOMAXPROCS]] - William Kennedy
- [[http://www.ece.ubc.ca/~sasha/papers/eurosys16-final29.pdf][The Linux Scheduler: a Decade of Wasted Cores]]
- [[https://news.ycombinator.com/item?id=12460807][Explanation of the Scheduler]]
- [[http://joeduffyblog.com/2016/11/30/15-years-of-concurrency/][15 Years of Concurrency]] - Joe Duffy
- [[https://www.quora.com/How-does-the-golang-scheduler-work/answer/Ian-Lance-Taylor][How does the golang scheduler work?]] - Ian Lance Taylor
- [[https://www.youtube.com/watch?v=YHRO5WQGh0k][The Scheduler Saga]] - Kavya Joshi

* Latihan

Gunakan templat ini sebagai titik awal untuk menyelesaikan latihan. Sebuah solusi disediakan.

** Latihan 1

*Bagian* *A* Buatlah sebuah program yang mendeklarasikan dua fungsi anonim.
Satu fungsi menghitung mundur dari 100 hingga 0 dan satu fungsi menghitung naik dari 0 hingga 100.
Tampilkan setiap angka dengan pengidentifikasi unik untuk setiap goroutine.
Kemudian buat goroutine dari kedua fungsi ini dan jangan biarkan fungsi utama selesai hingga semua goroutine selesai.

*Bagian* *B* Jalankan program secara paralel.

.play goroutines/exercise1.go
.play goroutines/answer1.go
