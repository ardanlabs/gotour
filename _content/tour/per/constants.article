ثابت‌ها (constant)
یکی از ویژگی‌های منحصربه‌فرد Go، نحوه‌ی اجرای زبان برای ثوابت است.

* ثابت ها

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][تماشای ویدئو]]
- نیاز به کمک مالی دارید؟ از [[https://www.ardanlabs.com/scholarship/][فرم Scholarship]] ما استفاده کنید.

یکی از ویژگی‌های منحصر به فرد Go، نحوه پیاده‌سازی ثوابت در زبان است. قوانین برای ثوابت در مشخصات زبان، به Go ویژگی‌های خاصی ارائه می‌دهند. این قوانین امکان ایجاد انعطاف‌پذیری برای Go را فراهم می‌کنند تا کدی که می‌نویسیم قابل خواندن و شفاف باشد در حالی که از نظر ایمنی نوع هم همچنان حفظ شود.

ثوابت می‌توانند دارای نوع (typed) یا بی‌نوع (untyped) باشند. وقتی یک ثابت بی‌نوع باشد، به عنوان نوعی خاص محسوب می‌شود. ثوابتی که دارای نوع هستند، ممکن است توسط کامپایلر به صورت ضمنی تبدیل شوند. این همه در زمان کامپایل و نه در زمان اجرا رخ می‌دهد.

** بررسی کد

- *مثال* *1:* تعریف و مقداردهی ثابت ها		
- *مثال* *2:* سیستم نوع موازی (Kind) (گم شده است)
- *مثال* *3:* iota			
- *مثال* *4:* تبدیل ضمنی

.play constants/example1.go
.play constants/example2.go
.play constants/example3.go
.play constants/example4.go

    const ui = 12345     // kind: integer
    const uf = 3.141592  // kind: floating-point

ثوابت عددی بی‌نوع دقت 256 بیتی دارند که توسط مشخصات مشخص شده است. آنها بر اساس نوعی (kind) مبتنی هستند.

    const ti int     = 12345     // type: int
    const tf float64 = 3.141592  // type: float64

ثوابت دارای نوع هنوز از سیستم نوع ثابت استفاده می‌کنند، اما دقت آنها محدود شده است.

    const myUint8 uint8 = 1000 // Compiler Error: constant 1000 overflows uint8

این کار کار نمی‌کند زیرا عدد 1000 بزرگ‌تر از حداکثر مقدار قابل ذخیره‌سازی در یک uint8 است.

    var answer = 3 * 0.333  // float64 = KindFloat(3) * KindFloat(0.333)

حساب‌های ثابت پشتیبانی می‌کند از استفاده از انواع مختلف ثوابت. ترفیع نوع (Kind Promotion) برای مدیریت این حالت‌های مختلف استفاده می‌شود. همه این‌ها به صورت ضمنی رخ می‌دهد. متغیر پاسخ در این مثال از نوع float64 خواهد بود و مقدار 0.999 را با دقت 64 بیتی نمایان می‌کند.

    const third = 1 / 3.0  // KindFloat = KindFloat(1) / KindFloat(3.0)

ثابت سوم از نوع float خواهد بود و مقدار 1/3 را با دقت 256 بیتی نمایان می‌کند.

    const zero = 1 / 3  // KindInt = KindInt(1) / KindInt(3)

ثابت صفر از نوع integer خواهد بود و به مقدار 0 تنظیم می‌شود زیرا تقسیم integer هیچ باقی‌مانده‌ای ندارد.

    const one int8 = 1
    const two = 2 * one  // int8(2) * int8(1)

این یک مثال از حساب‌های ثابت بین ثوابت دارای نوع و ثوابت بی‌نوع است. در این مورد، یک ثابت از نوع به نوع دیگری ترفیع می‌یابد. دو ثابت از نوع int8 خواهند بود و به مقدار 2 تنظیم می‌شوند.

    const maxInt = 9223372036854775807

این بیشترین مقدار ممکن برای یک عدد صحیح 64 بیتی است.

    const bigger = 9223372036854775808543522345

ثابت بزرگتر، مقداری بسیار بزرگتر از یک عدد صحیح 64 بیتی است، اما می‌تواند در یک ثابت نوع int ذخیره شود زیرا ثوابت نوع int به 64 بیت دقت محدود نیستند.

    const bigger int64 = 9223372036854775808543522345

خطای کامپایلر:

    constant 9223372036854775808543522345 overflows int64

اما اگر ثابت bigger از نوع int64 باشد، این کد کامپایل نخواهد شد.

** IOTA

IOTA امکان تنظیم ثوابت متوالی صحیح را فراهم می‌کند. ممکن است نام آن از تابع صحیح ⍳ از زبان برنامه‌نویسی APL آمده باشد. در APL، تابع ⍳ (که با حرف نهم الفبای یونانی، iota، نمایان می‌شود) برای ایجاد آرایه‌ای با مبنای صفر از اعداد صحیح متوالی و صعودی با طول مشخص استفاده می‌شود.

    const (
        A1 = iota  // 0 : Start at 0
        B1 = iota  // 1 : Increment by 1
        C1 = iota  // 2 : Increment by 1
    )
    fmt.Println(A1, B1, C1)

خروجی:

    0 1 2

کلمه کلیدی iota در محدوده‌ی ثابت (constant block) کار می‌کند و با مقدار 0 شروع می‌شود. سپس برای هر ثابت متوالی که در محدوده اعلام شده در بلاک، iota یک واحد افزایش می‌یابد.

    const (
        A2 = iota  // 0 : Start at 0
        B2         // 1 : Increment by 1
        C2         // 2 : Increment by 1
    )
    fmt.Println(A2, B2, C2)

خروجی:

    0 1 2

شما نیازی به تکرار استفاده از کلمه کلیدی iota ندارید. طبیعت متوالی ثوابت صحیح پس از استفاده یک بار فرض می‌شود.

    const (
        A3 = iota + 1  // 1 : 0 + 1
        B3             // 2 : 1 + 1
        C3             // 3 : 2 + 1
    )
    fmt.Println(A3, B3, C3)

خروجی:

    1 2 3

اگر نمی‌خواستید یک الگوی ریاضی اعمال کنید، می‌توانید محاسباتی انجام دهید و محاسبات با افزایش مقدار iota مجدداً اعمال می‌شود.

    const (
        Ldate= 1 << iota  //  1 : Shift 1 to the left 0.  0000 0001
        Ltime             //  2 : Shift 1 to the left 1.  0000 0010
        Lmicroseconds     //  4 : Shift 1 to the left 2.  0000 0100
        Llongfile         //  8 : Shift 1 to the left 3.  0000 1000
        Lshortfile        // 16 : Shift 1 to the left 4.  0001 0000
        LUTC              // 32 : Shift 1 to the left 5.  0010 0000
    )

    fmt.Println(Ldate, Ltime, Lmicroseconds, Llongfile, Lshortfile, LUTC)

خروجی:

    1 2 4 8 16 32

شما می‌توانید از این ویژگی به مانند بسته‌ی Log برای تنظیم پرچم‌ها (flags) استفاده کنید. در این مورد، عملیات بیتی با افزایش مقادیر iota برای محاسبه مقادیر پرچم انجام می‌شود.

** یادداشت‌ها

- ثوابت (constants) متغیرها نیستند.
- آنها تنها در زمان کامپایل وجود دارند.
- ثوابت بی‌نوع می‌توانند به صورت ضمنی تبدیل شوند، در حالی که ثوابت و متغیرهای دارای نوع نمی‌توانند.
- ثوابت بی‌نوع را به عنوان داشتن نوع، نه داشتن نوع (Kind) در نظر بگیرید.
- در مورد تبدیل‌های صریح و ضمنی آشنا شوید.
- قدرت ثوابت و کاربرد آنها در کتابخانه استاندارد را بیاموزید.

** Extra Reading

- [[https://golang.org/ref/spec#Constants][Constants specification]]    
- [[https://blog.golang.org/constants][Constants]] - Rob Pike    
- [[https://www.ardanlabs.com/blog/2014/04/introduction-to-numeric-constants-in-go.html][Introduction To Numeric Constants In Go]] - William Kennedy    
		
* تمرین‌ها

از الگو به عنوان نقطه شروع برای انجام تمرین‌ها استفاده کنید. یک راه حل ممکن ارائه شده است.

** تمرین 1

*بخش* *الف:* یک ثابت بی‌نوع و یک ثابت دارای نوع تعریف کرده و مقادیر آنها را نمایش دهید.

*بخش* *ب:* دو ثابت حرفی (literal constants) را به یک متغیر دارای نوع تقسیم کنید و مقدار آن را نمایش دهید.

.play constants/exercise1.go
.play constants/answer1.go
