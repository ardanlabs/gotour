ساختار (Struct)
ساختار (Struct) مجموعه ای از فیلد ها با تایپ های مختلف را درخود نگه می دارد.

* ساختار (Struct)

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][تماشای ویدئو]]
- نیاز به کمک مالی دارید؟ از [[https://www.ardanlabs.com/scholarship/][فرم Scholarship]] ما استفاده کنید.

انواع ساختاری (Struct types) یک روش برای ایجاد انواع پیچیده هستند که فیلدهای داده را با هم گروه‌بندی می‌کنند. آنها راه عالی‌ای برای سازماندهی و به اشتراک‌گذاری جنبه‌های مختلف داده‌هایی که برنامه شما مصرف می‌کند هستند.

کارایی پتانسیلی معماری کامپیوتر به طور عمده توسط طول کلمه (تعداد بیت‌های قابل پردازش در هر دسترسی) و، به ویژه، اندازه حافظه یا تعداد کلماتی که می‌توان به آن دسترسی پیدا کرد، تعیین می‌شود.

** بررسی کد

- *مثال* *1:*  اعلام، ایجاد و مقداردهی انواع ساختاری
- *مثال* *2:* انواع ساختاری ناشناس
- *مثال* *3:* انواع نام‌دار در مقابل انواع بی‌نام
- *مثال* *4:* ترازبندی انواع ساختاری

.play struct-types/example1.go
.play struct-types/example2.go
.play struct-types/example3.go
.play struct-types/example4.go

** Struct و Construction مکانزیم

این اعلام یک نوع تعریف‌شده توسط کاربر به عنوان یک ترکیب از فیلدها و انواع مختلف را نمایان می‌کند.

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

یک متغیر از نوع مثال (example) اعلام کنید و آن را به حالت مقدار صفری مقداردهی اولیه کنید.

    var e1 example

    fmt.Printf("%+v\n", e1)

Output:
    
    {flag:false counter:0 pi:0}

یک متغیر از نوع مثال (example) را با استفاده از نحوه ساخت از مقدار ابتدایی آن (صفر) مستثنی کرده و مقداردهی اولیه کنید.

    e2 := example{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e2.flag)
    fmt.Println("Counter", e2.counter)
    fmt.Println("Pi", e2.pi)

خروجی:

    Flag true
    Counter 10
    Pi 3.141592

یک متغیر از یک نوع معنون ناشناس اعلام کنید و آن را به حالت مقدار غیر صفری مقداردهی اولیه کنید با استفاده از نحوه ساخت از مقدار ابتدایی.

    e3 := struct {
        flag    bool
        counter int16
        pi      float32
    }{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e3.flag)
    fmt.Println("Counter", e3.counter)
    fmt.Println("Pi", e3.pi)

خروجی:

    Flag true
    Counter 10
    Pi 3.141592

ایده‌ی ساخت از مقدار ابتدایی دقیقا همین است، به معنای ساخت چیزی به صورت واقعی بدون نام.

برای مقدار صفر از var استفاده کنید و برای ساخت مقدار غیر صفر از اپراتور تعریف متغیر کوتاه به همراه نحو { } استفاده کنید.

** پدینگ و ترازبندی (Padding and Aligment)

مقدار حافظه مختصر یک نوع مثال چقدر است؟

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

یک متغیر bool 1 بایت، int16 2 بایت و float32 4 بایت حافظه اشغال می‌کند. اگر این مقادیر را با هم جمع کنید، مجموعاً 7 بایت خواهید داشت. با این حال، پاسخ واقعی 8 بایت است. چرا؟ چون بین فیلدهای پرچم و شمارنده یک بایت پدینگ وجود دارد به عنوان یک روش ترازبندی.

.image /tour/eng/static/img/f1.png

ایده ترازبندی این است که به سخت‌افزار امکان خواندن حافظه به صورت کارآمد‌تر با قرار دادن حافظه در مرزهای خاص ترازبندی اجازه دهد. کامپایلر از مکانیزم‌های مرز ترازبندی مراقبت می‌کند، بنابراین شما نیازی به انجام کارهای مربوط به ترازبندی ندارید.

بسته به اندازه یک فیلد خاص و مکان آن در ساختار، Go پدینگ مورد نیاز شما را تعیین می‌کند.

    type example2 struct {
        flag    bool
        counter int16
        flag2   bool
        pi      float32
    }

در این مثال، یک فیلد جدید به نام `flag2` بین فیلدهای شمارنده و pi اضافه کرده‌ام. این باعث می‌شود که در داخل ساختار (struct) بیشترین پدینگ (padding) ایجاد شود.

    type example2 struct {
        flag    bool     // 0xc000100020 <- Starting Address
                byte     // 0xc000100021 <- 1 byte padding
        counter int16    // 0xc000100022 <- 2 byte alignment
        flag2   bool     // 0xc000100024 <- 1 byte alignment
                byte     // 0xc000100025 <- 1 byte padding
                byte     // 0xc000100026 <- 1 byte padding
                byte     // 0xc000100027 <- 1 byte padding
        pi      float32  // 0xc000100028 <- 4 byte alignment
    }

این نشان‌دهنده نحوه عملکرد ترازبندی و پدینگ است اگر یک مقدار از نوع example2 از آدرس 0xc000100020 شروع شود. فیلد پرچم (flag) نشان‌دهنده آدرس شروع است و فقط 1 بایت اندازه دارد. از آنجایی که فیلد شمارنده (counter) نیاز به اختصاص 2 بایت حافظه دارد، باید در حافظه در تراز 2 بایتی قرار گیرد، به این معنی که باید در یک آدرس که ضریب 2 باشد قرار گیرد. این باعث می‌شود که فیلد شمارنده از آدرس 0xc000100022 شروع شود. این ایجاد یک فاصله 1 بایتی بین فیلدهای پرچم و شمارنده دارد.

.image /tour/eng/static/img/f2.png

فیلد `flag2` یک متغیر بول است و می‌تواند در آدرس بعدی 0xc000100024 قرار گیرد. فیلد نهایی، pi، نیاز به اختصاص 4 بایت حافظه دارد، بنابراین باید در یک تراز 4 بایتی قرار گیرد. آدرس بعدی برای یک مقدار 4 بایتی در 0xc000100028 قرار دارد. این به معنی نیاز به 3 بایت پدینگ دیگر برای حفظ تراز صحیح است. این منجر به این می‌شود که یک مقدار از نوع example2 نیاز به 12 بایت از حافظه اختصاصی کلی داشته باشد.

بزرگترین فیلد در یک struct تراز مرز تراز برای کل struct را نمایش می‌دهد. در این مورد، بزرگترین فیلد 4 بایت است، بنابراین آدرس شروع برای این مقدار struct باید ضریبی از 4 باشد. می‌توانید ببینید که آدرس 0xc000100020 ضریبی از 4 است.

اگر نیاز دارید که حداقل تعداد بایت‌های پدینگ را کاهش دهید، باید فیلدها را از حجم بالاتر به حجم کمتر بچینید. این کار باعث می‌شود که هر بایت پدینگ مورد نیاز به پایین‌ترین قسمت struct فشرده شود و تعداد کلی بایت‌های پدینگ مورد نیاز کاهش یابد.

    type example struct {
        pi      float32  // 0xc000100020 <- Starting Address
        counter int16    // 0xc000100024 <- 2 byte alignment
        flag    bool     // 0xc000100026 <- 1 byte alignment
        flag2   bool     // 0xc000100027 <- 1 byte alignment
    }

بعد از بازترتیب دهی مجدد فیلدها، مقدار struct فقط به 8 بایت از حافظه اختصاصی نیاز دارد و نه 12 بایت. از آنجا که تمامی فیلدها اجازه می‌دهند مقدار struct بر روی یک تراز 4 بایتی قرار گیرد، هیچ بایت پدینگ اضافی مورد نیاز نیست.

.image /tour/eng/static/img/f3.png

** تخصیص مقادیر

اگر دو نوع نامگذاری شده متفاوت که در ساختار یکسانی هستند را داشته باشید، نمی‌توانید مقدار یکی را به دیگری اختصاص دهید.

به عنوان مثال، اگر انواع example1 و example2 با استفاده از همان تعریف دقیق اعلام شوند و متغیرهایی را مقداردهی اولیه کنیم.

    var ex1 example1
    var ex2 example2

شما نمی‌توانید این دو متغیر را به یکدیگر اختصاص دهید چرا که آن‌ها از نوع‌های نامگذاری شده متفاوتی هستند. حقیقت این است که شباهت در ساختار آن‌ها اهمیتی ندارد.

    ex1 = ex2  // اجازه نمیده, خطای کامپایلر

برای انجام این اختصاص، شما باید از نحو تبدیل (conversion) استفاده کنید و از آنجا که در ساختار یکسان هستند، کامپایلر اجازه این عمل را می‌دهد.

    ex1 = example1(ex2)  // اجازه داده میشه, بدون خطای کامپایلر

با این حال، اگر ex2 به عنوان یک نوع بدون نام با استفاده از همان تعریف دقیق ex1 اعلام شود، نیازی به نحو تبدیل (conversion) نخواهد بود.

    var ex2 struct {
        flag    bool
        counter int16
        pi      float32
    }

    ex1 = ex2  // Allowed, NO need for conversion syntax

کامپایلر به انجام این اختصاص بدون نیاز به تبدیل اجازه می‌دهد.

** نکات

- ما می‌توانیم از فرم لیترال struct برای مقداردهی از یک نوع struct استفاده کنیم.
- اپراتور نقطه (.) به ما امکان دسترسی به مقادیر فیلد‌های فردی را می‌دهد.
- ما می‌توانیم struct‌های ناشناس ایجاد کنیم.

** نقل قول ها

"تبدیل ضمنی انواع معادل عید هالووین برنامه‌نویسی است. هر کسی که به این فکر افتاده است، به جهنم ویژه خودش لایق است." - مارتین تامسون

** خواندن اضافی

- [[https://www.ardanlabs.com/blog/2013/07/understanding-type-in-go.html][Understanding Type in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/07/object-oriented-programming-in-go.html][Object Oriented Programming in Go]] - William Kennedy    
- [[https://dave.cheney.net/2015/10/09/padding-is-hard][Padding is hard]] - Dave Cheney    
- [[https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/][Structure Member Alignment, Padding and Data Packing]]    
- [[http://www.catb.org/esr/structure-packing][The Lost Art of Structure Packing]] - Eric S. Raymond    

* تمرینات

از الگو به عنوان نقطه شروع برای انجام تمرینات استفاده کنید. یک راه حل ممکن ارائه شده است.

** تمرین 1

*بخش* *A:* یک نوع struct برای نگه‌داری اطلاعات یک کاربر (نام، ایمیل و سن) اعلام کنید. یک مقدار از این نوع ایجاد کرده، با مقادیر مقداردهی اولیه کنید و هر فیلد را نمایش دهید.

*بخش* *B:* یک نوع struct بدون نام اعلام کنید و با سه فیلد مشابه مقداردهی اولیه کنید. مقدار را نمایش دهید.

.play struct-types/exercise1.go
.play struct-types/answer1.go
