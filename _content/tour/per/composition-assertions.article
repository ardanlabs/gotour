نوع تبدیل و تأییدها
یاد بگیرید که تبدیل‌ها و تأییدها نوع چگونه کار می‌کنند.

* نوع تبدیل و تأییدها

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][تماشای ویدئو]]
- نیاز به کمک مالی دارید؟ از [[https://www.ardanlabs.com/scholarship/][فرم Scholarship]] ما استفاده کنید.

تبدیل نوع به دادهٔ یک نوع، امکان می‌دهد تا به نوع دیگری تبدیل شود. تأیید نوع به شما امکان می‌دهد تا بپرسید که آیا یک مقدار از نوع دادهٔ داده شده درون یک رابطه ذخیره شده است یا خیر.

** بررسی کد

- *مثال* *1:* تبدیل‌های اینترفیس
- *مثال* *2:* تأییدهای نوع زمان اجرا
- *مثال* *3:* تغییرات رفتار

.play composition/assertions/example1.go
.play composition/assertions/example2.go
.play composition/assertions/example3.go

**تبدیل‌های ضمنی رابط

همانطور که در مثال گذشته دیدید، یک مقدار رابط از یک نوع می‌تواند برای نوع دیگری از رابطه ارسال شود، اگر مقدار محتوای ذخیره شده درون رابط هر دو رفتار را پیاده‌سازی کند. این می‌تواند به عنوان یک تبدیل ضمنی رابط در نظر گرفته شود، اما بهتر است دربارهٔ اینکه چگونه دادهٔ محتوا در حالت مجزا از طریق رابطها جابجا می‌شود، فکر کنیم.

    type Mover interface {
        Move()
    }

    type Locker interface {
        Lock()
        Unlock()
    }

    type MoveLocker interface {
        Mover
        Locker
    }

با توجه به این سه رابطه، جایی که MoveLocker ترکیبی از Mover و Locker است.

    type bike struct{}

    func (bike) Move() {
        fmt.Println("Moving the bike")
    }

    func (bike) Lock() {
        fmt.Println("Locking the bike")
    }

    func (bike) Unlock() {
        fmt.Println("Unlocking the bike")
    }

و با توجه به این نوع محسوب‌شده bike که همه سه رابطه را پیاده‌سازی می‌کند، شما چه کارهایی می‌توانید انجام دهید؟

    var ml MoveLocker
    var m Mover

شما می‌توانید یک مقدار از نوع MoveLocker و Mover را به حالت مقدار صفر خود بسازید. این مقادیر رابطه ای هستند که واقعاً بی‌ارزش هستند.

    ml = bike{}

سپس شما می‌توانید یک مقدار از نوع bike را به حالت مقدار صفر خود بسازید و یک کپی از آن را به متغیر MoveLocker با نام ml اختصاص دهید. این امکان وجود دارد زیرا یک bike همه سه رفتار را پیاده‌سازی می‌کند و کامپایلر می‌تواند ببیند که پیاده‌سازی موجود است.

    m = ml

سپس شما می‌توانید متغیر MoveLocker با نام ml را به متغیر Mover با نام m اختصاص دهید. این امکان وجود دارد زیرا من مقدار رابطه ml را نمی‌دهم، بلکه مقدار محتوای واقعی که در داخل ml ذخیره شده است و یک مقدار bike است را اختصاص می‌دهم. کامپایلر می‌داند که هر مقدار واقعی که در داخل ml ذخیره شده است باید همچنین رابطه Mover را پیاده‌سازی کند.

با این حال، این اختصاص معتبر نیست.

    ml = m

خروجی:

    نمی‌توانید از m (نوع Mover) به عنوان نوع MoveLocker در اختصاص استفاده کنید:
        Mover پیاده‌سازی MoveLocker را انجام نمی‌دهد (متد Lock وجود ندارد)

نمی‌توانید متغیر Mover با نام m را به متغیر MoveLocker با نام ml اختصاص دهید زیرا کامپایلر تنها می‌تواند تضمین کند که مقدار واقعی که در داخل m ذخیره شده است، می‌داند چگونه حرکت کند. در زمان کامپایل، این مشخص نیست که آیا مقدار واقعی همچنین می‌داند چگونه قفل کند و باز کند.

** مکانیک تأیید نوع

یک تأیید نوع به شما اجازه می‌دهد تا در زمان اجرا سوالی را مطرح کنید، آیا یک مقدار از نوع داده شده درون یک رابطه ذخیره شده است. شما این را با استفاده از نحو m.(bike) مشاهده می‌کنید. 

    b := m.(bike)
    ml = b

در این حالت، شما در زمان اجرای کد سؤال می‌کنید که آیا یک مقدار bike درون مقدار m ذخیره شده است یا خیر. اگر چنین باشد، متغیر b یک کپی از مقدار bike ذخیره شده را دریافت می‌کند. سپس این کپی می‌تواند درون متغیر رابطه ml کپی شود.

اگر چیزی درون مقدار رابطه ذخیره نشده باشد، آنگاه برنامه به خطا می‌افتد. اگر شما مطمئن هستید که باید یک مقدار bike درون ذخیره شده باشد، این رفتار مطلوب است. اما اگر احتمال وجود نداشتن یک مقدار bike وجود داشته باشد و این معتبر باشد، آنگاه شما نیاز به فرم دوم تأیید نوع دارید.

    b, ok := m.(bike)

در این فرم، اگر مقدار ok برابر با true باشد، یک مقدار bike درون رابطه ذخیره شده است. اگر مقدار ok برابر با false باشد، بدین معنی است که مقدار bike ذخیره نشده است و برنامه به خطا نمی‌افتد. با این حال، متغیر b همچنان از نوع bike است، اما به حالت مقدار صفر خود تنظیم می‌شود.

    func main() {
        mvs := []fmt.Stringer{
            Car{},
            Cloud{},
        }

        for i := 0; i < 10; i++ {
            rn := rand.Intn(2)

            if v, is := mvs[rn].(Cloud); is {
                fmt.Println("Got Lucky:", v)
                continue
            }

            fmt.Println("Got Unlucky")
        }
    }

با فرض اینکه برنامه دو نوع به نام Car و Cloud را تعریف کند که هر دو آنها رابطه fmt.Stringer را پیاده‌سازی می‌کنند، شما می‌توانید یک مجموعه بسازید که به شما امکان ذخیره کردن مقداری از نوع Car و Cloud را می‌دهد. سپس به طور تصادفی و 10 بار، یک عدد از 0 تا 1 را انتخاب کرده و با استفاده از تأیید نوع، می‌توانید ببینید که آیا مقدار در آن شاخه تصادفی شامل یک مقدار Cloud است یا خیر. از آنجایی که احتمال دارد که این مقدار از نوع Cloud نباشد، فرم دوم تأیید نوع در اینجا بسیار حیاتی است.
