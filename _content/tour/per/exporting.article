صادرات (Exporting)
صادرات امکان تعیین می‌دهد که آیا یک شناسه (identifier) به کد خارج از پکیجی که در آن تعریف شده است، دسترسی دارد یا خیر.

* صادرات (Exporting)

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][تماشای ویدئو]]
- نیاز به کمک مالی دارید؟ از [[https://www.ardanlabs.com/scholarship/][فرم Scholarship]] ما استفاده کنید.

صادرات (Exporting) امکان تعیین می‌دهد که آیا یک شناسه (identifier) به کد خارج از پکیجی که در آن تعریف شده است، دسترسی دارد یا خیر.

** بررسی کد

- *مثال* *1:* تعریف و دسترسی به شناسه‌های صادر شده
- *مثال* *2:* تعریف شناسه‌های غیرصادر شده و محدودیت‌ها
- *مثال* *3:* دسترسی به مقادیر شناسه‌های غیرصادر شده
- *مثال* *4:* فیلدهای نوع ساختار غیرصادر شده
- *مثال* *5:*  embedded types غیرصادر شده

.play exporting/example1.go
.play exporting/example2.go
.play exporting/example3.go
.play exporting/example4.go
.play exporting/example5.go

** مکانیک صادرات

یک پکیج (package) واحد اصلی کد کامپایل شده در Go است. این یک واحد فیزیکی از کد کامپایل شده را نمایان می‌کند، معمولاً به عنوان یک کتابخانه کامپایل شده در سیستم عامل میزبان. صادرات تعیین می‌کند که آیا به شناسه‌ها دسترسی از مرزهای پکیج ممکن است یا نه.

    package counters

    type AlertCounter int

در این مورد، از یک حروف بزرگ برای نام‌گذاری نوع AlterCounter استفاده می‌شود، بنابراین این نوع صادر شده است و می‌توان به صورت مستقیم توسط کد خارج از پکیج counters ارجاع داد.

    package counters

    type alertCounter int

اکنون که نام نوع را به شروع با حرف کوچک تغییر داده‌اید، نوع به حالت غیرصادر (unexported) تغییر کرده است. این به این معناست که تنها کد درون پکیج counters می‌تواند به این نوع به صورت مستقیم ارجاع دهد.

    package counters

    type alertCounter int

    func New(value int) alertCounter {
        return alertCounter(value)
    }

هرچند کد بالا از نظر سینتکس صحیح است و کامپایل می شود، اما ارزشی ندارد. بازگرداندن مقدار از یک نوع داده غیرقابل مشاهده گیج کننده است زیرا فراخواننده (که احتمالاً در یک پکیج دیگر وجود دارد) نمی تواند به طور مستقیم به نام نوع داده اشاره کند.

    package main

    import (
        "fmt"

        "github.com/ardanlabs/.../exporting/example3/counters"
    )

    func main() {
        counter := counters.New(10)
        fmt.Printf("Counter: %d\n", counter)
    }

در این مورد، تابع اصلی در پکیج main با موفقیت تابع counters.New را فراخوانی می کند و کامپایلر می تواند یک متغیر از نوع داده غیرقابل مشاهده را اعلام و ایجاد کند. این بدان معنا نیست که شما باید این کار را انجام دهید و نه اینکه برای این کار محافظت واقعی دریافت می کنید. این باید اجتناب شود، و اگر New مقداری را برمی گرداند، باید از نوع داده قابل مشاهده باشد.
    package users

    type User struct {
        Name string
        ID   int

        password string
    }

وقتی صحبت از فیلدها در یک struct می شود، حرف اول مشخص می کند که آیا فیلد برای کدی در خارج از پکیجی که در آن اعلام شده است قابل دسترسی است یا خیر. در این مورد، Name و ID قابل دسترسی هستند، اما password خیر. این یک عرف است که فیلدهای قابل مشاهده و غیرقابل مشاهده را به این روش جدا کنید، اگر این کار منطقی یا عملی باشد. به طور معمول، همه فیلدها یکی یا دیگری هستند.

    package users

    type user struct {
        Name string
        ID   int
    }

    type Manager struct {
        Title string
        user
    }

در این سناریو، اگرچه نوع کاربر غیرقابل مشاهده است، اما دو فیلد قابل مشاهده دارد. این بدان معناست که زمانی که نوع کاربر در نوع صادر شده Manager جاسازی می شود، فیلدهای کاربر ارتقا می یابند و قابل دسترسی هستند. داشتن انواع غیرقابل مشاهده با فیلدهای قابل مشاهده رایج است زیرا بسته بازتابی تنها می تواند روی فیلدهای قابل مشاهده عمل کند. در غیر این صورت، Marshallers کار نمی کند.

این مثال یک موقعیت بد ایجاد می کند که در آن کدی در خارج از بسته users می تواند یک Manager بسازد، اما از آنجایی که نوع جاسازی شده user غیرقابل مشاهده است، فیلدهای آن نوع را نمی توان مقداردهی کرد. این مشکلات ساخت جزئی ایجاد می کند که منجر به اشکالات می شود. شما باید در صادر کردن و عدم صدور سازگار باشید.

** نکات

- کد در Go در پکیج ها کامپایل می شود و سپس به هم متصل می شود.
- شناسه ها بر اساس حروف بزرگ و کوچک بودن صادر می شوند (یا صادر نمی شوند).
- ما پکیج ها را برای دسترسی به شناسه های صادر شده وارد می کنیم.
- هر پکیجی می تواند از مقدار یک نوع داده غیرقابل مشاهده استفاده کند، اما استفاده از آن آزاردهنده است.

** خواندن بیشتر

[[https://www.ardanlabs.com/blog/2014/03/exportedunexported-identifiers-in-go.html][Exported/Unexported Identifiers In Go]] - William Kennedy    

* تمرین‌ها

از الگو به‌عنوان نقطه شروع برای تکمیل تمرین‌ها استفاده کنید. یک راه حل احتمالی ارائه شده است.

** تمرین 1

*بخش* *A:*  یک پکیج به نام toy با یک نوع struct صادر شده به نام Toy ایجاد کنید. فیلدهای صادر شده Name و Weight را اضافه کنید. سپس دو فیلد غیرقابل مشاهده به نام‌های onHand و sold اضافه کنید. یک تابع کارخانه به نام New برای ایجاد مقادیر از نوع toy و پذیرفتن پارامترهایی برای فیلدهای صادر شده اعلام کنید. سپس متدهایی را اعلام کنید که مقادیر فیلدهای غیرقابل مشاهده را برمی‌گردانند و به‌روزرسانی می‌کنند.

*بخش* *B:* یک برنامه ایجاد کنید که پکیج toy را وارد کند. از تابع New برای ایجاد یک مقدار از نوع toy استفاده کنید. سپس از متدها برای تنظیم شمارنده‌ها و نمایش مقادیر فیلدهای آن مقدار toy استفاده کنید.

.play exporting/exercise1.go
.play exporting/answer1.go
