Struct Types
از انواع ساختاری (Struct Types) می‌توانید از یک نوع ژنریک با استفاده از یک نوع ساختاری اعلام کنید.

* ویدیو

مشاهده کنید که من در مورد ژنریک‌ها چه چیزی ارائه داده‌ام که شما را از طریق تمام مثال‌های این بخش از تور راه می‌دهد.

.html generics-video.html

** بررسی کد

- *مثال* *1*: لیست پیوندی

.play generics/struct-types/example1.go

** توضیح داده شده

اگر بخواهید یک نوع ژنریک خود را با استفاده از یک نوع ساختاری اعلام کنید، چه اتفاقی می‌افتد؟

    type node[T any] struct {
        Data T
        next *node[T]
        prev *node[T]
    }

این نوع ساختاری به عنوان نوعی برای یک گره در لیست پیوندی اعلام شده است. هر گره شامل یک قطعه داده فردی است که توسط لیست ذخیره و مدیریت می‌شود. استفاده از پرانتز مربعی اعلام می‌کند که نوع T یک نوع ژنریک است که باید در زمان کامپایل تعیین شود. استفاده از محدودیت "any" نشان می‌دهد که هیچ محدودیتی بر روی نوع T وجود ندارد.

با تعریف نوع T، می‌توان داده Data را به عنوان یک فیلد از نوع T معرفی کرد که باید در زمان بعدی تعیین شود. فیلدهای next و prev باید به یک گره از همان نوع T اشاره کنند. این اشاره‌گرها به گره بعدی و گره قبلی در لیست پیوندی اشاره دارند. برای ایجاد این ارتباط، فیلدها به عنوان اشاره‌گرها به یک گره اعلام شده‌اند که به نوع T مرتبط است از طریق استفاده از پرانتز مربعی.

    type list[T any] struct {
        first *node[T]
        last *node[T]
    }

نوع ساختاری دوم به نام list است و یک مجموعه از گره‌ها را با اشاره به اولین و آخرین گره در یک لیست نمایان می‌کند. این فیلدها باید به یک گره از نوع T اشاره کنند، به همان شکلی که فیلدهای next و prev از نوع گره هستند.

بار دیگر، شناسه T به عنوان یک نوع ژنریک (که باید در زمان بعدی تعیین شود) تعریف می‌شود که می‌تواند برای هر نوع محسوسی جایگزین شود. سپس فیلدهای اولین و آخرین به عنوان اشاره‌گرهایی به یک گره از نوع T اعلام می‌شوند با استفاده از دستور زبان مربعی.

    func (l *list[T]) add(data T) *node[T] {
        n := node[T]{
            Data: data,
            prev: l.last,
        }
        
        if l.first == nil {
            l.first = &n
            l.last = &n
            return &n
        }

        l.last.next = &n
        l.last = &n
        
        return &n
    }

این یک پیاده‌سازی از یک متد به نام add برای نوع لیست است. اعلام رسمی نوع ژنریک برای لیست (مانند توابع) نیازی ندارد چون متد به لیست از طریق مخزن متصل می‌شود. مخزن متد add به عنوان یک اشاره‌گر به لیستی از نوع T اعلام شده است و بازگشت به عنوان یک اشاره‌گر به یک گره از همان نوع T اعلام شده است.

کد پس از ایجاد یک گره همیشه یکسان خواهد بود، بدون توجه به نوع داده‌ای که در لیست ذخیره می‌شود چرا که این تنها تغییر مکان‌نمایی اشاره‌گر است. تنها ایجاد یک گره است که توسط نوع داده‌ای که مدیریت می‌شود تحت تأثیر قرار می‌گیرد. با توجه به ژنریک‌ها، ایجاد یک گره می‌تواند به نوع T متصل شود که در زمان کامپایل بعدی جایگزین می‌شود.

بدون ژنریک‌ها، کل این متد نیاز به تکرار خواهد داشت چرا که ایجاد یک گره نیاز به کدگذاری سخت به یک نوع معلوم و اعلام شده قبل از کامپایل دارد. از آنجا که میزان کد (برای کل پیاده‌سازی لیست) که برای انواع داده مختلف باید تغییر کند، بسیار کم است، توانایی اعلام یک گره و لیست برای مدیریت داده‌های نوع T هزینه تکرار کد و نگهداری را کاهش می‌دهد.

    type user struct {
        name string
    }
    
    func main() {
        // Store values of type user into the list.
        var lv list[user]
        n1 := lv.add(user{"bill"})
        n2 := lv.add(user{"ale"})
        fmt.Println(n1.Data, n2.Data)
        
        // Store pointers of type user into the list.
        var lp list[*user]
        n3 := lp.add(&user{"bill"})
        n4 := lp.add(&user{"ale"})
        fmt.Println(n3.Data, n4.Data)
    }

خروجی:

    {bill} {ale}
    &{bill} &{ale}

در اینجا یک برنامه کوچک وجود دارد. یک نوع به نام user اعلام شده است و سپس یک لیست به حالت مقدار صفر برای مدیریت مقادیر نوع user ساخته می‌شود. سپس یک لیست دیگر به حالت مقدار صفر ساخته می‌شود و این لیست اشاره‌گرها به مقادیر نوع user را مدیریت می‌کند. تنها تفاوت بین این دو لیست این است که یکی مقادیر نوع user را مدیریت می‌کند و دیگری اشاره‌گرهای نوع user را.

از آنجا که نوع user به طور صریح در زمان ساخت نوع لیست مشخص شده است، متد add به نوبه‌ی خود مقادیر نوع user را می‌پذیرد. از آنجا که یک اشاره‌گر از نوع user به طور صریح در زمان ساخت نوع لیست مشخص شده است، متد add اشاره‌گرهای نوع user را می‌پذیرد.

شما می‌توانید در خروجی برنامه مشاهده کنید که فیلد Data برای گره‌ها در لیست‌های مربوطه با معنای داده مورد استفاده در ساخت تطابق دارد.

** تمرینات

از قالب به عنوان نقطه شروع برای تکمیل تمرینات استفاده کنید. یک راه حل ممکن نیز ارائه شده است.

** تمرین 1

یک نوع ژنریک به نام stack را اعلام کنید که از یک ساختار با یک فیلد به نام data به عنوان یک آرایه از نوع T استفاده می‌کند. یک متد به نام push را اعلام کنید که یک مقدار از نوع T را پذیرفته و این مقدار را به آرایه اضافه می‌کند. یک متد به نام pop را اعلام کنید که آخرین مقدار از نوع T که به آرایه اضافه شده است و یک خطا را برمی‌گرداند. سپس یک تابع اصلی بنویسید که از این متدها استفاده می‌کند.

.play generics/struct-types/exercise1.go 
.play generics/struct-types/answer1.go
