مسائل سرگرم‌کننده

این بخش شامل یک مجموعه از چالش‌های کد سرگرم‌کننده است که برخی از قابلیت‌هایی که Go ارائه می‌دهد را نشان می‌دهند.

* مسئله آرایشگر خواب‌آلود

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][تماشای ویدئو]]
- نیاز به کمک مالی دارید؟ از [[https://www.ardanlabs.com/scholarship/][فرم Scholarship]] ما استفاده کنید.

این برنامه نمونه‌ای از مسئله آرایشگر خواب‌آلود را پیاده‌سازی می‌کند.

- برای اطلاعات بیشتر به این لینک مراجعه کنید: [[https://en.wikipedia.org/wiki/Sleeping_barber_problem][https://en.wikipedia.org/wiki/Sleeping_barber_problem]]

در این مسئله آرایشگاه، یک آرایشگر، یک صندلی آرایشگر و `n` صندلی برای مشتریان منتظر وجود دارد. اگر مشتریانی حاضر نباشند، آرایشگر در صندلی آرایشگر نشسته و خواب می‌کند. مشتری وارد می‌شود و باید آرایشگر را بیدار کند. مشتریانی که بعداً وارد می‌شوند، اگر صندلی ای منتظر باشد، یکی از صندلی‌های منتظر را اشغال می‌کنند و در غیر این صورت آرایشگاه را ترک می‌کنند.

*خروجی:*

    باز کردن آرایشگاه
    آرایشگر آماده به کار است
    مشتری "مشتری-1" به آرایشگاه وارد شد
    مشتری "مشتری-1" صندلی‌ای را انتخاب کرد و منتظر می‌ماند
    آرایشگر در حال خدمت‌دهی به مشتری "مشتری-1" است
    آرایشگر خدمت به مشتری "مشتری-1" را به اتمام رساند
    آرایشگر در حال خوابیدن است
    مشتری "مشتری-2" به آرایشگاه وارد شد
    مشتری "مشتری-2" صندلی‌ای را انتخاب کرد و منتظر می‌ماند
    آرایشگر در حال خدمت‌دهی به مشتری "مشتری-2" است
    مشتری "مشتری-3" به آرایشگاه وارد شد
    مشتری "مشتری-3" صندلی‌ای را انتخاب کرد و منتظر می‌ماند
    آرایشگر خدمت به مشتری "مشتری-2" را به اتمام رساند
    آرایشگر در حال خدمت‌دهی به مشتری "مشتری-3" است
    مشتری "مشتری-4" به آرایشگاه وارد شد
    مشتری "مشتری-4" صندلی‌ای را انتخاب کرد و منتظر می‌ماند
    بستن آرایشگاه
    آرایشگر خدمت به مشتری "مشتری-3" را به اتمام رساند
    آرایشگر در حال خدمت‌دهی به مشتری "مشتری-4" است
    آرایشگر خدمت به مشتری "مشتری-4" را به اتمام رساند
    آرایشگاه بسته شد

.play algorithms/fun/barber.go

* فرکانس

این برنامه نمونه‌هایی ارائه می‌دهد که نشان می‌دهد چگونه یک تابع را پیاده‌سازی کنید که توانایی پیدا کردن فرکانس یک رون (کاراکتر) داده شده که در جمله مشخصی استفاده شده است، را داشته باشد.

- ترتیبی: الگوریتم خطی برای شمارش رون‌ها.
- همزمان: الگوریتم همزمان برای انجام شمارش رون‌ها.

.play algorithms/fun/freq_sequential.go
.play algorithms/fun/freq_concurrent.go

*  رمزگذاری/رمزگشایی متغیر طول

این برنامه نمونه‌ای ارائه می‌دهد که نشان می‌دهد چگونه Go می‌تواند برای پیاده‌سازی رمزگذاری/رمزگشایی متغیر طول مورد استفاده قرار گیرد.

- برای اطلاعات بیشتر به این لینک مراجعه کنید:  [[https://en.wikipedia.org/wiki/Variable-length_code][https://en.wikipedia.org/wiki/Variable-length_code]]

به طور خلاصه، هدف از این رمزگذاری این است که اعداد صحیح را به گونه‌ای کدگذاری کند که باعث صرفه‌جویی در بایت‌ها شود. تنها 7 بیت اول هر بایت معنی دارند (از راست چین؛ مشابه یک بایت ASCII). بنابراین، اگر یک مقدار 32 بیتی داشته باشید، باید آن را به سری بایت‌های 7 بیتی تجزیه کنید. البته، تعداد متغیری از بایت‌ها خواهید داشت که به مقدار صحیح شما بستگی دارد. برای نشان دادن کدام بایت آخرین بایت در سری است، باید بیت #7 را خاموش (0) بگذارید. در تمام بایت‌های پیشین، بایت #7 را روشن (1) می‌کنید.

بنابراین، اگر یک عدد صحیح بین 0 تا 127 باشد، می‌تواند به عنوان یک بایت نمایش داده شود. بزرگترین عدد مجاز برابر با 0FFFFFFF است که معادل 4 بایت متغیر طول می‌شود. در زیر نمونه‌هایی از مقادیر 32 بیتی به عنوان زمان‌های دلتا و مقادیر متغیر طولی که به آنها ترجمه می‌شوند آورده شده است:

       متغیر تعداد              عدد
    00000000              00
    00000040              40
    0000007F              7F
    00000080             81 00
    00002000             C0 00
    00003FFF             FF 7F
    00004000           81 80 00
    00100000           C0 80 00
    001FFFFF           FF FF 7F
    00200000          81 80 80 00
    08000000          C0 80 80 00
    0FFFFFFF          FF FF FF 7F

یک متغیر تعداد (VLQ) کد یکانیورسال است که از تعداد خودسرانه‌ای از اکتت‌های دودویی (بایت‌های 8 بیتی) برای نمایش یک عدد صحیح به طور خودسرانه‌ای استفاده می‌کند. این کد برای استفاده در قالب فایل معمولی میدی استفاده شد تا برای یک سیستم با محدودیت منابع فضای اضافی ذخیره کند و همچنین در فرمت موسیقی قابل توسعه (XMF) نیز استفاده می‌شود. یک VLQ در اصل نمایش یک عدد صحیح بدون علامت با اساس 128 است با اضافه کردن بیت هشتم برای نشان دادن ادامه بایت‌ها. نمونه زیر را ببینید.

	Int:    16384
	IntHex: 0x00004000
	IntBin: 00000000 00000000 01000000 00000000
	VLQHex: 0x81 0x80 0x00
	VLQBin: 00000000 10000001 10000000 00000000

بیایید فرض کنیم می‌خواهیم عدد 3435 را با استفاده از VLQ نمایش دهیم. عدد 3435 به صورت دودویی برابر با 110101101011 است. این را نمی‌توانیم به صورت کامل در یک بایت نمایش دهیم. بنابراین، می‌خواهیم آن را از انتها به صورت بلوک‌های 7 بیتی تقسیم کنیم.

    Septet	7	6	5	4	3	2	1
    #1		1	1	0	1	0	1	1
    #2		0	0	1	1	0	1	0


حالا به همه‌ی بلوک‌ها علاوه بر آخرین بلوک، یک بیت 1 را در ابتدای آنها اضافه می‌کنیم تا نشان دهیم که یک اکتت پیگیری می‌شود و یک بیت 0 به آخرین بلوک اضافه می‌کنیم تا نشان دهیم که این آخرین اکتت است.

    Octet   8	7	6	5	4	3	2	1
    #1      0	1	1	0	1	0	1	1
    #2      1	0	0	1	1	0	1	0

سرانجام، این دو بلوک را به هم چسبانده، با اولین اکتت مهم‌ترین را ابتدا، به شکل زیر نمایش می‌دهیم:

Encoded: 10011010 01101011  ToHex: 0x9A 0x6B

*منابع* *اضافی:*

- [[https://en.wikipedia.org/wiki/Variable-length_quantity][https://en.wikipedia.org/wiki/Variable-length_quantity]]
- [[https://blogs.infosupport.com/a-primer-on-vlq/][https://blogs.infosupport.com/a-primer-on-vlq/]]

*کنید* *برای* *پیاده* *سازی* *عالی* *این* *الگوریتم* *به* *اینجا* *نگاه:*

- [[https://github.com/go-audio/midi/blob/master/varint.go][https://github.com/go-audio/midi/blob/master/varint.go]]

.play algorithms/fun/vlq.go