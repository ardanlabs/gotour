Interfaces (ربط ها)
رابط‌ها به برنامه‌ها ساختار می‌دهند و طراحی توسط ترکیب را تشویق می‌کنند.

* Interfaces (ربط ها)

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][تماشای ویدئو]]
- نیاز به کمک مالی دارید؟ از [[https://www.ardanlabs.com/scholarship/][فرم Scholarship]] ما استفاده کنید.

رابط‌ها به برنامه‌ها ساختار می‌دهند و طراحی توسط ترکیب را تشویق می‌کنند. آنها امکان ایجاد تقسیم‌بندی‌های تمیز و اجباری بین اجزا را ممکن می‌سازند. استاندارد‌سازی رابط‌ها می‌تواند انتظارات واضح و یکپارچه را مشخص کند. جداکنندگی به معنای کاهش وابستگی‌ها بین اجزا و انواعی که استفاده می‌کنند است. این منجر به صحت، کیفیت و قابلیت نگهداری می‌شود.

** مرور کد

- *مثال* *1:* کد تکراری که نیاز به چندشکلی دارد
- *مثال* *2:* چندشکلی
- *مثال* *3:* مجموعه متدها
- *مثال* *4:* آدرس مقدار
- *مثال* *5:* ذخیره‌سازی توسط مقدار
- *مثال* *6:* تایید انواع
- *مثال* *7:* تایید‌های شرطی نوع
- *مثال* *8:* رابط خالی و کلیدهای تعویض نوع
- *مثال* *9:* ذخیره مقادیر

.play interfaces/example1.go
.play interfaces/example2.go
.play interfaces/example3.go
.play interfaces/example4.go
.play interfaces/example5.go
.play interfaces/example6.go
.play interfaces/example7.go
.play interfaces/example8.go
.play interfaces/example9.go

** مفاهیم رابط

رابط‌ها به شما اجازه می‌دهند داده‌های واقعی را براساس آنچه که داده‌ها می‌توانند انجام دهند، گروه‌بندی کنید. این موضوع در مورد تمرکز بر روی این است که داده‌ها چه کارهایی انجام می‌دهند و نه اینکه داده‌ها چه هستند. رابط‌ها همچنین به کد من کمک می‌کنند تا از تغییرات خود جدا شود، زیرا براساس آنچه که داده می‌تواند انجام دهد، درخواست داده‌های واقعی می‌کند. این محدود به یک نوع داده نیست.

باید بهترین تلاش‌های خود را بکنم تا درک کنم که چه تغییراتی در داده‌ها در راه است و از رابط‌ها برای جدا کردن برنامه خود از آن تغییرات استفاده کنم. رابط‌ها باید رفتار را توصیف کنند و نه وضعیت. آنها باید فعل باشند و نه اسم.

رابط‌های عمومی که بر روی رفتار تمرکز دارند بهترین‌اند. رابط‌هایی که بیش از یک متد دارند، بیش از یک دلیل برای تغییر دارند. رابط‌هایی که بر اساس اسم‌هاست، تمایل به استفاده کمتر از مجدد، بیشتر به تغییرات حساس هستند و مفهوم رابط را از بین می‌برند. ابهام در مورد تغییر، مجوز حدس زدن نیست بلکه دستور به توقف و یادگیری بیشتر است. باید بین کدی که در مقابل تقلب دفاع می‌کند و کدی که در مقابل تصادفات محافظت می‌کند، تمییز قائل شوید.

زمانی از رابط استفاده کنید که:

- کاربران API نیاز به ارائه جزئیات اجرایی دارند.
- API‌ها چندین اجرای داخلی نیاز به نگهداری دارند.
- بخش‌هایی از API که ممکن است تغییر کنند شناسایی شده‌اند و نیاز به جداکردن دارند.

** استفاده از رابط

رابط را به دلیل استفاده از یک رابط به کار نبرید:

- به خاطر استفاده از یک رابط.
- برای عمومی‌سازی یک الگوریتم.
- زمانی که کاربران می‌توانند رابط‌های خود را اعلام کنند.
- اگر واضح نباشد که رابط چگونه کد را بهبود می‌بخشد.

** رابط‌ها بی ارزش هستند

اولین مورد مهمی که باید درک کنید این است که یک نوع رابط یک نوع بی ارزش (valueless) را اعلام می‌کند.

    type reader interface {
        read(b []byte) (int, error)
    }

نوع `reader` یک نوع رابط نیست، بلکه یک نوع رابط است. اعلام آن بر اساس ویژگی‌ها نیست بلکه بر اساس رفتار است. نوع‌های رابط یک مجموعه متدهای رفتاری را اعلام می‌کنند که داده‌های محسوب‌شونده باید آن را اجرا کنند تا رابط را برآورده کنند. در مورد نوع‌های رابط، هیچ چیز متمایزی وجود ندارد، بنابراین بی ارزش هستند.

    var r reader

به علت بی‌ارزش بودن آن‌ها، ساخت متغیر (مانند r) عجیب است زیرا در مدل برنامه‌نویسی ما، r وجود ندارد، بی ارزش است. هیچ چیز درباره r به تنهایی وجود ندارد که بتوانید آن را مدیریت یا تغییر دهید. این یک مفهوم بسیار مهم است که باید درک شود. من هرگز با مقادیر رابط کار نمی‌کنم، فقط با مقادیر محسوب می‌شوند. رابط دارای یک نمایشگر کامپایلر (نوع داخلی) دارد، اما از مدل برنامه‌نویسی ما، رابط‌ها بی ارزش هستند.

** پیاده‌سازی رابط‌ها

Go یک زبان است که در آن کنوانسیون بر کانفیگوریشن غلبه دارد. وقتی به پیاده‌سازی یک نوع محسوب‌شونده در یک رابط می‌آید، هیچ استثناءی وجود ندارد.

    type reader interface {
        read(b []byte) (int, error)
    }

    type file struct {
        name string
    }

    func (file) read(b []byte) (int, error) {
        s := "<rss><channel><title>Going Go</title></channel></rss>"
        copy(b, s)
        return len(s), nil
    }

کد یک نوع به نام "file" اعلام می‌کند و سپس یک متد به نام "read" اعلام می‌کند. به علت این دو اعلامیه، می‌توانید این را بگویید:

"نوع محسوب‌شونده "file" اکنون رابط "reader" را با استفاده از سمانتیک مقدار اجرا می‌کند."

هر کلمه گفته شده مهم است. در Go، تنها کافیست مجموعه کامل متدهای رفتاری توسط یک رابط تعریف شده را اعلام کنید تا آن رابط را پیاده‌سازی کنید. در این مورد، همین کار را کرده‌ام زیرا رابط "reader" تنها یک عمل رفتاری به نام "read" را اعلام می‌کند.

    type reader interface {
        read(b []byte) (int, error)
    }

    type pipe struct {
        name string
    }

    func (pipe) read(b []byte) (int, error) {
        s := `{name: "Bill", title: "developer"}`
        copy(b, s)
        return len(s), nil
    }

در این کد، یک نوع به نام "pipe" اعلام شده و سپس یک متد با نام "read" اعلام شده است. به دلیل این دو اعلامیه، می‌توانید موارد زیر را بگویید:

"نوع محسوب‌شونده "pipe" اکنون رابط "reader" را با استفاده از سمانتیک مقدار اجرا می‌کند."

اکنون شما دو نوع محسوب‌شونده دارید که هر یک از آن‌ها پیاده‌سازی منحصربه‌فرد خود را برای رابط "reader" دارند. دو نوع محسوب‌شونده، هر یک با پیاده‌سازی خود، یکی برای خواندن سیستم‌های فایل و دیگری برای شبکه‌ها.

** چندوجودی

چندوجودی به معنای این است که یک قسمت کد بر اساس داده محسوب‌شونده که بر روی آن عمل می‌کند، رفتار خود را تغییر می‌دهد. این تعریف توسط تام کورتز، مخترع زبان برنامه‌نویسی BASIC، ارائه شده است. این تعریف را در ادامه استفاده خواهیم کرد.

    // retrieve can read any device and process the data.
    func retrieve(r reader) error {
        data := make([]byte, 100)

        len, err := r.read(data)
        if err != nil {
            return err
        }

        fmt.Println(string(data[:len]))
        return nil
    }

نگاهی به نوع داده‌ای که این تابع می‌پذیرد بیندازید. این تابع یک مقدار از نوع "reader" می‌خواهد. این امکان وجود ندارد زیرا "reader" یک رابط است و رابط‌ها از نوع‌های بدون مقدار هستند. نمی‌تواند بخواهد یک مقدار "reader"، چرا که چنین مقادیری وجود ندارند.

اگر این تابع درخواستی برای یک مقدار "reader" نمی‌کند، پس تابع درخواستی برای چه چیزی دارد؟ این تابع برای تنها چیزی درخواست دارد که می‌تواند درخواست دهد، یعنی داده محسوب‌شونده.

تابع "retrieve" تابع چندوجودی است زیرا درخواست می‌کند داده محسوب‌شونده را بر اساس اینکه داده چیست (نوع محسوب‌شونده) نه بر اساس اینکه داده چه کارهایی انجام می‌دهد (نوع رابط)، برایش فرستاده شود.

    f := file{"data.json"}
    p := pipe{"cfg_service"}

    retrieve(f)
    retrieve(p)

شما می‌توانید دو مقدار محسوب‌شونده بسازید، یکی از نوع "file" و دیگری از نوع "pipe". سپس می‌توانید یک کپی از هر مقدار را به تابع چندوجودی ارسال کنید. این به این دلیل است که هر یک از این مقادیر تمام مجموعه‌ی متد‌های رفتاری تعریف‌شده توسط رابط "reader" را پیاده‌سازی می‌کنند.

وقتی که مقدار محسوب‌شونده "file" به تابع "retrieve" ارسال می‌شود، مقدار در داخل یک نوع داده داخلی با دو کلمه کلیدی ذخیره می‌شود که نمایانگر مقدار رابطی است.

.image /tour/eng/static/img/i1.png

در واقعیت، داده‌ی رابط از دو کلمه کلیدی تشکیل شده است. کلمه کلیدی دوم به مقدار ذخیره‌شده اشاره می‌کند. در این مورد، این یک کپی از مقدار "file" است چرا که رفتار رفتاری مقدار در حال اجرا است. کلمه کلیدی اول به یک ساختار داده‌ای ویژه اشاره می‌کند که به نام iTable معروف است.

iTable دو مقصد دارد:

- این توصیف می‌کند که نوع مقداری که در حال ذخیره است چیست. در این مورد، این یک مقدار "file" است.
- این اسامی تابع به اشکال اجرایی متدهای مجموعه‌ی متدهای مربوط به نوع مقداری که در حال ذخیره است، ارائه می‌دهد.

وقتی تماس به متد "read" علیه مقدار رابطی انجام می‌شود، یک جستجوی iTable انجام می‌شود تا پیاده‌سازی محکم مربوط به متد "read" مرتبط با نوع  زیر پیدا شود. سپس تماس به متد بر روی مقداری که در کلمه دوم ذخیره شده است، انجام می‌شود.

می‌توانید بگویید که "retrieve" یک تابع چندوجودی است چرا که مقدار محاسبه‌شونده "pipe" می‌تواند به "retrieve" ارسال شود و در این صورت تماس به "read" علیه مقدار رابطی تغییر رفتار می‌دهد. در این مورد، تماس به "read" در حالتی دیگر است که این بار از شبکه به جای خواندن یک فایل است.

** قوانین مجموعه متدها

پیاده‌سازی یک رابط با استفاده از رفتار رفتاری برخی محدودیت‌ها را در خصوص پایداری رابط اعمال می‌کند.

    type notifier interface {
        notify()
    }

    type user struct {
        name  string
        email string
    }

    func (u *user) notify() {
        fmt.Printf("Sending User Email To %s<%s>\n", u.name, u.email)
    }

    func sendNotification(n notifier) {
        n.notify()
    }

    func main() {
        u := user{"Bill", "bill@email.com"}
        sendNotification(u)
    }

رابط notifier توسط نوع کاربر با استفاده از رفتار نشانگر اجرا می‌شود. وقتی از رفتار مقداری برای تماس چندوجودی استفاده می‌شود، پیام کامپایلر زیر تولید می‌شود.

    "cannot use u (type user) as type notifier in argument to sendNotification:
    user does not implement notifier (notify method has pointer receiver)"

این به این دلیل است که در مشخصات مربوط به مجموعه متدها مجموعه‌ای خاص از قوانین وجود دارد. این قوانین تعریف می‌کنند کدام متدها به مقدار و اشاره‌گر نوعی وابسته هستند. این‌ها برای حفظ بالاترین سطح از اعتبار در برنامه‌ام استفاده می‌شوند.

این قوانین در مشخصات تعریف شده‌اند:

- برای هر مقدار از نوع T، تنها متدهایی که با یک نشانگر مقدار برای آن نوع پیاده‌سازی شده‌اند، به مجموعه متدهای آن مقدار تعلق دارند.
- برای هر آدرس از نوع T، تمام متدهای پیاده‌سازی شده برای آن نوع به مجموعه متدهای آن مقدار تعلق دارند.

به عبارت دیگر، هنگامی که با یک آدرس (اشاره‌گر) کار می‌کنید، تمام متدهای پیاده‌سازی شده به آن وابسته و قابل فراخوانی هستند. هنگام کار با یک مقدار، تنها متدهای پیاده‌سازی شده با نشانگر مقدار وابسته و قابل فراخوانی هستند.

در درس قبل در مورد متدها، شما می‌توانستید یک متد را بر روی یک قطعه داده محاسبه کنید بدون در نظر گرفتن رفتار داده که توسط نشانگر اعلام می‌شود. این به این دلیل است که کامپایلر می‌تواند تنظیمات را تغییر دهد تا تماس متد را انجام دهد. در این مورد، یک مقدار درون یک رابط ذخیره می‌شود و متدها باید وجود داشته باشند. هیچ تنظیماتی انجام نمی‌شود.

سوال اکنون این است: چرا متدهای پیاده‌سازی شده با نشانگرهای اشاره‌گر به مقادیر نوع T وابسته نمی‌شوند؟ در اینجا چه مشکلی در اعتبار وجود دارد؟

یکی از دلایل این است که نمی‌توانید تضمین کنید که هر مقدار از نوع T قابل دسترسی باشد. اگر یک مقدار آدرس نداشته باشد، نمی‌تواند به اشتراک گذاشته شود.

    type duration int

    func (d *duration) notify() {
            fmt.Println("Sending Notification in", *d)
    }

    func main() {
        duration(42).notify()
    }

خطای کامپایلر:

    cannot call pointer method on duration(42)
    cannot take the address of duration(42)

در این مثال، مقدار 42 یک ثابت از نوع int است. با این وجود، این مقدار به یک مقدار از نوع duration تبدیل می‌شود، اما درون یک متغیر ذخیره نمی‌شود. این به این معناست که مقدار هرگز درون استک یا هیپ نیست. هیچ آدرسی وجود ندارد. ثابت‌ها تنها در زمان کامپایل زنده هستند.

دلیل دوم بزرگتر است. کامپایلر به شما می‌گوید که نمی‌توانید از رفتار مقداری استفاده کنید اگر انتخاب کرده‌اید که از رفتار نشانگری استفاده کنید. به عبارت دیگر، شما مجبور به به اشتراک گذاری مقدار با رابط می‌شوید زیرا کپی کردن یک مقداری که یک اشاره‌گر به آن اشاره می‌کند، ایمن نیست. اگر انتخاب کرده‌اید که متد را با رفتار نشانگری پیاده‌سازی کنید، دارید اعلام می‌کنید که مقداری از این نوع ایمن نیست که کپی شود.

    func main() {
        u := user{"Bill", "bill@email.com"}
        sendNotification(&u)
    }

برای رفع پیام کامپایلر، شما باید رفتار نشانگری را در تماس با تابع چندوجهی استفاده کرده و مقدار u را به اشتراک بگذارید. پاسخ این نیست که متد را به رفتار مقداری تغییر دهید.

** آرایه نشانگرها

زمانی که یک آرایه از نوع رابط تعریف می‌کنید، من قادر به گروه‌بندی مقادیر مختلف از نوع‌های مختلف با توجه به اینکه چه کارهایی می‌توانند انجام دهند، هستم. این دلیلی است که Go به مفهوم زیرنوعی نیاز ندارد. این موضوع درباره DNA مشترک نیست، بلکه درباره رفتار مشترک است.

    type printer interface {
        print()
    }

    type canon struct {
        name string
    }

    func (c canon) print() {
        fmt.Printf("Printer Name: %s\n", c.name)
    }

    type epson struct {
        name string
    }

    func (e *epson) print() {
        fmt.Printf("Printer Name: %s\n", e.name)
    }

    func main() {
        c := canon{"PIXMA TR4520"}
        e := epson{"WorkForce Pro WF-3720"}

        printers := []printer{
            c,
            &e,
        }
        c.name = "PROGRAF PRO-1000"
        e.name = "Home XP-4100"

        for _, p := range printers {
            p.print()
        }
    }

خروجی:

    Printer Name: PIXMA TR4520
    Printer Name: Home XP-4100

کد نشان می‌دهد که چگونه یک آرایه از نوع رابط printer به من اجازه می‌دهد مجموعه‌ای از نوع‌های مختلف چاپگر را ایجاد کنم. با گردش در مجموعه و بهره‌بردن از چندوجهی، زیرا تماس با p.print به تغییر رفتار خود می‌پردازد بسته به مقدار مختلفی که کد با آن عمل می‌کند.

این مثال همچنین نشان می‌دهد که انتخاب رفتار داده چگونه رفتار برنامه را تغییر می‌دهد. وقتی داده با استفاده از رفتار مقداری ذخیره می‌شود، تغییرات در مقدار اصلی دیده نمی‌شوند. این به این دلیل است که یک کپی در داخل رابط ذخیره می‌شود. هنگامی که رفتار نشانگرها استفاده می‌شود، تمام تغییرات در مقدار اصلی دیده می‌شوند.

** یادداشت‌ها

- مجموعه متد برای یک مقدار، تنها شامل متد‌هایی است که با گیرنده مقداری پیاده‌سازی شده‌اند.
- مجموعه متد برای یک نشانگر، شامل متد‌هایی است که با گیرنده‌های هم مقدار و هم نشانگر پیاده‌سازی شده‌اند.
- متد‌هایی که با گیرنده نشانگر اعلام شده‌اند، تنها با مقادیر نشانگر رابط پیاده‌سازی می‌شوند.
- متد‌های اعلام شده با گیرنده مقداری، رابط را با هم مقدار و هم نشانگر پیاده‌سازی می‌کنند.
- قوانین مجموعه متد برای انواع رابط اعمال می‌شوند.
- رابط‌ها از نوع مرجع هستند، با نشانگر به اشتراک گذاشته نشود.
- این چگونگی ایجاد رفتار چندوجهی در Go است.

** نقل قول‌ها

"چندوجهی به این معناست که شما یک برنامه خاصی را می‌نویسید و بسته به داده‌هایی که بر روی آن عمل می‌کند، رفتار متفاوتی از خود نشان می‌دهد." - تام کورتز (مخترع BASIC)

"رابط خالی چیزی نمی‌گوید." - راب پایک

"طراحی هنر ترتیب دادن کد به نحوی است که امروز کار کند و همیشه قابل تغییر باشد." - سندی متز

"یک انتزاع مناسب، کد را به نحوی از یکدیگر جدا می‌کند که هر تغییری به سراسر پایگاه کد نخورد." - رونا استاینبرگ

** خواندن اضافی

- [[https://golang.org/doc/effective_go.html#interfaces][Interfaces]]    
- [[https://blog.golang.org/laws-of-reflection][The Laws of Reflection]] - Rob Pike    
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methods, Interfaces and Embedded Types in Go]] - William Kennedy    
- [[https://rakyll.org/interface-pollution/][Interface Pollution]] - JBD    
- [[https://bravenewgeek.com/abstraction-considered-harmful/][Abstraction Considered Harmful]] - Tyler Treat    
- [[https://www.ardanlabs.com/blog/2018/03/interface-values-are-valueless.html][Interface Values Are Valueless]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2017/07/interface-semantics.html][Interface Semantics]] - William Kennedy    
- [[https://www.hyrumslaw.com/][Hyrum's Law]] - Hyrum  
- [[https://www.youtube.com/watch?v=Pjz9WrXeOW0][Engineering Innovation - Why Constraints Are Critical]] - André Eriksson (MUST WATCH)

** تمرینات

از قالب به عنوان نقطه شروع برای انجام تمرینات استفاده کنید. یک راه حل ممکن نیز ارائه شده است.

** تمرین 1

* بخش A: ابتدا یک رابط با نام speaker و یک متد به نام speak اعلام کنید. یک ساختار به نام english اعلام کنید که یک شخصی را نمایش می‌دهد که انگلیسی صحبت می‌کند و یک ساختار به نام chinese برای شخصی که چینی صحبت می‌کند. رابط speaker را برای هر یک از ساختارها با استفاده از گیرنده مقداری و این رشته‌های حرفه‌ای "Hello World" و "你好世界" پیاده‌سازی کنید. یک متغیر از نوع speaker اعلام کنید و آدرس یک مقدار از نوع english را اختصاص دهید و متد را فراخوانی کنید. این کار را برای یک مقدار از نوع chinese دوباره انجام دهید.

* بخش B: یک تابع جدید به نام sayHello اضافه کنید که یک مقدار از نوع speaker را قبول کند. این تابع را به گونه‌ای پیاده‌سازی کنید که متد speak را روی مقدار رابط فراخوانی کند. سپس مقادیر جدیدی از هر نوع ایجاد کرده و از تابع استفاده کنید.

.play interfaces/exercise1.go
.play interfaces/answer1.go
