گروه‌بندی با نوع‌ها
مهم است به یاد داشته باشیم که در Go، مفاهیم زیرنوع‌بندی یا زیرکلاس‌بندی در واقع وجود ندارند و این الگوهای طراحی باید اجتناب شود.

* گروه‌بندی با نوع‌ها

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][تماشای ویدئو]]
- نیاز به کمک مالی دارید؟ از [[https://www.ardanlabs.com/scholarship/][فرم Scholarship]] ما استفاده کنید.

مهم است به یاد داشته باشیم که در Go، مفاهیم زیرنوع‌بندی یا زیرکلاس‌بندی واقعاً وجود ندارند و این الگوهای طراحی باید اجتناب شود.

** بررسی کد

- *مثال* *1:* گروه‌بندی بر اساس وضعیت
- *مثال* *2:* گروه‌بندی بر اساس رفتار

.play composition/grouping/example1.go
.play composition/grouping/example2.go

** گروه‌بندی انواع مختلف داده‌ها

مهم است به یاد داشته باشیم که در Go، مفاهیم زیرنوع‌بندی یا زیرکلاس‌بندی واقعاً وجود ندارند و این الگوهای طراحی باید اجتناب شود.

مورد زیر الگوی ضد-الگویی است که نباید دنبال کرده یا پیاده‌سازی کنید.

    type Animal struct {
        Name string
        IsMammal bool
    }

نوع Animal به عنوان یک نوع پایه اعلام شده است که سعی در تعریف داده‌هایی دارد که مشترک برای تمام حیوانات هستند. همچنین سعی می‌کنید برخی از رفتارهای مشترک را نیز برای یک حیوان فراهم کنید.

    func (a *Animal) Speak() {
        fmt.Println("UGH!",
        "My name is", a.Name, ", it is", a.IsMammal, "I am a mammal")
    }

بیشتر حیوانات قابلیت صحبت کردن به یک شکل یا شکل دیگر را دارند. با این حال، سعی در اعمال این رفتار مشترک فقط بر روی یک حیوان هیچ معنایی ندارد. در این نقطه، شما هیچ اطلاعاتی در مورد صدایی که این حیوان تولید می‌کند ندارید، بنابراین UGH را می‌نویسید.

    type Dog struct {
        Animal
        PackFactor int
    }

حالا مشکلات واقعی آغاز می‌شوند. من سعی می‌کنم با استفاده از تعبیه (embedding)، یک سگ همه چیزی که یک حیوان است و همچنین بیشتر از آن باشد. به نظر می‌رسد در ابتدا این روش کار می‌کند، اما مشکلاتی وجود خواهد داشت. با این حال، یک سگ یک روش خاص برای صحبت کردن دارد.

    func (d *Dog) Speak() {
        fmt.Println("Woof!",
            "My name is", d.Name,
            ", it is", d.IsMammal,
            "I am a mammal with a pack factor of", d.PackFactor)
    }

در پیاده‌سازی روش Speak، شما می‌توانید UGH را با Woof جایگزین کنید. این مربوط به نحوه صحبت کردن سگ است.

    type Cat struct {
        Animal
        ClimbFactor int
    }

اگر قرار است یک سگ داشته باشم که یک حیوان را نمایندگی کند، آنگاه باید یک گربه هم داشته باشم. با استفاده از تعبیه، یک گربه همه چیزی است که یک حیوان هست و همچنین بیشتر از آن.

    func (c *Cat) Speak() {
        fmt.Println("Meow!",
            "My name is", c.Name,
            ", it is", c.IsMammal,
            "I am a mammal with a climb factor of", c.ClimbFactor)
    }

در پیاده‌سازی روش Speak، شما می‌توانید UGH را با Meow جایگزین کنید. این مربوط به نحوه صحبت کردن یک گربه است.

همه چیز به نظر می‌رسد خوب است و به نظر می‌رسد تعبیه (embedding) همان قابلیت‌های وراثت را که در زبان‌های دیگر دارد، ارائه می‌دهد. سپس شما سعی می‌کنید به جلو بروید و سگ‌ها و گربه‌ها را بر اساس واقعیتی که یک DNA مشترک به عنوان یک حیوان دارند، گروه‌بندی کنید.

    animals := []Animal{
        Dog{
            Animal: Animal{
                Name: "Fido",
                IsMammal: true,
            },
            PackFactor: 5,
        },
    
        Cat{
            Animal: Animal{
                Name: "Milo",
                IsMammal: true,
            },
            ClimbFactor: 4,
        },
    }

    for _, animal := range animals {
        animal.Speak()
    }

وقتی سعی می‌کنید این کار را انجام دهید، کامپایلر اعتراض می‌کند که یک سگ و یک گربه حیوان نیستند و این درست است. تعبیه (embedding) همان وراثت نیست و این الگویی است که باید از آن دوری کنم. یک سگ یک سگ است، یک گربه یک گربه است و یک حیوان یک حیوان است. نمی‌توانم سگ‌ها و گربه‌ها را به عنوان حیوانات منتقل کنم زیرا آن‌ها حیوان نیستند.

این نوع مکانیک همچنین بسیار انعطاف‌پذیر نیست. آن نیاز به پیکربندی توسط توسعه‌دهنده دارد و مگر اینکه به کد دسترسی داشته باشید، نمی‌توانید تغییرات پیکربندی را در طول زمان اعمال کنید.

اگر این روش نباشد که می‌توانیم مجموعه‌ای از سگ‌ها و گربه‌ها را بسازیم، در Go چگونه این کار را انجام دهیم؟ این مورد مربوط به گروه‌بندی از طریق رفتار مشترک است نه از طریق DNA مشترک. رفتار کلید است.

    type Speaker interface {
        Speak()
    }

اگر از یک رابطه (interface) استفاده کنید، می‌توانید مجموعه‌ی متدهای مشترک رفتاری که می‌خواهید انواع مختلف داده را بر اساس آن گروه‌بندی کنید، تعریف کنید.

    speakers := []Speaker{
        &Dog{
            Animal: Animal{
                Name: "Fido",
                IsMammal: true,
            },
            PackFactor: 5,
        },
        &Cat{
            Animal: Animal{
                Name: "Milo",
                IsMammal: true,
            },
            ClimbFactor: 4,
        },
    }

    for _, speaker := range speakers {
        speaker.Speak()
    }

در کد جدید، اکنون می‌توانید سگ‌ها و گربه‌ها را بر اساس مجموعه‌ی مشترک رفتاری‌شان، که صحبت کردن است، گروه‌بندی کنید.

در واقع، نوع Animal واقعاً آلودگی نوع (type pollution) است زیرا اعلام یک نوع فقط برای به اشتراک گذاشتن مجموعه‌ای از وضعیت‌های مشترک، نقصی است و باید اجتناب شود.

    type Dog struct {
        Name string
        IsMammal bool
        PackFactor int
    }
    
    type Cat struct {
        Name string
        IsMammal bool
        ClimbFactor int
    }

در این مورد خاص، ترجیح می‌دهید نوع Animal حذف شود و فیلدها در نوع‌های Dog و Cat کپی و الصق شوند. بعدها نکاتی درباره الگوهای بهتری که این سناریوها را از بین می‌برند، بررسی خواهید کرد.

این‌ها هستند نقاط ضعف کد اصلی:

- نوع Animal یک لایه انتزاعی از وضعیت قابل استفاده مجدد فراهم می‌کند.
- برنامه هرگز نیاز به ایجاد یا استفاده انحصاری از مقدار نوع Animal ندارد.
- پیاده‌سازی روش Speak برای نوع Animal به صورت عمومی است.
- روش Speak برای نوع Animal هرگز فراخوانی نخواهد شد.

دستورالعمل‌های مربوط به اعلام نوع:

- نوع‌ها را برای نمایانگر چیزی جدید یا منحصربه‌فرد تعریف کنید.
- فقط برای خوانایی، نوع‌های مستعار ایجاد نکنید.
- تأیید کنید که مقدار هر نوع به تنهایی ایجاد یا استفاده می‌شود.
- نوع‌ها را تعبیه نکنید فقط به این دلیل که به وضعیت نیاز داریم، بلکه به این دلیل که به رفتار نیاز داریم.
- اگر درباره رفتار فکر نمی‌کنید، خود را در طراحی قفل کرده‌اید که نمی‌توانید در آینده بدون تغییرات کد پیوسته رشد کنید.
- نوع‌هایی که مستعارها یا انتزاعاتی برای یک نوع موجود هستند، مورد سؤال قرار دهید.
- نوع‌هایی که هدف اصلی آن‌ها به اشتراک گذاشتن مجموعه‌ای از وضعیت‌های مشترک است، مورد سؤال قرار دهید.

** با رابطه‌ها طراحی نکنید

متأسفانه، بسیاری از توسعه‌دهندگان تلاش می‌کنند ابتدا مسائل را به صورت انتزاعی حل کنند. آن‌ها بلافاصله بر روی رابطه‌ها تمرکز می‌کنند و این باعث آلودگی رابطه می‌شود. به عنوان یک توسعه‌دهنده، شما در یکی از دو حالت وجود دارید: برنامه‌نویس و سپس مهندس.

وقتی برنامه‌نویسی می‌کنید، تمرکزتان بر روی کار کردن یک قطعه کد است. تلاش برای حل مسئله و شکستن موانع. اثبات اینکه ادر این مورد خاص، بهتر است نوع Animal حذف شود و فیلدها در نوع‌های Dog و Cat کپی و الصق شوند. در ادامه، یادداشت‌هایی درباره الگوهای بهتری که این سناریوها را از بین می‌برند، خواهید داشت.

وقتی شما در حال برنامه‌نویسی هستید، تمرکزتان بر روی کار کردن یک قطعه کد است. تلاش برای حل مسئله و شکستن موانع. اثبات اینکه ایده‌های اولیه من جواب می‌دهد. همین چیزی است که مهم است. این برنامه‌نویسی باید در قالبی محکم انجام شود و هرگز آماده استفاده تولیدی نیست.

وقتی یک پروتوتایپ از کدی که مسئله را حل می‌کند دارید، باید به حالت مهندسی تغییر کنید. باید بر روی نحوه نوشتن کد در سطح میکرو برای معناشناسی داده و خوانایی، و سپس در سطح ماکرو برای مدلهای ذهنی و قابلیت ادامه کار تمرکز کنید. همچنین باید بر روی خطاها و وضعیت‌های شکست تمرکز کنید.

این کار در یک چرخه بازطراحی انجام می‌شود. بازطراحی برای خوانایی، کارآیی، انتزاع و قابلیت آزمون. انتزاع فقط یکی از چندین بازطراحی است که باید انجام شود. این کار بهترین نتیجه را زمانی می‌دهد که با یک قطعه کد محکم شروع کنید و سپس رابطه‌هایی که نیاز دارید را کشف کنید. انتزاع را اعمال نکنید مگر اینکه به طور مطلق ضروری باشد.

هر مسئله‌ای که با کد حل می‌کنید، یک مسئله داده است که نیازمند نوشتن تبدیلات داده است. اگر داده را نفهمیدید، مسئله را نفهمیدید. اگر مسئله را نفهمیدید، نمی‌توانید هیچ کدی بنویسید. شروع با یک راه‌حل محکم که بر اساس ساختارهای داده محکم است، بسیار حائز اهمیت است. همانطور که راب پایک گفت:

"داده حاکم است. اگر ساختارهای داده صحیح را انتخاب و سازماندهی کنید، الگوریتم‌ها تقریباً همیشه روشن خواهند بود." - راب پایک

کی انتزاع ضروری است؟ زمانی که در کد یک نقطه را مشاهده می‌کنید که داده ممکن است تغییر کند و می‌خواهید اثرات کد پیوسته که نتیجه آن خواهد بود را کمینه کنید. ممکن است از انتزاع برای کمک به قابلیت آزمون کردن کد استفاده کنم، اما اگر امکان دارد باید سعی کنید از آن پرهیز کنید. بهترین توابع قابل آزمون، توابعی هستند که داده‌های خام را دریافت کرده و داده‌های خام را ارسال می‌کنند. اهمیتی ندارد که داده از کجا می‌آید یا به کجا می‌رود.

در پایان، با یک راه‌حل محکم برای هر مسئله شروع کنید. حتی اگر بخش عمده‌ای از آن فقط برنامه‌نویسی باشد. سپس رابط‌هایی را کشف کنید که برای کد امروز به طور مطلق لازم هستند.

"با رابط‌ها طراحی نکنید، آن‌ها را کشف کنید." - راب پایک
