جداول هش
یک جدول هش مثال کلاسیکی از یک نوع مخزن است که می‌تواند از ژنریک بهره‌برداری واقعی داشته باشد.

* ژنریک‌ها - جداول هش

یک جدول هش مثال کلاسیکی از یک نوع مخزن است که می‌تواند از ویژگی‌های واقعی ژنریک بهره‌برداری کند. این پیاده‌سازی توسط Matt Layher (@mdlayer) در یک پست وبلاگی که نوشته است، انجام شده است. این یک مثال عالی از امکاناتی است که با استفاده از ژنریک ممکن است.

** ویدیو

سخنرانی من در مورد ژنریک‌ها را که شما را از طریق تمام مثال‌ها در این بخش از تور هدایت می‌کند، تماشا کنید.

.html generics-video.html

** بررسی کد

- *مثال* *1*: جدول هش

.play generics/hash-table/example1.go

*** توضیح داده شده

این کد یکم پیچیده‌تر از آنچه تا الآن دیده‌اید است. این چیزی است که انتظار دارید در پیاده‌سازی‌های واقعی ببینید. در طول این بخش، دو دیدگاه از کد را خواهید دید. یکی قبل و دیگری بعد از اعمال نحوه جدید ژنریک.

    type hashFunc func(key K, buckets int) int

این نوع یک امضای تابع هش را تعریف می‌کند که توسط جدول هش برای محاسبه موقعیت سبد برای ذخیره و بازیابی داده‌ها استفاده می‌شود. کاربر باید این تابع را پیاده‌سازی کرده و آن را در هنگام ساخت جدول هش ارائه دهد. این تابع یک کلید و تعداد سبدها را که می‌تواند از آنها انتخاب کند، می‌پذیرد. چون می‌خواهید این سیستم در اصطلاح انواع استفاده شده برای کلید و مقدار ژنریک باشد، یک پارامتر به نام key با نوع حرف بزرگ K تعریف می‌کنید.

بعداً می‌توانید نحوه جدید ژنریک را برای تبدیل K به یک نوع ژنریک واقعی اعمال کنید.

    type hashFunc[K comparable] func(key K, buckets int) int <-- تغییر یافته است

پس از نام نوع، کروشه‌ها با نوع ژنریک K و محدودیت comparable را اضافه کنید. از آنجایی که مقادیر نوع کلید باید در یک عمل مقایسه استفاده شوند، اینکه این الآن توضیح داده شود، حتی اگر پیاده‌سازی تابع هش به آن نیاز نداشته باشد، منطقی است. همگانیت همه چیز در خوانایی، درک و قابلیت تعمیر در طول زمان می‌باشد.

این نوع یک جفت کلید/مقدار از داده‌ها را نمایان می‌کند که توسط جدول هش ذخیره خواهد شد.

    type keyValuePair struct {
        Key K
        Value V
    }

وظیفه این نوع نگه داشتن داده واقعی با کلید مربوطه است. در ادامه، کد یک فیلد کلید با نوع K و یک فیلد مقدار با نوع V تعریف می‌کند.

حال می‌توانید نحوه جدید ژنریک را برای تبدیل K و V به نوع ژنریک واقعی اعمال کنید.

    type keyValuePair[K comparable, V any] struct { <-- تغییر یافته است
        Key K
        Value V
    }

پس از نام نوع، کروشه‌ها با انواع ژنریک K و V اضافه می‌شوند. در این تعریف، K همچنان نمایانگر کلید است و V نمایانگر یک مقدار است که می‌تواند هر چیزی باشد.

این نوع یک جدول هش را نمایان می‌کند که یک تابع هش و یک مجموعه از سبدها برای ذخیره واژه‌های کلید/مقدار مدیریت می‌کند.

    type Table struct {
        hashFunc hashFunc
        buckets int
        data [][]keyValuePair
    }

نوع Table دارای سه فیلد است: یک تابع هش، تعداد سبدها و داده که به عنوان یک برش از برش‌های جفت کلید/مقدار نمایان داده شده است. برش بیرونی سبدها را نمایان می‌کند و برش داخلی جفت کلید/مقدارها را نمایان می‌کند که در داخل یک سبد ذخیره می‌شوند.

حالا نحوه جدید ژنریک را اعمال کنید تا انواع ژنریک کلید و مقدار را اعلام کنید و آنها را به اعلام فیلد اعمال کنید.

    type Table[K comparable, V any] struct { <-- تغییر یافته است
        hashFunc hashFunc[K] <-- تغییر یافته است
        buckets int
        data [][]keyValuePair[K, V] <-- تغییر یافته است
    }

پس از نام نوع، کروشه‌ها با انواع ژنریک K و V اضافه شوند. تعریف نوع hashFunc نیاز به اطلاعات در مورد نوع واقعی برای کلید دارد. تعریف نوع keyValuePair نیاز به اطلاعات در مورد نوع واقعی کلید و مقدار دارد.

این یک تابع کارخانه است که می‌تواند یک جدول را برای استفاده ایجاد کند.

    func New(
        buckets int,
        hf hashFunc
    ) *Table {
        
        return &Table{
            hashFunc: hf,
            buckets: buckets,
            data: make([][]keyValuePair, buckets),
        }
    }

تابع کارخانه تعداد سبدها را برای مدیریت و یک تابع هش برای انتخاب یک سبد برای ذخیره و جستجوی داده‌ها قبول می‌کند. هنگامی که یک مقدار جدول ساخته می‌شود، تعداد سبدها برای ساخت برش استفاده می‌شود و طول برش بیرونی به تعداد سبدها که استفاده خواهد شد، تنظیم می‌شود.

حالا نحوه جدید ژنریک را اعمال کنید تا انواع ژنریک کلید و مقدار را اعلام کنید و آنها را به انواعی که باید ساخته شوند، اعمال کنید.

    func New[K comparable, V any]( <-- تغییر یافته است
        buckets int,
        hf hashFunc[K],            <-- تغییر یافته است
    ) *Table[K, V] {               <-- تغییر یافته است
        
        return &Table[K, V]{       <-- تغییر یافته است
            hashFunc: hf,
            buckets: buckets,
            data: make([][]keyValuePair[K, V], buckets), <-- تغییر یافته است
        }
    }

پس از نام نوع، کروشه‌ها و انواع ژنریک K و V را اضافه کنید. سپس K به پارامتر ورودی hf اعمال شود تا تعریف نوع hashFunc کامل شود. انواع K و V به نوع Table که در حال ساخت و برگشت داده می‌شود، اعمال می‌شوند. در نهایت، مقداردهی اولیه فیلد داده نیاز به اعمال انواع K و V به نحوه ساخت انواع keyValuePair دارد.

این یک متد است که می‌تواند مقادیر را براساس یک کلید مشخص به جدول هش اضافه کند.

    type Table[K comparable, V any] struct {
        hashFunc hashFunc[K]
        buckets int
        table [][]keyValuePair[K, V]
    }

    func (t *Table) Insert(key K, value V) {
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.table[bucket] {
            if key == kvp.Key {
                t.table[bucket][idx].Value = value
                return
            }
        }

        kvp := keyValuePair{
            Key: key,
            Value: value,
        }
        t.table[bucket] = append(t.table[bucket], kvp)
    }

متد Insert به اعلام یک کلید و مقدار با همان انواع ژنریکی که با نوع Table اعلام شده‌اند، تعریف شده است. مرحله اول درج، تعیین سبدی است که برای ذخیره‌سازی استفاده خواهد شد. این کار با فراخوانی تابع هش با کلید مشخص انجام می‌شود. تابع هش یک مقدار عددی را که سبدی را نمایان می‌کند برمی‌گرداند.

سپس تابع بررسی می‌کند که آیا کلید مشخص شده قبلاً برای ذخیره کردن مقداری در سبد انتخابی استفاده شده است یا نه. این با گردش در مجموعه موجود از جفت‌های کلید/مقدار در سبد انجام می‌شود. اگر کلید از قبل وجود داشته باشد، مقدار مربوط به آن کلید به‌روزرسانی می‌شود. اگر کلید پیدا نشود، سپس یک مقدار جدید کلید/مقدار ساخته، مقداردهی و به انتهای برش برای سبد انتخابی اضافه می‌شود.

حالا نحوه جدید ژنریک را اعمال کنید تا انواع ژنریک کلید و مقدار را اعلام کنید و آنها را به انواعی که باید ساخته شوند، اعمال کنید.

    func (t *Table[K, V]) Insert(key K, value V) { <-- CHANGED
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.table[bucket] {
            if key == kvp.Key {
                t.table[bucket][idx].Value = value
                return
            }
        }
    
        kvp := keyValuePair[K, V]{                 <-- CHANGED
            Key: key,
            Value: value,
        }
        t.table[bucket] = append(t.table[bucket], kvp)
    }

پس از نام نوع دریافت‌کننده، کروشه‌ها و انواع ژنریک K و V را اضافه کنید. تغییر دیگر تنها اعمال K و V به نحوه ساخت انواع keyValuePair می‌باشد.

این یک متد است که می‌تواند مقادیر را از جدول هش براساس یک کلید مشخص بازیابی کند.

    func (t *Table) Retrieve(key K) (V, bool) {
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.data[bucket] {
            if key == kvp.Key {
                return t.data[bucket][idx].Value, true
            }
        }
    
        var zero V
        return zero, false
    }

متد Retrieve به اعلام یک کلید پاسخ داده می‌شود و یک نسخه از مقدار ذخیره شده برای آن کلید برگردانده می‌شود. مرحله اول بازیابی، تعیین سبدی است که برای ذخیره استفاده شده است. این با فراخوانی تابع هش با کلید مشخص انجام می‌شود. تابع هش یک مقدار عددی را که سبدی را نمایان می‌کند برمی‌گرداند.

سپس تابع در طول مجموعه‌ای از جفت‌های کلید/مقدار ذخیره شده درون سبد قرار دارد و به دنبال کلید مشخص می‌گردد. اگر کلید پیدا شود، یک نسخه از مقدار برگردانده می‌شود و به فراخواننده true ارائه می‌شود. اگر کلید پیدا نشود، مقدار صفر برگردانده می‌شود و به فراخواننده false ارائه می‌شود.

حالا نحوه جدید ژنریک را اعمال کنید تا انواع ژنریک کلید و مقدار را اعلام کنید و آنها را به انواعی که باید ساخته شوند، اعمال کنید.

    func (t *Table[K, V]) Get(key K) (V, bool) { <-- CHANGED
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.data[bucket] {
            if key == kvp.Key {
                return t.data[bucket][idx].Value, true
            }
        }
    
        var zero V
        return zero, false
    }

پس از نام نوع دریافت‌کننده، کروشه‌ها و انواع ژنریک K و V را اضافه کنید. تغییرات کد دیگری نیاز نیست.

این یک برنامه کوچک است برای تست پیاده‌سازی جدول هش.

```go
func main() {
    const buckets = 8
    // ... (سایر قسمت‌های برنامه)
}
```

ابتدا با یک ثابت شروع کنید که تعداد سبدهایی که در جدول هش استفاده می‌شود را تعریف می‌کند.

    import (
        "hash/fnv"
    )
    
    func main() {
        . . .
        
        hashFunc1 := func(key string, buckets int) int {
            h := fnv.New32()
            h.Write([]byte(key))
            return int(h.Sum32()) % buckets
        }

        . . .
    }

سپس، یک تابع هش تعریف کنید که یک رشته را برای کلید اعلام می‌کند. پیاده‌سازی از بسته fnv از کتابخانه استاندارد استفاده می‌کند که توابع هش غیر-رمزنگاری FNV-1 و FNV-1a را پیاده‌سازی می‌کند که توسط Glenn Fowler، Landon Curt Noll و Phong Vo ایجاد شده است. FNV به معنای تابع هش Fowler-Noll-Vo است.

عملیات باقی‌مانده با مقدار سبدها موجب می‌شود که مقدار نهایی در محدوده تعداد سبدها قرار بگیرد.

    import (
        "hash/fnv"
    )
    
    func main() {
        . . .
        
        table1 := New[/*key*/ string, /*value*/ int](buckets, hashFunc1)
        
        . . .
    }

سپس یک جدول هش بسازید و به صراحت بیان کنید که کلید از نوع رشته و مقدار از نوع عدد صحیح (int) خواهد بود. در پارامترهای ورودی چیزی وجود ندارد که به کامپایلر کمک کند این اطلاعات را استنتاج کند.

برای نمایش ماهیت جدول هش به عنوان ژنریک، یک تابع هش و جدول دومی تعریف کنید.

    import (
        "hash/fnv"
    )
    
    func main() {
        . . .
    
        hashFunc2 := func(key int, buckets int) int {
            return key % buckets
        }

        table2 := New[/*key*/ int, /*value*/ string](buckets, hashFunc2)
    
        . . .
    }

این تابع هش یک عدد صحیح برای کلید اعلام می‌کند و با مقدار سبد در مقابل کلید یک عملیات باقی‌مانده ساده انجام می‌دهد. سپس یک جدول جدید ساخته می‌شود که در آن کلید به عنوان یک عدد صحیح و مقدار به عنوان یک رشته مشخص شده است. عکس اولین جدول.


    import (
        "hash/fnv"
    )
    
    func main() {
        . . .
    
        words := []string{"foo", "bar", "baz"}
        for i, word := range words {
            table1.Insert(word, i)
            table2.Insert(i, word)
        }
    
        for i, s := range append(words, "nope!") {
            v1, ok1 := table1.Retrieve(s)
            fmt.Printf("t1.Rtr(%v) = (%v, %v)\n", s, v1, ok1)
            
            v2, ok2 := table2.Retrieve(i)
            fmt.Printf("t2.Rtr(%v) = (%v, %v)\n", i, v2, ok2)
        }
    }

خروجی:

    t1.Rtr(foo) = (0, true)
    t2.Rtr(0) = (foo, true)
    t1.Rtr(bar) = (1, true)
    t2.Rtr(1) = (bar, true)
    t1.Rtr(baz) = (2, true)
    t2.Rtr(2) = (baz, true)
    t1.Rtr(nope!) = (0, false)
    t2.Rtr(3) = (, false)

سرانجام کدی بنویسید تا ارزش‌ها را در دو جدول متناظر ذخیره و بازیابی کنید.
