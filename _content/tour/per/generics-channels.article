کانال‌ها
بررسی کنید که چگونه تیم Go می‌تواند بسته‌ای از الگوهای همروندی را به کتابخانه استاندارد اضافه کند، با تشکر از generic.

* ژنریک‌ها - کانال‌ها


بررسی کنید که چگونه تیم Go می‌تواند با تشکر از ژنریک، یک بسته از الگوهای همروندی را به کتابخانه استاندارد اضافه کند.

* ویدیو

تماشای سخنرانی من در مورد ژنریک‌ها که شما را از طریق تمام مثال‌ها در این بخش از تور هدایت می‌کند.

.html generics-video.html

** بررسی کد

- *مثال* *1*: Work Function
- *مثال* *2*: Pooling

.play generics/channels/example1.go
.play generics/channels/example2.go

** توضیح داده شده

برای انجام این کار، نیاز به تعریف کانال‌ها و توابع با استفاده از انواع ژنریک داریم.

    type workFn[Result any] func(context.Context) Result

در این مثال، یک نوع تعریف شده است که یک تابع را نمایان می‌کند که یک متغیر context را می‌پذیرد
و یک مقدار از نوع ژنریک Result بر می‌گرداند. این تعریف تابع یک تابع را توصیف می‌کند که اجرای کار همروند را انجام می‌دهد و نتیجه آن کار را برمی‌گرداند.

    func doWork[Result any](ctx context.Context, work workFn[Result]) chan Result {
        ch := make(chan Result, 1)
        
        go func() {
            ch <- work(ctx)
            fmt.Println("doWork : work complete")
        }()
        
        return ch
    }

اکنون یک تابع به نام doWork بنویسید که تابع کار مشخص شده را به صورت همروند اجرا کرده و یک کانال برگشتی کند تا فراخواننده بتواند نتیجه کار انجام شده توسط تابع کار را دریافت کند. یک نوع ژنریک به نام Result تعریف می‌شود تا نوع بازگشتی برای تابع کار و نوع کانال را نمایان کند.

در پیاده‌سازی تابع doWork، یک کانال بافر شده با ظرفیت یک به نوع ژنریک Result ساخته می‌شود. این کانال به فراخواننده برگشت داده می‌شود تا نتیجه کار همروند را دریافت کند. در وسط تابع، یک گوروتین برای اجرای تابع کار همروند ساخته می‌شود. هنگامی که تابع کار بازگشت دهد، آرگومان بازگشتی از طریق کانال به فراخواننده ارسال می‌شود.

برای تست استفاده از تابع doWork، یک برنامه کوچک بسازید.

    func main() {
        duration := 100 * time.Millisecond
        
        ctx, cancel := context.WithTimeout(context.Background(), duration)
        defer cancel()
        
        dwf := func(ctx context.Context) string {
            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
            return "work complete"
        }

        result := doWork(ctx, dwf)
        
        select {
            case v := <-result:
                fmt.Println("main:", v)
            case <-ctx.Done():
                fmt.Println("main: timeout")
        }
    }

Output:

    doWork : work complete
    main: work complete

خروجی:

    doWork: کار تکمیل شد
    main: کار تکمیل شد

برنامه با تعریف یک متغیر context آغاز می‌شود که در ۱۰۰ میلی‌ثانیه منقضی می‌شود. سپس یک تابع کار تعریف می‌شود که تا ۲۰۰ میلی‌ثانیه قبل از بازگشت رشته "کار تکمیل شد" منتظر می‌ماند. با داشتن context و تابع کار، یک فراخوانی به تابع doWork انجام می‌شود و یک کانال از نوع string برگشت داده می‌شود و به متغیر نتیجه اختصاص داده می‌شود.

کامپایلر قادر است نوع محتوایی را که باید برای نوع ژنریک Result استفاده کند را با بررسی نوع بازگشتی تابع کار لغوشده که به تابع doWork منتقل می‌شود، تشخیص دهد. این بسیار شگفت‌انگیز است زیرا به این معناست که نیازی به انتقال نوع به تماس با doWork نداشته‌اید.

با کانال نوع string که به متغیر نتیجه اختصاص داده شده است، از یک select case برای انتظار بازگشت نتیجه به موقع یا منقضی شدن timeout استفاده می‌شود. تابع doWork می‌تواند برای انجام این کار همروند برای هر نوع محتوایی مورد نیاز استفاده شود.

این ایده می‌تواند به یک مجموعه از گوروتین‌ها که می‌توانند کار را روی ورودی ژنریک انجام دهند و نتیجه‌ای ژنریک را برگردانند، اعمال شود.

نوع تابع کار را در این مثال به گونه‌ای تغییر دهید که ورودی ژنریک را پذیرفته و نتیجه‌ای ژنریک را برگرداند.

type workFn[Input any, Result any] func(input Input) Result

در این مثال، نوع تابع را به گونه‌ای تغییر دهید که ورودی ژنریک را پذیرفته و نتیجه‌ای ژنریک را برگرداند.

    func poolWork[Input any, Result any](size int, work workFn[Input, Result]) (chan Input, func()) {
        var wg sync.WaitGroup
        wg.Add(size)
        
        ch := make(chan Input)
        
        for i := 0; i < size; i++ {
            go func() {
                defer wg.Done()
                for input := range ch {
                    result := work(input)
                    fmt.Println("pollWork :", result)
                }
            }()
        }
        
        cancel := func() {
            close(ch)
            wg.Wait()
        }

        return ch, cancel
    }

در تابع poolWork، دو نوع ژنریک یکسان برای نمایانگر ورودی و نوع بازگشتی تابع کار تعریف می‌شوند. یک WaitGroup ساخته می‌شود تا مدیریت ژیروتین‌ها در استخر را انجام دهد. سپس یک کانال از نوع ژنریک Input ساخته می‌شود. این کانال توسط ژیروتین‌ها در استخر برای دریافت داده ورودی برای تابع کار استفاده می‌شود.

سپس استخر ژیروتین‌ها با ایجاد هر ژیروتین در عملیات دریافتی با استفاده از حلقه for-range در برابر کانال ایجاد می‌شود. در نهایت، یک تابع کنسل ساخته می‌شود تا به فراخواننده اجازه دهد استخر را خاموش کند و منتظر شود که تمام ژیروتین‌ها اعلام کنند که ترمینال شده‌اند.

برای تست استفاده از تابع poolWork، یک برنامه کوچک دیگر بسازید.

    func main() {
        size := runtime.GOMAXPROCS(0)
        
        pwf := func(input int) string {
            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
            return fmt.Sprintf("%d : received", input)
        }

        ch, cancel := poolWork(size, pwf)
        defer cancel()
        
        for i := 0; i < 4; i++ {
            ch <- i
        }
    }

خروجی:

    poolWork : 3 : دریافت شد
    poolWork : 2 : دریافت شد
    poolWork : 1 : دریافت شد
    poolWork : 0 : دریافت شد

اندازه استخر بر اساس تعداد ژیروتین‌هایی محاسبه می‌شود که می‌توانند به صورت موازی اجرا شوند. سپس یک تابع کار ساخته می‌شود تا به مدت زمان تصادفی بخوابد و سپس یک رشته را که نمایانگر ورودی است برگرداند.

با داشتن این تغییرات، تابع poolWork اجرا می‌شود و کانال و تابع کنسل برگردانده می‌شود. تابع کنسل به صورت بازگشتی فراخوانی می‌شود و یک حلقه ساخته می‌شود تا ۴ مقدار به استخر ارسال شود. خروجی هر بار که برنامه اجرا می‌شود متفاوت خواهد بود زیرا این کار به صورت همروند انجام می‌شود.

این مثال‌های کوچک نمونه‌ای از اینکه چگونه یک بسته همروند می‌تواند پیاده‌سازی شود، ارائه می‌دهند.
