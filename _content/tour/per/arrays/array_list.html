<ul>
    <li>کش‌های CPU با کش کردن حافظه اصلی در خطوط کش کار می‌کنند.</li>
    <li>خطوط کش امروزه بسته به سخت‌افزار، 32 یا 64 بایت عرض دارند.</li>
    <li>هسته‌ها به طور مستقیم به حافظه اصلی دسترسی ندارند. آنها تمایل دارند فقط به کش‌های محلی خود دسترسی داشته باشند.</li>
    <li>هم داده‌ها و هم دستورالعمل‌ها در کش‌ها ذخیره می‌شوند.</li>
    <li>خطوط کش با توجه به نیاز به ذخیره خطوط کش جدید در کش‌ها، از L1->L2->L3 جابه‌جا می‌شوند.</li>
    <li>سخت‌افزار دوست دارد داده‌ها و دستورالعمل‌ها را به صورت خطی در طول خطوط کش طی کند.</li>
    <li><p>حافظه اصلی بر روی حافظه نسبتا سریع و ارزان ساخته شده است. کش‌ها بر روی حافظه بسیار سریع و گران قیمت ساخته شده‌اند.</p></li>
    <li><p>دسترسی به حافظه اصلی بسیار کند است، ما به کش نیاز داریم.</p>
    <ul>
    <li>دسترسی به یک بایت از حافظه اصلی باعث خواندن و کش کردن کل خط کش می‌شود.</li>
    <li>نوشتن در یک بایت در یک خط کش نیاز به نوشتن کل خط کش دارد.</li>
    </ul>
    </li>
    <li><p>کوچک = سریع</p>
    <ul>
    <li>کد فشرده و خوب موضعی که در کش جای می‌گیرد سریع‌ترین است.</li>
    <li>ساختارهای داده فشرده که در کش جای می‌گیرند سریع‌ترین هستند.</li>
    <li>پیمایش‌هایی که فقط به داده‌های کش شده دست می‌زنند سریع‌ترین هستند.</li>
    </ul>
    </li>
    <li><p>الگوهای دسترسی قابل پیش‌بینی مهم هستند.</p>
    <ul>
    <li>هر زمان که عملی باشد، می‌خواهید از یک پیمایش آرایه خطی استفاده کنید.</li>
    <li>الگوهای منظمی از دسترسی به حافظه را فراهم کنید.</li>
    <li>سخت‌افزار می‌تواند پیش‌بینی‌های بهتری در مورد حافظه مورد نیاز انجام دهد.</li>
    </ul>
    </li>
    <li><p>خطای کش می‌تواند منجر به خطای کش TLB نیز شود.</p>
    <ul>
    <li>کش ترجمه آدرس مجازی به آدرس فیزیکی.</li>
    <li>منتظر ماندن برای سیستم عامل تا به ما بگوید حافظه کجاست.</li>
    </ul>
    </li>
    </ul>    