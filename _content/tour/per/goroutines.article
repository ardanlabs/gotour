گوروتین‌ها
گوروتین‌ها توابعی هستند که توسط برنامه‌نویس ایجاد می‌شوند و توسط برنامه اجرا می‌شوند. این اجراها مستقل از یکدیگر توسط برنامه‌ی Go مدیریت می‌شوند.

* گوروتین‌ها

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][تماشای ویدئو]]
- نیاز به کمک مالی دارید؟ از [[https://www.ardanlabs.com/scholarship/][فرم Scholarship]] ما استفاده کنید.

گوروتین‌ها توابعی هستند که به صورت مستقل توسط برنامه‌ی Go ایجاد و برنامه‌ی Go برای اجرای آن‌ها زمان‌بندی می‌کند. زمان‌بندی و اجرای گوروتین‌ها توسط برنامه‌ی Go انجام می‌شود.

** مرور کد

- *مثال* *1:* گوروتین‌ها و همروندی
- *مثال* *2:* تعویض متناوب کانتکست گوروتین
- *مثال* *3:* گوروتین‌ها و همروندی

.play goroutines/example1.go
.play goroutines/example2.go
.play goroutines/example3.go


** معنایی از زمان‌بند

زمانی که یک برنامه Go شروع به اجرا می‌کند، محیط اجرایی Go از سیستم (مجازی یا فیزیکی) می‌پرسد که چند نخ سیستم عامل می‌توانند به صورت موازی اجرا شوند. این بر اساس تعداد هسته‌هایی است که برنامه در دسترس دارد. برای هر نخ که می‌تواند به صورت موازی اجرا شود، محیط اجرایی یک نخ سیستم عامل (M) ایجاد می‌کند و آن را به یک ساختار داده متصل می‌کند که یک پردازنده منطقی (P) در داخل برنامه را نمایان می‌کند. این P و M قدرت محاسباتی یا زمینه اجرایی را برای اجرای برنامه Go نمایان می‌کنند.

همچنین، یک گوروتین اولیه (G) ایجاد می‌شود تا مدیریت اجرای دستورات را در یک M/P انتخاب شده انجام دهد. همانطور که یک M مدیریت اجرای دستورات را روی سخت‌افزار انجام می‌دهد، یک G مدیریت اجرای دستورات را روی M انجام می‌دهد. این یک لایه جدید از انتزاع بالاتر از زمان‌بند سیستم عامل ایجاد می‌کند، اما کنترل اجرا را به سطح برنامه انتقال می‌دهد.

.image /tour/eng/static/img/gor1.png

زیرا زمان‌بند Go روی زمان‌بند سیستم عامل قرار دارد، اهمیت دارد که مفهومی از زمان‌بند سیستم عامل و محدودیت‌های آن نسبت به زمان‌بند Go و برنامه‌ها وجود داشته باشد.

زمان‌بند سیستم عامل وظیفه ایجاد حس واقعی از اجرای همزمان چند کار را دارد، حتی زمانی که این امر فیزیکیاً ممکن نباشد. این نیاز به مدیریت تعادل‌هایی در طراحی زمان‌بند دارد. قبل از ادامه، مهم است که تعریف‌هایی ارائه دهیم:

**کار:** یک مجموعه دستوراتی که باید برای اجرای یک برنامه اجرا شود. این با استفاده از نخ‌ها انجام می‌شود و یک برنامه می‌تواند 1 تا متعدد نخ داشته باشد.

**نخ:** یک مسیر اجرایی که برنامه ریزی شده و اجرا می‌شود. نخ‌ها مسئول اجرای دستورات بر روی سخت‌افزار هستند.

**وضعیت‌های نخ:** یک نخ ممکن است در یکی از سه وضعیت زیر باشد: در حال اجرا، در حالت آماده به اجرا (قابل اجرا) یا در حالت انتظار. در حال اجرا به معنای اجرای دستورات اختصاص داده شده بر روی سخت‌افزار با قرار دادن یک G بر روی M است. قابل اجرا به معنای نخ می‌باشد که می‌خواهد زمانی را در سخت‌افزار داشته باشد تا دستورات اختصاص داده شده را اجرا کند و در یک صف اجرایی قرار دارد. انتظار به معنای انتظار نخ برای چیزی قبل از ادامه کار خود است. نخ‌های در حالت انتظار مورد نظر زمان‌بند نیستند.

*همزمانی:* این به معنای اجرای غیر معین و بدون ترتیب است. به عبارت دیگر، یک مجموعه دستورات که باید به ترتیب اجرا شود، به ترتیب معینی اجرا نمی‌شوند، بلکه به ترتیب نامعینی دیگری اجرا می‌شوند، اما تمام اجرا می‌شوند. کلید این است که نتیجه اجرای تمام دستورات در هر ترتیب نامعینی، نتیجه مشابهی تولید می‌کند. می‌توانید بگویید که کار می‌تواند همزمان انجام شود زمانی که ترتیب اجرای کار در واقعیت مهم نیست، تا زمانی که همه کار انجام شود.

*پردازش همزمان:* این به معنای انجام چندین کار به یکدیگر است. برای این که این امکان وجود داشته باشد، باید قابلیت اجرای حداقل دو یا بیشتر نخ سیستم عامل را بر روی سخت‌افزار داشته باشید.

*کار محدود به پردازنده (CPU Bound):* این نوع کار به نوعی است که باعث نمی‌شود نخ به صورت طبیعی در وضعیت انتظار بیفتد. مثلاً محاسبه اعداد فیبوناچی به عنوان کار محدود به پردازنده محسوب می‌شود.

*کار محدود به ورودی/خروجی (I/O Bound):* این نوع کار باعث می‌شود نخ به صورت طبیعی به وضعیت انتظار بیفتد. مثلاً دریافت داده از آدرس‌های مختلف در شبکه به عنوان کار محدود به ورودی/خروجی محسوب می‌شود.

*همگام‌سازی:* زمانی که دو یا بیشتر از گوروتین‌ها نیاز به دسترسی به همان مکان حافظه دارند، ممکن است در همان زمان این عملیات رخ دهد. در این صورت، نیاز به همگام‌سازی و تنظیم ترتیب اجرا دارند. اگر این همگام‌سازی انجام نشود و حداقل یک گوروتین دارای عملیات نوشتن باشد، ممکن است با یک اشکال در داده (مسابقه داده) روبه‌رو شوید. مسابقه داده، علتی از اشکالات خرابی داده است که ممکن است به دشواری پیدا شود.

*ارتباط گیری:* زمانی که دو یا بیشتر از گوروتین‌ها نیاز به ارسال پیام به یکدیگر دارند، با یا بدون داده، ارتباط گیری مورد نیاز است. اگر ارتباط گیری انجام نشود، تضمینات مربوط به کار همزمان انجام شده و تکمیل شده از دست می‌روند. این می‌تواند علت ایجاد انواع مختلفی از اشکالات خرابی داده باشد.

تعداد زیادی جزئیات کوچک مرتبط با نحوه زمان‌بندی وجود دارد، بنابراین برای یادگیری بیشتر می‌توانید سه مطلب در فصل 14 با عنوان "زمان‌بندی در Go" را مطالعه کنید.

** مبانی همزمانی

شروع با یک مشکل همزمانی پایه که نیاز به ارتباط گیری دارد.

    func init() {
        runtime.GOMAXPROCS(1)
    }

تماس به `GOMAXPROCS` برای اجرای برنامه Go به عنوان یک برنامه تک‌نخی Go استفاده می‌شود. این برنامه تک‌نخی خواهد بود و یک P/M تنها برای اجرای تمام گوروتین‌ها دارد. تابع با حروف بزرگ نوشته شده است چرا که همچنین یک متغیر محیطی است. با این حال، این فراخوانی تابع متغیر محیطی را بازنویس می‌کند.


    g := runtime.GOMAXPROCS(0)


این تابع یک تابع مهم است زمانی که نرخ‌های پردازنده را به پیکربندی کانتینر تنظیم می‌کنید. با ارسال 0، تعداد نخ‌هایی که برنامه Go از آن استفاده خواهد کرد، گزارش می‌شود. باید اطمینان حاصل کنید که این تعداد با تعداد نخ‌های سیستم عاملی که در محیط کانتینر دارید مطابقت دارد. اگر اعداد مطابقت نداشته باشند، برنامه Go به عنوان خواهد بود که بدون بهینه‌سازی اجرا می‌شود. ممکن است بخواهید از متغیر محیطی یا این تماس برای تطابق استفاده کنید.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        fmt.Println("Waiting To Finish")
        wg.Wait()

        fmt.Println("\nTerminating Program")
    }

این برنامه باید یک مشکل هماهنگی را حل کند. گوروتین اصلی نمی‌تواند به تابع اصلی اجازه دهد تا تا زمانی که دو گوروتین ایجاد شده خودشان کار خود را به اتمام نرسانند، بازگردد. WaitGroup ابزاری مناسب برای مسائل هماهنگی است که نیازی به انتقال داده بین گوروتین‌ها ندارند. ارسال سیگنال در اینجا از طریق یک API انجام می‌شود که به یک گوروتین اجازه می‌دهد منتظر شدن از سایر گوروتین‌ها برای اعلام پایان کار خود باشد.

در این کد، یک WaitGroup به حالت مقدار صفر ایجاد شده و سپس به طور فوری متد Add فراخوانی می‌شود تا مقدار WaitGroup به 2 تنظیم شود که با تعداد گوروتین‌هایی که باید ایجاد شوند مطابقت خواهد داشت. وقتی می‌دانید که چند گوروتین به صورت پیش‌فرض ایجاد می‌شوند، باید یک بار با آن تعداد Add را فراخوانی کنید. وقتی نمی‌دانید (مثل در یک سرویس استریمینگ)، آنگاه فراخوانی Add(1) قابل قبول است.

در پایان تابع main، فراخوانی به Wait وجود دارد. Wait گوروتین اصلی را متوقف می‌کند تا از بازگشت تابع اصلی جلوگیری شود. وقتی تابع اصلی بازگردد، برنامه Go با حذف سریع بسته می‌شود. به همین دلیل مدیریت هماهنگی با تضمینات مناسب مهم است. تماس Wait تا زمانی که مقدار WaitGroup به 0 تنظیم شود بلاک می‌کند.

در وسط برنامه، شما دو گوروتین ایجاد کرده‌اید.

    func main() {
        . . .

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        . . .
    }

توابع متنی با استفاده از کلمه کلیدی go اعلام و اجرا می‌شوند. در این نقطه، به زمانبند Go می‌گویید که این توابع را به صورت موازی اجرا کند. برای اجرای آنها به ترتیبی نامشخص. در داخل اجرای هر گوروتین، فراخوانی Done وجود دارد. این فراخوانی باعث کاهش مقدار WaitGroup به مقدار 1 می‌شود. یک بار که هر دو فراخوانی به Done انجام شود، مقدار WaitGroup از 2 به 0 تغییر خواهد کرد و سپس گوروتین اصلی از فراخوانی Wait باز می‌شود و برنامه خاتمه می‌یابد.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            wg.Done()
        }()

        . . .
    }

یک بخش مهم از این الگوی ارکستراسیون نگه داشتن تماس‌های Add و Done در دید یکسان است. سعی کنید وقتی تماس‌ها انجام می‌شوند، WaitGroup را به عنوان پارامتر تابع منتقل نکنید که تماس‌ها گم شوند. این کمک می‌کند تا خطاها کاهش پیدا کنند.

    خروجی:

    شروع گوروتین‌ها
    در انتظار پایان
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    خاتمه برنامه

وقتی این برنامه را بسازید و اجرا کنید، مشاهده می‌کنید که این برنامه به صورت موازی اجرا می‌شود. گوروتین دومی که ایجاد شده، ابتدا زمان‌بندی شد. این اجازه را داد تا کار خود را به اتمام برساند و سپس گوروتین دیگر اجرا شد. هر دو به پایان رسیدند پیش از اینکه برنامه خاتمه یابد. بار دیگر که این برنامه را اجرا می‌کنید، هیچ تضمینی برای مشاهده خروجی یکسان وجود ندارد. تنها تضمین در این برنامه این است که برنامه تا زمانی که دو گوروتین به اتمام نرسیده‌اند، خاتمه نخواهد یافت.

حتی اگر این برنامه را 100 بار اجرا کنید و همان خروجی را مشاهده کنید، تضمینی برای تکرار این موضوع وجود ندارد. این ممکن است بسیار احتمالی باشد، اما تضمین نشده است، به ویژه در بین نسخه‌ها، سیستم‌عامل‌ها و معماری‌های مختلف.

    func main() {
        . . .

        fmt.Println("Waiting To Finish")
        // wg.Wait()                           <-- CHANGED

        fmt.Println("\nTerminating Program")
    }

اگر تماس به `Wait` را کامنت کنید، چه اتفاقی می‌افتد وقتی این برنامه را اجرا می‌کنید؟ دوباره، دیگر هیچ تضمینی در مورد اتفاقات وجود ندارد، اما احتمالات مختلفی وجود دارد.

این برنامه ممکن است مانند قبل عمل کند، زیرا تماس‌ها به `Println` تماس‌های سیستمی هستند که به اجرای تبادل سیاق اجازه می‌دهند. این برنامه ممکن است تنها یکی از دو گوروتین را اجرا کند یا شاید فوراً پایان یابد.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            lowercase()
            // wg.Done()               <-- CHANGED
        }()

        . . .
    }

اگر در یکی از گوروتین‌ها فراموش کنید که تابع `Done` را فراخوانی کنید، چه اتفاقی می‌افتد؟ در این صورت، برنامه به دلیل عدم توانایی تعداد `WaitGroup` برگشت به 0، به وقوع می‌پیوندد. تماس `Wait` به طور بی‌پایان مسدود خواهد شد.

    خروجی:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    fatal error: all goroutines are asleep - deadlock!

    goroutine 1 [semacquire]:
    sync.runtime_Semacquire(0xc00001a0a8)
        /usr/local/go/src/runtime/sema.go:56 +0x45
    sync.(*WaitGroup).Wait(0xc00001a0a0)
        /usr/local/go/src/sync/waitgroup.go:130 +0x65
    main.main()
        concurrency/goroutines/example1/example1.go:42 +0x145
    exit status 2

می‌توانید ببینید که زمانی که تماس به `Wait` در خط 42 رخ می‌دهد، Go Runtime تشخیص می‌دهد که برنامه در وضعیت مسدود شده (deadlock) قرار دارد. با این حال، باید به خاطر داشته باشید که تشخیص مسدودیت انجام شده تنها زمانی صورت می‌پذیرد که همه‌ی گوروتین‌ها مسدود شده و هیچ راهی برای خروج از آنها وجود نداشته باشد. این نشان می‌دهد چرا اهمیت دارد که تماس‌های `Add` و `Done` را در کنار هم نگه دارید.

    func main() {
        var wg sync.WaitGroup
        wg.Add(1)              <-- CHANGED, Number Too Small

        go func() {
            lowercase()
            wg.Done()
        }()

        go func() {
            uppercase()
            wg.Done()
        }()

        . . .
    }

اگر تعداد نادرستی از گوروتین‌ها به `WaitGroup` دهید چه اتفاقی می‌افتد؟ اگر تعداد زیادی باشد، ممکن است یک مسدودیت دیگر داشته باشید. اگر تعداد کم باشد، تضمینی وجود ندارد که کار قبل از ادامه برنامه انجام شود. خروجی برنامه تعریف نشده است.

** برنامه‌ریزی ممنوع

اگرچه برنامه‌ریز در داخل محدوده برنامه اجرا می‌شود، مهم است که ببینیم برنامه‌ریزی چگونه ممنوع (preemptive) است. این به معنای نمی‌توانید پیش‌بینی کنید کی یک تعویض متن رخ خواهد داد و این در هر بار اجرای برنامه تغییر می‌کند.

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            printHashes("A")
            wg.Done()
        }()

        go func() {
            printHashes("B")
            wg.Done()
        }()

        fmt.Println("Waiting To Finish")
        wg.Wait()

        fmt.Println("\nTerminating Program")
    }

با استفاده از الگوی هماهنگی مشابه به قبل، این برنامه باعث می‌شود که هر گوروتین کار بیشتری انجام دهد. کاری که برنامه‌ریز به یک گوروتین اجازه تکمیل آن در یک تایم‌اسلایس نخواهد داد.

    func printHashes(prefix string) {
        for i := 1; i <= 50000; i++ {
            num := strconv.Itoa(i)
            sum := sha1.Sum([]byte(num))
            fmt.Printf("%s: %05d: %x\n", prefix, i, sum)
        }
        fmt.Println("Completed", prefix)
    }

این تابع کارهای زیادی که به ورودی-خروجی مربوط می‌شود را انجام می‌دهد و این انجام این کارها احتمالاً باعث تغییر کانتکست می‌شود.

    $ ./example2 | cut -c1 | grep '[AB]' | uniq
    B
    A
    B
    A
    B
    A
    B
    A
    B
    A  9 Context Switches

    $ ./example2 | cut -c1 | grep '[AB]' | uniq
    B
    A
    B
    A  3 Context Switches

همانطور که می‌بینید، هر بار که برنامه را اجرا می‌کنید، تعداد متفاوتی از تغییرات کانتکست وقوع می‌کند. این چیزی عالی است چرا که یک برنامه زمان‌بندی نباید قابل پیش‌بینی باشد. همزمانی باید به عنوان یک چیز نامعلوم باقی بماند و شما باید به خاطر داشته باشید که وقتی از همزمانی برای حل مشکلات عملکرد استفاده می‌کنید، این ویژگی برای شما حفظ شود.

    func init() {
        runtime.GOMAXPROCS(2)
    }

اگر به برنامه اصلی برگشته و از GOMAXPROCS استفاده کنید تا برنامه به عنوان یک برنامه Go دو نخی اجرا شود، چه اتفاقی می‌افتد؟

    خروجی:

    Start Goroutines
    Waiting To Finish
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N a b c d e f g h i j k l m n o O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z
    Terminating Program

آنچه می‌بینید این است که هم اکنون همگرایی برنامه با دقت بیشتری انجام می‌شود. خروجی حروف به ترتیب تعریف نشده و به ترتیب اجرا نمی‌شود.

** یادداشت‌ها

- گوروتین‌ها توابعی هستند که برنامه‌هایی هستند که برای اجرا به صورت مستقل برنامه‌ریزی می‌شوند.
- ما همیشه باید حساب کرد که گوروتین‌های در حال اجرا را به دقت نگه داریم و به‌طور منظم خاتمه دهیم.
- همگرایی و هم‌پردازی مفاهیم متفاوتی هستند.

- همگرایی در مورد مقابله با چندین چیز در یک زمان است.
- هم‌پردازی در مورد انجام چندین کار به یک زمان است.

"هم‌پردازی به معنای انجام فیزیکی دو یا چند کار به یک زمان است. همگرایی به معنای اجرای تعریف‌نشده و به ترتیب اجرا نمی‌شود." - ویلیام کندی

"به صورت پیش‌فرض، گوروتین‌ها نباید بعد از تابعی که از آن ایجاد شده‌اند به پایان برسند. این باعث می‌شود شما در یک وضعیت طراحی بسیار خوب قرار گیرید." - پیتر بورگون

** رهنمودهای طراحی

- درباره [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#concurrent-software-design][رهنمودهای طراحی]] هم‌پردازی بیشتری بیاموزید.

** مطالب اضافی

- [[https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html][Scheduling In Go - Part I]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html][Scheduling In Go - Part II]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html][Scheduler Tracing In Go]] - William Kennedy   
- [[https://blog.golang.org/advanced-go-concurrency-patterns][Advanced Go Concurrency Patterns]] - Sameer Ajmani    
- [[https://blog.golang.org/context][Go Concurrency Patterns: Context]] - Sameer Ajmani    
- [[https://blog.golang.org/concurrency-is-not-parallelism][Concurrency is not parallelism]] - Rob Pike    
- [[https://talks.golang.org/2013/distsys.slide][Go, for Distributed Systems]] - Russ Cox    
- [[https://docs.google.com/document/d/1At2Ls5_fhJQ59kDK2DFVhFu3g5mATSXqqV5QrxinasI/edit][Go 1.5 GOMAXPROCS Default]]    
- [[https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html][Concurrency, Goroutines and GOMAXPROCS]] - William Kennedy    
- [[http://www.ece.ubc.ca/~sasha/papers/eurosys16-final29.pdf][The Linux Scheduler: a Decade of Wasted Cores]]    
- [[https://news.ycombinator.com/item?id=12460807][Explanation of the Scheduler]]    
- [[http://joeduffyblog.com/2016/11/30/15-years-of-concurrency/][15 Years of Concurrency]] - Joe Duffy    
- [[https://www.quora.com/How-does-the-golang-scheduler-work/answer/Ian-Lance-Taylor][How does the golang scheduler work?]] - Ian Lance Taylor    
- [[https://www.youtube.com/watch?v=YHRO5WQGh0k][The Scheduler Saga]] - Kavya Joshi    

** تمرین 1

*قسمت* *الف* یک برنامه ایجاد کنید که دو تابع ناشناس اعلام کند. یکی که از ۱۰۰ به ۰ شماره برمی‌شود و دیگری که از ۰ به ۱۰۰ شماره می‌برد. هر عدد را با یک شناسه منحصر به فرد برای هر گوروتین نمایش دهید. سپس گوروتین‌ها را از این توابع ایجاد کنید و به main اجازه بازگشت ندهید تا گوروتین‌ها کامل شوند.

*قسمت* *ب* برنامه را به صورت موازی اجرا کنید.

.play goroutines/exercise1.go
.play goroutines/answer1.go
