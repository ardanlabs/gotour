slice ها
slice ها یک ساختار داده بسیار مهم در Go هستند. آنها اساس مدیریت و دستکاری داده ها به روشی انعطاف پذیر، کارآمد و پویا را تشکیل می دهند. برای همه برنامه نویسان Go بسیار مفید است که بدانند slice ها چگونه کار می کنند و چگونه از آنها استفاده کنند.

* slice ها

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][تماشای ویدئو]]
- نیاز به کمک مالی دارید؟ از [[https://www.ardanlabs.com/scholarship/][فرم Scholarship]] ما استفاده کنید.

slice ها یک ساختار داده بسیار مهم در Go هستند. آنها اساس مدیریت و دستکاری داده ها به روشی انعطاف پذیر، کارآمد و پویا را تشکیل می دهند. برای همه برنامه نویسان Go بسیار مفید است که بدانند برش ها چگونه کار می کنند و چگونه می توان از آنها استفاده کرد.

.image /tour/eng/static/img/sl1.png

** بررسی کد 

- *مثال* *1:* اعلام و طول
- *مثال* *2:* اتواع ارجاع
- *مثال* *3:* اضافه کردن slice ها
- *مثال* *4:* گرفتن slice از slice ها
- *مثال* *5:* slice ها و ارجاع‌ ها
- *مثال* *6:* رسته ها و slice ها
- *مثال* *7:* توابع متغیر
- *مثال* *8:* مکانیک‌ های محدوده
- *مثال* *9:* پیمایش های کارآمد
- *مثال* *10:* سه شاخص slice کردن

.play slices/example1.go
.play slices/example2.go
.play slices/example3.go
.play slices/example4.go
.play slices/example5.go
.play slices/example6.go
.play slices/example7.go
.play slices/example8.go
.play slices/example9.go 
.play slices/example10.go

** Slice سازنده

ایجاد slice را می توان به چند طریق انجام داد.

    // Slice of string set to its zero value state.
    var slice []string

    // Slice of string set to its empty state.
    slice := []string{}

    // Slice of string set with a length and capacity of 5.
    slice := make([]string, 5)

    // Slice of string set with a length of 5 and capacity of 8.
    slice := make([]string, 5, 8)

    // Slice of string set with values with a length and capacity of 5.
    slice := []string{"A", "B", "C", "D", "E"}

می توانید ببینید که تابع داخلی make به من اجازه می دهد تا طول و ظرفیت آرایه پشتیبان برش را پیش اختصاص دهم. اگر کامپایلر اندازه slice را در زمان کامپایل بداند، آرایه پشتیبان می تواند روی پشته ساخته شود.

** Slice طول در مقابل ظرفیت

طول یک slice نشان دهنده تعداد عناصر قابل خواندن و نوشتن است. ظرفیت نشان دهنده تعداد کل عناصر موجود در آرایه پشتیبان از آن موقعیت اشاره گر است.

به دلیل وجود syntactic sugar، slice ها مانند آرایه به نظر می رسند و احساس می شوند.

    slice := make([]string, 5)
    slice[0] = "Apple"
    slice[1] = "Orange"
    slice[2] = "Banana"
    slice[3] = "Grape"
    slice[4] = "Plum"

می توانید تفاوت بین ساخت slice و آرایه را بگویید، زیرا یک آرایه در زمان کامپایل اندازه شناخته شده ای دارد و slice ها لزوماً اینگونه نیستند.

اگر سعی کنید به عنصری فراتر از طول slice دسترسی پیدا کنید، با خطای زمان اجرا مواجه خواهید شد.

    slice := make([]string, 5)
    slice[5] = "Raspberry"

خطای کامپایلر:

    Error: panic: runtime error: index out of range slice[5] = "Runtime error"

در این مثال، طول slice 5 است و من سعی می کنم به عنصر ششم دسترسی پیدا کنم، که وجود ندارد.

** Data Semantic Guideline For Slices

به عنوان یک راهنما، اگر داده‌ای که با آن کار می‌کنم یک آرایه است، بهتر است که از دستورات معنای مقداری (Value Semantics) برای جابه‌جایی داده در برنامه‌ام استفاده کنم. این شامل تعریف فیلدها در یک نوع (Type) نیز می‌شود.

    func Foo(data []byte) []byte

    type Foo struct {
        X []int
        Y []string
        Z []bool
    }

این قاعده برای تمامی ساختارهای داده داخلی Go اعمال می‌شود (آرایه‌ها، maps، کانال‌ها، اینترفیس ها و توابع).

یکی از دلایلی که برای استفاده از معنای اشاره‌گری (Pointer Semantics) ممکن است نیاز به به اشتراک‌گذاری آرایه برای یک عملیات رمزگشایی یا بازنگاری (decoding or unmarshaling) داشته باشید. استفاده از اشاره‌گرها برای این نوع عملیاتها مجاز است، اما اگر این موضوع برای دیگران واضح نباشد، آن را در مستندات توضیح دهید.

** چیدمان حافظه متوالی

ایده پشت تعریف آرایه این است که یک آرایه داشته باشیم که به عنوان کارا‌ترین ساختار داده ارتباط دارد با سخت‌افزار. با این حال، هنوز نیاز به امکان انعطاف‌پذیری و کارا بودن با حجم داده مورد نیاز در زمان اجرا و رشد آینده دارید.

    func main() {
        slice := make([]string, 5, 8)
        slice[0] = "Apple"
        slice[1] = "Orange"
        slice[2] = "Banana"
        slice[3] = "Grape"
        slice[4] = "Plum"

        inspectSlice(slice)
    }

    func inspectSlice(slice []string) {
        fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
        for i := range slice {
            fmt.Printf("[%d] %p %s\n", i, &slice[i], slice[i])
        }
    }

خروجی:

    Length[5] Capacity[8]
    [0] 0xc00007e000 Apple
    [1] 0xc00007e010 Orange
    [2] 0xc00007e020 Banana
    [3] 0xc00007e030 Grape
    [4] 0xc00007e040 Plum

تابع inspectSlice نشان می‌دهد که یک تیکه (slice) دارای یک آرایه پشتیبان متوالی با یک گام پیش‌بینی‌پذیر است. همچنین نشان می‌دهد که یک تیکه دارای طول و ظرفیتی است که ممکن است متفاوت باشد. توجه کنید که تابع چاپ فقط در طول تیکه حرکت می‌کند.

** افزودن با استفاده از slice ها

زبان یک تابع داخلی به نام append ارائه می‌دهد تا ارزش‌ها را به یک تیکه موجود اضافه کند.

    var data []string

    for record := 1; record <= 102400; record++ {
        data = append(data, fmt.Sprintf("Rec: %d", record))
    }

تابع append حتی زمانی که تیکه به حالت مقدار صفری خود مقداردهی اولیه شده باشد، با یک تیکه کار می‌کند. طراحی واسط برنامه‌نویسی (API) تابع append جالب است چرا که از تغییرات معنای مقداری استفاده می‌کند. تابع append یک نسخه از مقدار تیکه را به دست می‌آورد، مقدار تیکه خودش را تغییر می‌دهد، سپس یک نسخه از مقدار تیکه را به تماس‌گیرنده باز می‌گرداند.

چرا API به این شکل طراحی شده است؟ این به این دلیل است که الگو به کار برده شده است که از معنای مقداری برای جابه‌جایی مقدار تیکه در سراسر برنامه استفاده شود. این الگو حتی در عملیات تغییر هم باید رعایت شود. به علاوه، تغییر معنای مقداری روش ایمن‌تری برای انجام تغییر است، زیرا تغییر در نسخهٔ تابع در جدایی از داده انجام می‌شود.

تابع append همیشه یک بلوک متوالی از حافظه برای آرایه پشتیبان تیکه حفظ می‌کند، حتی پس از افزایش. این برای سخت‌افزار اهمیت دارد.

.image /tour/eng/static/img/sl2.png

هر بار که تابع append فراخوانی می‌شود، تابع بررسی می‌کند که آیا طول و ظرفیت تیکه یکسان است یا خیر. اگر یکسان باشند، به این معناست که در آرایه پشتیبان برای مقدار جدید جا نمانده است. در این صورت، append یک آرایه پشتیبان جدید ایجاد می‌کند (با دو برابر شدن یا افزایش 25٪) و سپس مقادیر را از آرایه قدیمی به آرایه جدید کپی می‌کند. سپس مقدار جدید می‌تواند به آن اضافه شود.

.image /tour/eng/static/img/sl3.png

اگر طول و ظرفیت یکسان نباشد، به این معناست که یک عنصر اضافی از ظرفیت برای append وجود دارد. یک عنصر از ظرفیت گرفته شده و به طول تیکه اضافه می‌شود. این باعث می‌شود که عملیات append بسیار کارا باشد.

زمانی که آرایه پشتیبان دارای ظرفیت 1024 عنصر یا کمتر باشد، آرایه‌های پشتیبان جدید با دو برابر شدن اندازه آرایه موجود ساخته می‌شوند. یک‌باری که آرایه پشتیبان بیش از 1024 عنصر رشد کند، رشد با نرخ 25٪ انجام می‌شود.

*توجه:* *نحوه* *افزایش* *ظرفیت* *آرایه* *پشتیبان* *تابع* *append* *تغییر کرده است از نسخه Go 1.18 به بعد.

- [[https://tip.golang.org/doc/go1.18#runtime][https://tip.golang.org/doc/go1.18#runtime]]

** برش slice ها

تیکه‌ها (Slices) امکان اجتناب از کپی‌های اضافی و اختصاص حافظه در پشتیبانی‌کننده‌ی آرایه را فراهم می‌کنند هنگامی که نیاز به جداسازی عناصر مشخصی از آرایه پشتیبان برای عملیات‌های مختلف دارید.

نحوه برش تیکه با نمادگذاری لیست [a:b) نمایش داده می‌شود که به این معناست که عناصر از فهرست a تا b را شامل می‌شود، اما عنصر b شامل نمی‌شود.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]

متغیر تیکه (slice2) یک مقدار تیکه جدید است که اکنون از همان آرایه پشتیبانی کننده‌ای استفاده می‌کند که تیکه اول (slice1) از آن استفاده می‌کند. با این حال، تیکه دوم (slice2) فقط به شما اجازه می‌دهد تا به عناصر در شاخص‌های 2 و 3 (C و D) از آرایه پشتیبانی کننده‌ی تیکه اصلی دسترسی داشته باشید. طول تیکه دوم (slice2) برابر با 2 است و نه 5 که در تیکه اول (slice1) است، و ظرفیت آن نیز برابر با 3 است چرا که اکنون از این موقعیت نقطه به 3 عنصر دیگر دسترسی داریم.

.image /tour/eng/static/img/sl4.png

یک راه بهتر برای در نظر گرفتن برش، تمرکز بر روی طول با استفاده از این نمادگذاری است: [a:a+len] که به معنای از شاخص a تا a به علاوه طول است. این کار به کاهش خطاها در محاسبه تیکه‌های جدید کمک خواهد کرد.

استفاده از این تابع inspect.

    func inspectSlice(slice []string) {
        fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
        for i, s := range slice {
            fmt.Printf("[%d] %p %s\n",
                i,
                &slice[i],
                s)
        }
    }

شما می‌توانید این را در عمل مشاهده کنید.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    inspectSlice(slice1)
    inspectSlice(slice2)

خروجی:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[3]
    [0] 0xc00007e020 C     <-- SAME AS INDEX 2 IN SLICE 1
    [1] 0xc00007e030 D     <-- SAME AS INDEX 3 IN SLICE 1

توجه کنید که دو تیکه متفاوت از همان آرایه پشتیبانی‌کننده به اشتراک گذاشته می‌شوند. این را می‌توانید با مقایسه آدرس‌ها مشاهده کنید.

نکته جالب اینجا این است که هیچ اختصاصی انجام نمی‌شود. کامپایلر در زمان کامپایل اندازه آرایه پشتیبانی‌کننده برای تیکه اول (slice1) را می‌شناسد. انتقال یک نسخه از مقدار تیکه به تابع inspectSlice باعث می‌شود که همه چیز روی پشته (stack) باقی بماند.

** تغییرات در آرایه پشتیبان

زمانی که از تیکه دوم (slice2) برای تغییر مقدار رشته در شاخص 0 استفاده می‌کنید، هر مقدار تیکه‌ای که از همان آرایه پشتیبان به اشتراک گذاشته می‌شود (که آدرس این شاخص جزء طول تیکه است) تغییر را مشاهده خواهد کرد.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    slice2[0] = "CHANGED"
    inspectSlice(slice1)
    inspectSlice(slice2)

خروجی:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 CHANGED
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[3]
    [0] 0xc00007e020 CHANGED
    [1] 0xc00007e030 D

همیشه باید موازنه کنید که زمانی که یک مقدار در یک موقعیت شاخص تغییر می‌دهید، آیا آرایه پشتیبان با یک تیکه دیگر به اشتراک گذاشته شده است یا نه.

.image /tour/eng/static/img/sl5.png

اگر از تابع داخلی append استفاده کنید چه اتفاقی می‌افتد؟

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    slice2 = append(slice2, "CHANGED")
    inspectSlice(slice1)
    inspectSlice(slice2)

خروجی:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 CHANGED
    Length[3] Capacity[3]
    [0] 0xc00007e020 C
    [1] 0xc00007e030 D
    [2] 0xc00007e040 CHANGED

تابع append اثر جانبی مشابهی ایجاد می‌کند، اما این اثر جانبی پنهان است. در این مورد، اضافه کردن طول بیشتر از ظرفیت به تیکه دوم (slice2) باعث تغییر مقدار در آدرس 0xc00007e040 شده است. متأسفانه، تیکه اول (slice1) این آدرس را از قبل به عنوان بخشی از طول خود داشت.

.image /tour/eng/static/img/sl6.png

یک راه برای پیشگیری از اثر جانبی این است که در ساخت تیکه دوم (slice2) از تیکه با سه شاخص استفاده کنید تا طول و ظرفیت آن به 2 برسد.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4:4]
    inspectSlice(slice1)
    inspectSlice(slice2)

خروجی:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[2]
    [0] 0xc00007e020 C
    [1] 0xc00007e030 D

نحوهٔ نمادگذاری برای تیکه با سه شاخص به صورت [a:b:c] است، که b و c باید یکسان باشند، زیرا [a-b] طول را تعیین می‌کند و [a-c] ظرفیت را تنظیم می‌کند. حالا طول و ظرفیت تیکه دوم (slice2) یکسان است.

حالا می‌توانید دوباره از تابع داخلی append استفاده کنید، همانند قبل.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4:4]
    slice2 = append(slice2, "CHANGED")
    inspectSlice(slice1)
    inspectSlice(slice2)

خروجی:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[3] Capacity[4]
    [0] 0xc000016080 C
    [1] 0xc000016090 D
    [2] 0xc0000160a0 CHANGED

توجه کنید که پس از فراخوانی تابع append، تیکه دوم (slice2) دارای یک آرایه پشتیبان جدید است.

.image /tour/eng/static/img/sl7.png

این می‌تواند با مقایسه آدرس‌های هر تیکه مشاهده شود. در این مورد، تغییر در تیکه دوم (slice2) اثر جانبی روی تیکه اول (slice1) ایجاد نکرد.

** کپی کردن تیکه‌ها به صورت دستی

یک تابع داخلی به نام copy وجود دارد که اجازهٔ کپی سطحی تیکه‌ها را می‌دهد. از آنجایی که یک رشته دارای یک آرایه پشتیبان از بایت‌ها است که تغییرناپذیر هستند، می‌تواند به عنوان یک منبع مورد استفاده قرار گیرد، اما هرگز به عنوان مقصد نه.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice3 := make([]string, len(slice1))
    copy(slice3, slice1)

    inspectSlice(slice1)
    inspectSlice(slice3)

خروجی:

    Length[5] Capacity[5]
    [0] 0xc00005c050 A
    [1] 0xc00005c060 B
    [2] 0xc00005c070 C
    [3] 0xc00005c080 D
    [4] 0xc00005c090 E
    Length[5] Capacity[5]
    [0] 0xc00005c0a0 A
    [1] 0xc00005c0b0 B
    [2] 0xc00005c0c0 C
    [3] 0xc00005c0d0 D
    [4] 0xc00005c0e0 E

تا زمانی که تیکه مقصد دارای نوع و طول مناسب باشد، تابع داخلی copy قادر به انجام یک کپی سطحی خواهد بود.

** تیکه‌ها از تغییر معنای اشاره‌گری استفاده می‌کنند

مهم است به یاد داشته باشید که حتی اگر از معنای مقداری برای جابه‌جایی تیکه در برنامه استفاده کنید، زمانی که یک تیکه را می‌خوانید و می‌نویسید، از تغییر معنای اشاره‌گری استفاده می‌کنید. به اشتراک گذاری عناصر تیکه با بخش‌های مختلف برنامه ممکن است اثرات جانبی ناخواسته‌ای ایجاد کند.

    // Construct a slice of 1 user, set a pointer to that user,
    // use the pointer to update likes.

    users := make([]user, 1)
    ptrUsr0 := &users[0]
    ptrUsr0.likes++

    for i := range users {
        fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
    }

خروجی:

    User: 0 Likes: 1

یک تیکه برای نگهداری مجموعه‌ای از کاربران استفاده می‌شود. سپس یک اشاره‌گر به اولین کاربر تنظیم می‌شود و برای به‌روزرسانی تعداد پسندیدن‌ها (likes) استفاده می‌شود. خروجی نشان می‌دهد که استفاده از اشاره‌گر کار می‌کند.

.image /tour/eng/static/img/sl8.png

سپس یک کاربر جدید به مجموعه اضافه می‌شود و دوباره از اشاره‌گر برای افزودن پسندیدن به اولین کاربر استفاده می‌شود.

    // Append a new user to the collection. Use the pointer again
    // to update likes.

    users = append(users, user{})
    ptrUsr0.likes++

    for i := range users {
        fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
    }

خروجی:

    User: 0 Likes: 1
    User: 1 Likes: 0

با این حال، از آنجایی که تابع append آرایه پشتیبانی را با یک آرایه جدید جایگزین کرد، اشاره‌گر در حال به‌روزرسانی آرایه پشتیبان قدیمی است و تعداد پسندیدن‌ها از دست رفته است. خروجی نشان می‌دهد که تعداد پسندیدن‌ها برای اولین کاربر افزایش نیافت.

.image /tour/eng/static/img/sl9.png

شما باید مواظب باشید که بدانید آیا یک تیکه در طول اجرای برنامه به یک عملیات append اضافه می‌شود یا نه. نحوه به اشتراک گذاری تیکه باید مورد نظر قرار گیرد. به اشتراک گذاری اندیس‌های فردی ممکن است بهترین ایده نباشد. به اشتراک گذاری کل مقدار تیکه همچنین ممکن است در هنگام انجام عملیات append کار نکند. احتمالاً استفاده از تیکه به عنوان یک فیلد در یک ساختار (struct) و به اشتراک گذاری مقدار ساختار راه بهتری برای انجام کار است.

** کارایی گذر خطی
زیبایی یک تیکه در این است که امکان انجام گذر خطی که به صورت مکانیکی با اشتراک‌گذاری داده با استفاده از معنای مقداری برای کاهش تخصیص حافظه در Heap (صفحه اصلی حافظه) را فراهم می‌کند.

    x := []byte{0x0A, 0x15, 0x0e, 0x28, 0x05, 0x96, 0x0b, 0xd0, 0x0}

    a := x[0]
    b := binary.LittleEndian.Uint16(x[1:3])
    c := binary.LittleEndian.Uint16(x[3:5])
    d := binary.LittleEndian.Uint32(x[5:9])

    println(a, b, c, d)

این کد با ایجاد مقادیر تیکه، از ابتدا تا انتها بخوانید، یک گذر خطی انجام می‌دهد که بخش‌های مختلفی از آرایه بایت را می‌خواند.

.image /tour/eng/static/img/sl10.png

تمام داده‌ها در این کد روی پشته (stack) باقی می‌مانند. هیچ کپی اضافی از داده‌های داخل تیکه بایت ایجاد نمی‌شود.

** یادداشت‌ها

- تیکه‌ها مانند آرایه‌های پویا با عملکرد و ویژگی‌های داخلی ویژه هستند.
- تفاوتی بین طول و ظرفیت تیکه‌ها وجود دارد و هر کدام وظیفه‌های خاص خود را دارند.
- تیکه‌ها اجازه مشاهده‌های متعددی از همان آرایه پایه را می‌دهند.
- تیکه‌ها از طریق استفاده از تابع داخلی append قابل افزایش هستند.

 ** خواندن اضافی

- [[https://blog.golang.org/go-slices-usage-and-internals][Go Slices: usage and internals]] - Andrew Gerrand    
- [[https://blog.golang.org/strings][Strings, bytes, runes and characters in Go]] - Rob Pike    
- [[https://blog.golang.org/slices][Arrays, slices (and strings): The mechanics of 'append']] - Rob Pike        
- [[https://www.ardanlabs.com/blog/2013/08/understanding-slices-in-go-programming.html][Understanding Slices in Go Programming]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/08/collections-of-unknown-length-in-go.html][Collections Of Unknown Length in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/09/iterating-over-slices-in-go.html][Iterating Over Slices In Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/09/slices-of-slices-of-slices-in-go.html][Slices of Slices of Slices in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/12/three-index-slices-in-go-12.html][Three-Index Slices in Go 1.2]] - William Kennedy    
- [[https://github.com/golang/go/wiki/SliceTricks][SliceTricks]]    
- [[https://go-review.googlesource.com/c/go/+/347917][runtime: Make slice growth formula a bit smoother]] - Go Team 
			 
* تمرینات

از قالب به عنوان نقطه شروع برای انجام تمرینات استفاده کنید. یک راه حل ممکن ارائه شده است.

** تمرین 1

*قسمت* *A:* یک تیکه خالی از اعداد صحیح اعلام کنید. یک حلقه ایجاد کنید که 10 مقدار را به تیکه اضافه کند. بر روی تیکه حرکت کنید و هر مقدار را نمایش دهید.

*قسمت* *B:* یک تیکه از پنج رشته اعلام کرده و تیکه را با مقادیر رشته‌های ثابت مقداردهی اولیه کنید. تمام عناصر را نمایش دهید. یک تیکه از شاخص یک و دو ایجاد کرده و شاخص موقعیت و مقدار هر عنصر در تیکه جدید را نمایش دهید.

.play slices/exercise1.go		  
.play slices/answer1.go
