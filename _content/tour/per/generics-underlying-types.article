انواع پایه
می‌توانید یک نوع ژنریک با استفاده از یک نوع پایه اعلان کنید.

* ویدیو
مکالمه‌ای که در مورد ژنریک‌ها انجام دادم را تماشا کنید که شما را از طریق تمام مثال‌های این بخش از تور راهنمایی می‌کند.

** بررسی کد
- مثال 1: نوع وکتور قابل مشاهده
- مثال 2: نوع وکتور رابط
- مثال 3: نوع وکتور ژنریک

.play generics/underlying-types/example1.go
.play generics/underlying-types/example2.go
.play generics/underlying-types/example3.go

** توضیح

اگر می‌خواستید نوع ژنریک خود را با استفاده از یک نوع پایه اعلان کنید، چه اتفاقی می‌افتاد؟

    type vector[T any] []T

    func (v vector[T]) last() (T, error) {
        var zero T
        
        if len(v) == 0 {
            return zero, errors.New("empty")
        }
        
        return v[len(v)-1], nil
    }

این مثال یک نوع وکتور ژنریک نشان می‌دهد که ساخت وکتور را به یک نوع واحد داده محدود می‌کند. استفاده از براکت‌های مربعی نوع T را به عنوان یک نوع ژنریک تعیین‌شده در زمان کامپایل اعلان می‌کند. استفاده از محدودیت "any" نشان می‌دهد که هیچ محدودیتی بر روی نوع T وجود ندارد.

آخرین متد با یک گیرنده مقداری از نوع vector[T] اعلان شده است تا یک مقدار از نوع وکتور با یک زیرمجموعه‌ی از نوع T نمایان دهد. این متد یک مقدار از همان نوع T را برمی‌گرداند.

    func main() {
        fmt.Print("vector[int] : ")

        vGenInt := vector[int]{10, -1}

        i, err := vGenInt.last()
        if err != nil {
            fmt.Print("ERROR:", err)
            return
        }

        if i < 0 {
            fmt.Print("negative integer: ")
        }

        fmt.Printf("value: %d\n", i)

        // -------------------------------------------------------------------------

        fmt.Print("vector[string] : ")

        vGenStr := vector[string]{"A", "B", string([]byte{0xff})}

        s, err := vGenStr.last()
        if err != nil {
            fmt.Print("ERROR:", err)
            return
        }

        if !utf8.ValidString(s) {
            fmt.Print("non-valid string: ")
        }

        fmt.Printf("value: %q\n", s)
    }

خروجی:

    vector[int] : negative integer: value: -1
    vector[string] : non-valid string: value: "\xff"

این نحوه‌ی ساخت یک مقدار از نوع وکتور با نوع زیرین int است، زمانی که مقادیر را در زمان ساخت وکتور تنظیم می‌کنم. یک جنبه مهم این کد فراخوانی‌های ساخت وکتور است.

    // Zero Value Construction
    var vGenInt vector[int]
    var vGenStr vector[string]
    
    // Non-Zero Value Construction
    vGenInt := vector{10, -1}
    vGenStr := vector{"A", "B", string([]byte{0xff})}

زمانی که به ساخت این انواع ژنریک به حالت مقدار صفر می‌پردازیم، امکان استنباط نوع توسط کامپایلر وجود ندارد. با این حال، در مواردی که در زمان ساخت اولیه اطلاعات مقداردهی می‌شود، کامپایلر می‌تواند نوع را استنباط کند.

یک جنبه از مشخصات مربوط به ساخت یک نوع ژنریک به حالت مقدار صفر می‌پردازد.

    type vector[T any] []T
    
    func (v vector[T]) last() (T, error) {
        var zero T
        
        if len(v) == 0 {
            return zero, errors.New("empty")
        }
        
        return v[len(v)-1], nil
    }

شما باید به تصریح متد در اختیار گذاشته شده برای متد آخر و چگونگی بازگرداندن یک مقدار از نوع ژنریک T توجه کنید. در بازگشت اولین موقعیت، شما باید مقدار صفر را برای نوع T برگردانید. پیاده سازی کنونی دو راه حل برای نوشتن این کد ارائه داده است. راه حل اولیه که در حال حاضر مشاهده می‌کنید، یک متغیر با نام صفر تا حالت مقدار صفر نوع T ساخته می‌شود و سپس این متغیر برای بازگشت استفاده می‌شود.

گزینه دیگر استفاده از تابع داخلی new و دیرفرنس دادن اشاره‌گر بازگشتی در بیانیه بازگشت است.

    type vector[T any] []T
    
    func (v vector[T]) last() (T, error) {
        if len(v) == 0 {
            return *new(T), errors.New("empty")
        }
        
        return v[len(v)-1], nil
    }

این نسخه از متد آخر از تابع داخلی new برای ساخت صفر و معکوس کردن اشاره‌گر بازگشتی برای ارضای نوع بازگشتی T استفاده می‌کند.

توجه: شما ممکن است بپندارید چرا از T{} برای انجام ساخت مقدار صفر استفاده نکنید؟ مشکل این است که این نحو از نحوه‌ش تا کلیه انواع کار نمی‌کند، مثل انواع اسکالر (int، string، bool). بنابراین این گزینه نمی‌باشد.

** تمرینات

از قالب به عنوان نقطه شروع برای انجام تمرینات استفاده کنید. یک راه حل ممکن ارائه شده است.

** تمرین 1

یک نوع ژنریک با نام keymap اعلام کنید که از نوع اصلی نقشه با کلید نوع string و مقدار نوع T استفاده می‌کند. یک متد با نام set اعلام کنید که یک کلید از نوع string و یک مقدار از نوع T را قبول می‌کند. یک متد با نام get اعلام کنید که یک کلید از نوع string را قبول کرده و مقدار نوع T و درست یا غلط اگر کلید پیدا شود برمی‌گرداند. سپس یک تابع اصلی بنویسید که از متدها استفاده می‌کند.

.play generics/underlying-types/exercise1.go 
.play generics/underlying-types/answer1.go
