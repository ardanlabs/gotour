متدها
یک تابع به نام یک متد فراخوانده می‌شود زمانی که آن تابع یک مشتری (receiver) داشته باشد.

* متدها

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][تماشای ویدئو]]
- نیاز به کمک مالی دارید؟ از [[https://www.ardanlabs.com/scholarship/][فرم Scholarship]] ما استفاده کنید.

یک تابع به نام یک متد فراخوانده می‌شود زمانی که آن تابع یک مشتری (receiver) داشته باشد. مشتری، پارامتری است که بین کلمه کلیدی func و نام تابع تعریف می‌شود.

** بررسی کد

- *مثال* *1:* تعریف و عملکرد مشتری
- *مثال* *2:* متدهای نوع داده‌های نامی
- *مثال* *3:* متغیرهای تابع/متد
- *مثال* *4:* انواع تابع
- *مثال* *5:* دستورات مقدار و اشاره‌گر

.play methods/example1.go
.play methods/example2.go
.play methods/example3.go
.play methods/example4.go
.play methods/example5.go

** تعریف متد

دو نوع مشتری وجود دارد، مشتری مقدار برای اجرای مفهوم مقدار و مشتری اشاره‌گر برای اجرای مفهوم اشاره‌گر.

    type user struct {
        name  string
        email string
    }

    func (u user) notify() {
        fmt.Printf("Sending User Email To %s<%s>\n", u.name, u.email)
    }

    func (u *user) changeEmail(email string) {
        u.email = email
        fmt.Printf("Changed User Email To %s\n", email)
    }

تابع notify با مشتری مقدار اجرا می‌شود. این بدان معناست که متد بر مبنای مفهوم مقدار اجرا می‌شود و بر روی نسخه خود از مقداری که برای انجام تماس استفاده شده، عمل می‌کند.

تابع changeEmail با مشتری اشاره‌گر اجرا می‌شود. این بدان معناست که متد بر مبنای مفهوم اشاره‌گر اجرا می‌شود و بر روی دسترسی به اشتراک گذاشته شده به مقداری که برای انجام تماس استفاده شده، عمل می‌کند.

به جز چند استثنا، مجموعه متد برای یک نوع نباید شامل ترکیبی از مشتری مقدار و مشتری اشاره‌گر باشد. انطباق دقیق معنایی داده بسیار مهم است و این شامل تعریف متدها نیز می‌شود.

** فراخوانی متدها

در زمان فراخوانی یک متد، کامپایلر مهم نمی‌داند که مقدار مورد استفاده برای انجام تماس با مفهوم داده مشتری تطابق دقیق داشته باشد یا نه. کامپایلر فقط می‌خواهد یک مقدار یا اشاره‌گری از همان نوع داشته باشد.

    bill := user{"Bill", "bill@email.com"}
    bill.notify()
    bill.changeEmail("bill@hotmail.com")

می‌بینید که یک مقدار از نوع کاربر ایجاد و به متغیر بیل اختصاص داده شده است. در مورد تماس با notify، متغیر بیل با نوع مشتری همخوانی دارد که از یک مشتری مقدار استفاده می‌کند. در مورد تماس با changeEmail، متغیر بیل با نوع مشتری همخوانی ندارد که از یک مشتری اشاره‌گر استفاده می‌کند. با این حال، کامپایلر تماس متد را قبول می‌کند و متغیر بیل را با متد به اشتراک می‌گذارد. Go به منظور انجام تماس تنظیماتی انجام می‌دهد.

این کار وقتی انجام می‌شود که متغیری که برای انجام تماس استفاده می‌شود یک متغیر اشاره‌گر باشد، همانطور که توضیح داده شد.

    bill := &user{"Bill", "bill@email.com"}
    bill.notify()
    bill.changeEmail("bill@hotmail.com")

در این مورد، متغیر بیل یک متغیر اشاره‌گر به یک مقدار از نوع کاربر است. دوباره، Go تنظیماتی را انجام می‌دهد تا تماس متد را برقرار کند هنگام فراخوانی متد notify.

اگر Go تنظیماتی انجام نمی‌داد، آنگاه این است که باید برای انجام همان تماس‌های متد اقدام می‌کردید.

    bill := user{"Bill", "bill@email.com"}
    (&bill).changeEmail("bill@hotmail.com")

    bill := &user{"Bill", "bill@email.com"}
    (*bill).notify()

خوشحالم که برای انجام تماس‌های متد در Go نیازی به انجام این کارها نیست.

** رهنمود داده‌های داده‌ای برای انواع داخلی

به عنوان یک رهنمود، اگر داده‌ای که با آن کار می‌کنم نوع داخلی باشد (اسلایس، مپ، کانال، تابع، رابط)، در آن صورت از داده‌دانی ارزشی برای انتقال داده در برنامه استفاده کنید. این شامل تعریف فیلدها در یک نوع هم می‌شود. اما هنگامی که می‌خواهم خواندن و نوشتن را انجام دهم، باید به خاطر داشته باشم که از داده‌دانی اشاره‌گری استفاده می‌کنم.

    type IP []byte
    type IPMask []byte

این انواع در پکیج net که جزو کتابخانه استاندارد است تعریف شده‌اند. آنها با یک نوع اساسی که یک اسلایس از بایت‌هاست تعریف شده‌اند. به علت این موضوع، این انواع به رهنمودهای انواع داخلی پیروی می‌کنند.

    func (ip IP) Mask(mask IPMask) IP {
        if len(mask) == IPv6len && len(ip) == IPv4len && allFF(mask[:12]) {
            mask = mask[12:]
        }
        if len(mask) == IPv4len && len(ip) == IPv6len &&
            bytesEqual(ip[:12], v4InV6Prefix) {
            ip = ip[12:]
        }
        n := len(ip)
        if n != len(mask) {
            return nil
        }
        out := make(IP, n)
        for i := 0; i < n; i++ {
            out[i] = ip[i] & mask[i]
        }
        return out
    }

با متد Mask، سمانتیک مقادیر برای هر دو گیرنده، پارامتر و آرگومان برگشتی در حال اجرا است. این متد یک کپی از مقدار Mask را می‌پذیرد، این مقدار را تغییر می‌دهد، و سپس یک کپی از تغییر را برمی‌گرداند. این متد از سمانتیک مقداری برای تغییرات استفاده می‌کند. این به طور اتفاقی یا تصادفی نیست.

یک تابع می‌تواند تصمیم بگیرد که چه ورودی و خروجی داده‌ای نیاز دارد. اما نمی‌تواند در مورد سمانتیک داده‌ها برای نحوه جریان داده‌ها تصمیم بگیرد. داده‌ها این تصمیم را می‌گیرند و تابع باید با آن تطابق کند. به همین دلیل Mask یک رابط تغییری با سمانتیک مقداری اجرایی می‌کند. این باید با نحوه حرکت یک آرایه در برنامه مطابقت داشته باشد.

    func ipEmptyString(ip IP) string {
        if len(ip) == 0 {
            return ""
        }
        return ip.String()
    }

تابع `ipEmptyString` همچنین برای ورودی و خروجی از سمانتیک مقداری استفاده می‌کند. این تابع یک کپی از یک مقدار IP را می‌پذیرد و یک مقدار رشته را برمی‌گرداند. هیچ استفاده‌ای از سمانتیک نشانگر وجود ندارد زیرا داده سمانتیک داده را تعیین می‌کند و نه تابع.

یک استثناء از استفاده از سمانتیک مقداری وقتی به وجود می‌آید که نیاز به اشتراک‌گذاری یک آرایه یا نقشه با یک تابعی است که عملیات بازگشت دادن یا رمزگشایی انجام می‌دهد.

** راهنمای سمانتیک داده برای انواع ساختاری

به عنوان یک راهنمای کلی، اگر داده‌هایی که با آن کار می‌کنید از نوع ساختاری باشند، باید به این فکر بیفتید که داده چه چیزی را نمایان می‌کند تا تصمیم بگیرید. یک قانون کلی خوب این است که بپرسید که آیا ساختار داده‌ای را نمایان می‌کند یا یک رابط (API). اگر ساختار داده را نمایان می‌کند، از سمانتیک مقداری استفاده کنید. اگر ساختار یک رابط را نمایان می‌کند، از سمانتیک نشانگری استفاده کنید.

    type Time struct {
        sec  int64
        nsec int32
        loc  *Location
    }

اینجا ساختار زمان (Time) از بسته زمان (time) آمده است. اگر زمان را به عنوان داده در نظر بگیرید، باید برای این ساختار از سمانتیک مقداری استفاده شود.

وقتی کد موجودی را می‌بینید و می‌خواهید بدانید کدام سمانتیک داده انتخاب شده است، به دنبال یک تابع کارخانه بگردید. نوع بازگشتی یک تابع کارخانه باید سمانتیک داده‌ای که توسط توسعه‌دهنده انتخاب شده است را مشخص کند.

    func Now() Time {
        sec, nsec := now()
        return Time{sec + unixToInternal, nsec, Local}
    }

Now تابع کارخانه برای ساخت مقادیر زمان (Time) است. به بازگشت نگاه کنید، از سمانتیک مقداری استفاده می‌کند. این به شما می‌گوید که برای مقادیر زمان باید از سمانتیک مقداری استفاده کنید که به این معناست که هر تابع کپی جداگانه‌ای از یک مقدار زمان (Time) دریافت می‌کند و فیلدها در یک ساختار به عنوان مقادیر نوع Time اعلام می‌شوند.

    func (t Time) Add(d Duration) Time {
        t.sec += int64(d / 1e9)
        nsec := int32(t.nsec) + int32(d%1e9)
        if nsec >= 1e9 {
            t.sec++
            nsec -= 1e9
        } else if nsec < 0 {
            t.sec--
            nsec += 1e9
        }
        t.nsec = nsec
        return t
    }

Add یک متد است که نیاز دارد تا یک عملیات تغییری را انجام دهد. اگر به دقت نگاه کنید، خواهید دید که تابع از سمانتیک مقداری برای انجام عملیات تغییری استفاده می‌کند. متد Add نسخه‌ای از مقدار Time که برای فراخوانی تابع استفاده شده است را می‌گیرد، نسخهٔ خودش از آن را تغییر می‌دهد، سپس یک نسخه جدید از آن را به فراخواننده برمی‌گرداند. دوباره، این روش ایمن‌ترین راه برای انجام یک عملیات تغییری است.

    func div(t Time, d Duration) (qmod2 int, r Duration) {}

در اینجا مثال دیگری از تابع div آمده است که یک مقدار از نوع Time و Duration (int64) را می‌پذیرد، سپس مقادیری از نوع int و Duration برمی‌گرداند. برای نوع Time و تمام نوع‌های داخلی (built-in) از سمانتیک مقداری استفاده می‌شود. Duration دارای یک نوع داخلی به نام int64 است.

    func (t *Time) UnmarshalBinary(data []byte) error {}
    func (t *Time) GobDecode(data []byte) error {}
    func (t *Time) UnmarshalJSON(data []byte) error {}
    func (t *Time) UnmarshalText(data []byte) error {}

این چهار متد از بستهٔ Time به نظر می‌آید که قوانین سمانتیک داده را نقض می‌کنند. آن‌ها از سمانتیک اشاره‌گری استفاده می‌کنند، چرا؟ چرا که آن‌ها یک رابط را پیاده‌سازی می‌کنند که امضای متد در آن قفل شده است. از آنجا که پیاده‌سازی نیاز به تغییر دارد، سمانتیک اشاره‌گری تنها انتخاب ممکن است.

در اینجا یک راهنما وجود دارد: اگر سمانتیک مقداری در حال اجرا باشد، می‌توانید برای برخی از توابع به سمانتیک اشاره‌گری تغییر دهید، به شرطی که دیگرین در زنجیرهٔ فراخوانی بازیابی به سمانتیک مقداری ننشانده شوند. یک بار که به سمانتیک اشاره‌گری تغییر دادید، همهٔ فراخوانی‌های آینده از آن نقطه باید به سمانتیک اشاره‌گری پایبند بمانند. شما هرگز نمی‌توانید از اشاره‌گر به مقدار برگردید. هیچ‌وقت، هیچ‌وقت، هیچ‌وقت نمی‌توانید از اشاره‌گر به مقدار برگردید. ایجاد یک کپی از یک مقداری که یک اشاره‌گر به آن اشاره می‌کند هیچ‌گاه ایمن نیست.

    func Open(name string) (file *File, err error) {
        return OpenFile(name, O_RDONLY, 0)
    }

تابع Open از بستهٔ os نشان می‌دهد که هنگام استفاده از مقدار نوع File، سمانتیک اشاره‌گری در حال اجرا است. مقادیر File باید به اشتراک گذاشته شوند و هرگز نباید کپی شوند.

    func (f *File) Chdir() error {
        if f == nil {
            return ErrInvalid
        }
        if e := syscall.Fchdir(f.fd); e != nil {
            return &PathError{"chdir", f.name, e}
        }
        return nil
    }

متد Chdir از یک رسیور اشاره‌گری استفاده می‌کند، حتی اگر این متد مقدار File را تغییر ندهد. این به این دلیل است که مقادیر File باید به اشتراک گذاشته شوند و نمی‌توانند کپی شوند.

    func epipecheck(file *File, e error) {
        if e == syscall.EPIPE {
            if atomic.AddInt32(&file.nepipe, 1) >= 10 {
                sigpipe()
            }
        } else {
            atomic.StoreInt32(&file.nepipe, 0)
        }
    }

تابع epipecheck همچنین مقادیر File را با استفاده از اشاره‌گرها به صورت نحوه استفاده از اشاره‌گرها می‌پذیرد.

** متدها فقط توابع هستند

واقعاً متدها فقط توابعی هستند که قندشکری نحوی فراهم می‌کنند تا این امکان فراهم شود که داده‌ها رفتار نشان دهند.

    type data struct {
        name string
        age  int
    }

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

یک نوع (type) و دو متد (method) اعلام شده‌اند. متد displayName از سمانتیک مقدار (value semantics) استفاده می‌کند و متد setAge از سمانتیک اشاره‌گر (pointer semantics) استفاده می‌کند.

توجه: در Go از ستر و گترها (setters و getters) استفاده نکنید. این‌ها APIs با هدف نیستند و در این موارد بهتر است که این فیلدها را برای دسترسی عمومی (export) قرار دهید.
    
    d := data{
        name: "Bill",
    }

    d.displayName()
    d.setAge(21)

یک مقدار از نوع data ساخته شده و تماس‌های متد انجام شده است.


    data.displayName(d)
    (*data).setAge(&d, 21)


از آنجایی که متد‌ها در واقع توابعی با شکر و سینتکتیک آرایه هستند، می‌توان متدها را مانند توابع اجرا کرد. می‌بینید که گیرنده در واقع یک پارامتر است، این اولین پارامتر است. وقتی شما یک متد را فرا می‌خوانید، کامپایلر آن را به یک تماس تابع تبدیل می‌کند.

توجه: اینجا متدها را به این صورت اجرا نکنید، اما ممکن است این نحوه نوشتار در پیام‌های ابزاردها را ببینید.

** نحوه عملکرد کد را بشناسید

اگر شما سمانتیک داده در بازی را بشناسید، آنگاه شما عملکرد کد را می‌شناسید. اگر شما عملکرد کد را می‌شناسید، آنگاه هزینه کد را می‌شناسید. بعد از آن، من درحال مهندسی هستم.

در اینجا نوع و مجموعه متدهای داده داده شده است.

    type data struct {
        name string
        age  int
    }

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

You can write the following code.

    func main() {
        d := data{
            name: "Bill",
        }

        f1 := d.displayName
        f1()
        d.name = "Joan"
        f1()
    }

خروجی:

    My Name Is Bill
    My Name Is Bill

شما با ساختن یک مقدار از نوع Data و اختصاص دادن آن به متغیر d شروع می‌کنید. سپس متد displayName را به d بسته و آن را به متغیری به نام f1 اختصاص می‌دهید. این یک فراخوانی متد نیست بلکه یک اختصاص است که یک سطح نهان ایجاد می‌کند. توابع مقادیر در Go هستند و به مجموعه‌ای از انواع داده داخلی تعلق دارند.

بعد از اختصاص، شما می‌توانید متد را به صورت غیرمستقیم از طریق استفاده از متغیر f1 فراخوانی کنید. این کار نام Bill را نمایش می‌دهد. سپس داده را تغییر می‌دهید تا نام Joan شود و دوباره متد را از طریق متغیر f1 فراخوانی می‌کنید. تغییر را نمی‌بینید. دوباره خروجی Bill است. پس چرا؟

.image /tour/eng/static/img/m1.png

این به سمانتیک داده در بازی مربوط دارد. متد displayName از یک گیرنده مقدار استفاده می‌کند، بنابراین سمانتیک مقدار در حال بازی است.

    func (d data) displayName() {
        fmt.Println("My Name Is", d.name)
    }

این بدان معناست که متغیر f1 کپی خود d را نگه می‌دارد و علیه کپی خودش عمل می‌کند. بنابراین فراخوانی متد از طریق متغیر f1 همیشه از کپی استفاده می‌کند و این کپی در برابر تغییر محافظت می‌شود. این چیزی است که با سمانتیک مقدار می‌خواهید.

حالا همان کار را با متد setAge انجام می‌دهید.

    func main() {
        d := data{
            name: "Bill",
        }

        f2 := d.setAge
        f2(45)
        d.name = "Sammy"
        f2(45)
    }

خروجی:

    Bill Is Age 45
    Sammy Is Age 45

در این باره، متد setAge به متغیر f2 اختصاص داده می‌شود. دوباره، متد به طور غیرمستقیم از طریق متغیر f2 فراخوانی می‌شود و عدد 45 برای سن Bill ارسال می‌شود. سپس نام Bill به Sammy تغییر می‌کند و دوباره از متغیر f2 برای انجام تماس استفاده می‌شود. این بار می‌بینید که نام تغییر کرده است.

.image /tour/eng/static/img/m2.png

متد setAge از گیرنده نقطه‌ای استفاده می‌کند، بنابراین setAge بر روی کپی خود متغیر d عمل نمی‌کند، بلکه به طور مستقیم روی متغیر d عمل می‌کند. بنابراین، f2 بر روی دسترسی مشترک عمل می‌کند و تغییر را مشاهده می‌کنید.

    func (d *data) setAge(age int) {
        d.age = age
        fmt.Println(d.name, "Is Age", d.age)
    }

بدون دانستن سمانتیک داده در حال بازی، شما نمی‌توانید رفتار کد را بفهمید. این سمانتیک داده‌ها واقعی هستند و بر رفتار تأثیر می‌گذارند.

** یادداشت‌ها

- متدها توابعی هستند که متغیر گیرنده را اعلام می‌کنند.
- گیرنده‌ها یک متد را به یک نوع متصل می‌کنند و می‌توانند از سمانتیک مقدار یا اشاره‌گر استفاده کنند.
- سمانتیک مقدار به معنای ارسال یک کپی از مقدار از مرزهای برنامه است.
- سمانتیک اشاره‌گر به معنای ارسال یک کپی از آدرس مقادیر از مرزهای برنامه است.
- به یک سمانتیک تنها برای یک نوع داده داده و پایبند باشید.

** نقل‌قول‌ها

"متدها وقتی معقول یا منطقی باشد که یک قطعه داده بتواند یک قابلیت را بیرون بیاورد." - ویلیام کندی

** مطالعه اضافی

- [[https://golang.org/doc/effective_go.html#methods][Methods]]    
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methods, Interfaces and Embedded Types in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2018/01/escape-analysis-flaws.html][Escape-Analysis Flaws]] - William Kennedy  
		 
** تمرین‌ها

از قالب به عنوان نقطه شروع برای انجام تمرین‌ها استفاده کنید. یک راه‌حل ممکن نیز ارائه شده است.

** تمرین 1

یک ساختار داده اعلام کنید که یک بازیکن بیسبال را نمایندگی می‌کند. شامل نام، تعداد حضور در بازی (atBats) و تعداد ضربه‌ها (hits) باشد.
یک متد اعلام کنید که میانگین بتینگ بازیکن را محاسبه می‌کند. فرمول این میانگین به شکل ضربه‌ها تقسیم بر حضور در بازی است (Hits / AtBats).
یک برش از این نوع تعریف کرده و آن را با چندین بازیکن مقداردهی اولیه کنید. روی برش حلقه بزنید و نام بازیکنان و میانگین بتینگ آن‌ها را نمایش دهید.

.play methods/exercise1.go
.play methods/answer1.go
