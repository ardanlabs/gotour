مفاهیم پایه
یادگیری نحوه نوشتن یک تابع چاپ عمومی پایه.

* ژنریک - مفاهیم پایه

یادگیری نحوه نوشتن یک تابع چاپ عمومی پایه.

** ویدئو

تماشای سخنرانی‌ام در مورد ژنریک که شما را از طریق همهٔ مثال‌ها در این بخش از تور می‌گذراند.

.html generics-video.html

** مرور کد

- *مثال* *1*:  پیاده‌سازی محدودیتی از چاپ
- *مثال* *2*: پیاده‌سازی با تصدی نوع از چاپ
- *مثال* *3*: پیاده‌سازی با بازتاب از چاپ
- *مثال* *4*:  پیاده‌سازی ژنریک از چاپ

.play generics/basics/example1.go
.play generics/basics/example2.go
.play generics/basics/example3.go
.play generics/basics/example4.go

** توضیح داده شده

اگر می‌خواهید یک تابع چاپ تنها بنویسید که می‌تواند یک تایپ‌لیست از هر نوع داده دلخواهی را خروجی دهد و از بازتاب (reflection) استفاده نکنید، می‌توانید از نحوه‌نویسی ژنریک جدید استفاده کنید.

    func print[T any](slice []T) {
        fmt.Print("Generic: ")
        
        for _, v := range slice {
            fmt.Print(v, " ")
        }

        fmt.Print("\n")
    }

این یک پیاده‌سازی از تابع چاپ تنها است که می‌تواند تایپ‌لیستی از هر نوع داده دلخواه را با استفاده از نحوه‌نویسی ژنریک جدید به خروجی بدهد. نکته‌ای که در مورد این نحوه‌نویسی جدید جالب است این است که کد داخل تابع می‌تواند از نحوه‌نویسی و توابع داخلی استفاده کند که با یک نوع کانکرت (مشخص) کار می‌کند. این در مورد استفاده از رابط خالی برای نوشتن کد ژنریک صادق نیست.

باید یک روش وجود داشته باشد که به کامپایلر بگویید که نوع T را به صورت صریح اعلام نمی‌کنید، اما باید در زمان کامپایل توسط کامپایلر تعیین شود. نحوه‌نویسی جدید از پرانتز مربعی برای این منظور استفاده می‌کند. این پرانتزها یک فهرست از شناسه‌های نوع ژنریک را تعریف می‌کنند که نماینده انواع خاص مربوط به تابع هستند و باید در زمان کامپایل تعیین شوند. این گونه به کامپایلر می‌گویید که انواع با این نام‌ها قبل از کامپایل برنامه اعلام نخواهند شد و باید در زمان کامپایل تعیین شوند.

توجه: می‌توانید چندین شناسه نوعی داخل پرانتز تعریف کنید، اگرچه مثال فعلی تنها یک شناسه نوعی را مورد استفاده قرار داده است. برای مثال: [T، S، R هر کدام]

همچنین می‌توانید این شناسه‌های نوعی را به هر نامی که برای خوانایی کد مفید است، نامگذاری کنید. در این مورد، کد از حروف بزرگ T برای توصیف استفاده کرده است که نشان دهنده تایپ‌لیستی از نوعی مشخص (که در زمان کامپایل تعیین می‌شود) که وارد تابع می‌شود، خواهد بود. این یک کلمه به عنوان مثال استفاده از یک حرف بزرگ واحد است که در مورد مجموعه‌ها شایع است و همچنین یک اصطلاح است که به برنامه‌نویسی‌های قدیمی‌تر مانند C++ و جاوا برمی‌گردد.

همچنین از کلمه any داخل پرانتز استفاده شده است. این نمایانگر یک محدودیت در مورد نوع T است که توسط کامپایلر مورد نیاز است

    numbers := []int{1, 2, 3}
    print[int](numbers)

    strings := []string{"A", "B", "C"}
    print[string](strings)
    
    floats := []float64{1.7, 2.2, 3.14}
    print[float64](floats)

این نمونه‌ها نشان می‌دهند که چگونه به تابع ژنریک چاپ فراخوانی کنید، جایی که اطلاعات نوع T به صورت صریح در محل فراخوانی تابع ارائه شده است. نحوه‌نویسی اینجا به ایده ایمیته که تعریف تابع `func name[T any](slice []T)` دو مجموعه پارامتر تعریف می‌کند، اشاره دارد. مجموعه اول نوع است که به شناسه‌های نوع متناظر نقش می‌بیند و مجموعه دوم داده‌ای است که به متغیرهای ورودی متناظر می‌پردازد.

خوشبختانه، کامپایلر می‌تواند نوع را استخراج کرده و نیاز به ارسال اطلاعات نوع به صورت صریح در محل فراخوانی را از بین ببرد.

    numbers := []int{1, 2, 3}
    print(numbers)
    
    strings := []string{"A", "B", "C"}
    print(strings)
    
    floats := []float64{1.7, 2.2, 3.14}
    print(floats)

این کد نشان می‌دهد که چگونه می‌توان توابع ژنریک چاپ را بدون نیاز به انتقال اطلاعات نوع به صورت صریح فراخوانی کرد. در محل فراخوانی تابع، کامپایلر قادر است نوعی که برای T استفاده کند را تشخیص دهد و نسخه متمایزی از تابع را برای پشتیبانی از اسلایس‌های آن نوع ایجاد کند. کامپایلر قادر است با استفاده از اطلاعات موجود در محل فراخوانی از داده‌هایی که داده می‌شود، نوع را استنباط کند.

** تمرین 1

یک تابع ژنریک به نام marshal را پیاده‌سازی کنید که هر مقداری را قبول کرده و آن مقدار را به JSON تبدیل کرده و JSON و یک خطا بازگرداند. یک نوع ساختاری به نام User با دو فیلد Name و Age اعلام کنید. سپس یک مقدار از نوع User را ایجاد کرده و مقدار را به تابع marshal بدهید.

.play generics/basics/exercise1.go 
.play generics/basics/answer1.go
