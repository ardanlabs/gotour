رفتار به عنوان محدودیت
هر نوع عمومی نیاز به تعیین یک محدودیت دارد تا کامپایلر بداند چه جایگزین‌های نوع محسوسی را می‌تواند در زمان کامپایل بپذیرد یا رد کند.

* ژنریک‌ها - رفتار به عنوان محدودیت
هر نوع عمومی نیاز به تعیین یک محدودیت دارد تا کامپایلر بداند چه جایگزین‌های نوع محسوسی را می‌تواند در زمان کامپایل بپذیرد یا رد کند. این مورد حتی در صورت عدم واقعیت محدودیتی در نوع عمومی مورد نیاز است، به همین دلیل شناسه محدودیت پیش‌تعیین شده به نام "هر" وجود دارد.

** ویدیو
تماشای سخنرانی من در مورد ژنریک‌ها که شما را از طریق تمام مثال‌ها در این بخش از تور راه می‌اندازد."

.html generics-video.html

** بررسی کد

- *مثال* *1*: Concrete stringify function
- *مثال* *2*: Type assertion stringify function
- *مثال* *3*: Interface stringify function
- *مثال* *4*: Generic stringify function

.play generics/behavior-constraints/example1.go
.play generics/behavior-constraints/example2.go
.play generics/behavior-constraints/example3.go
.play generics/behavior-constraints/example4.go

** توضیح داده‌شده

نکته جالب این است که مفهوم یک محدودیت در زبان قبلاً وجود دارد.

    type User struct {
        name string
    }
    
    func (u User) String() string {
        return u.name
    }
    
    type Stringer interface {
        String() string
    }
    
    func Concrete(u User) {
        u.String()
    }

    func Polymorphic(s Stringer) {
        s.String()
    }

کد یک نوع محسوس به نام کاربر (User) تعریف کرده و یک متد به نام String پیاده‌سازی می‌کند که نام کاربر را باز می‌گرداند. سپس نوع رابطی به نام Stringer تعریف می‌شود که یک عمل رفتاری به نام String دارد که یک رشته را باز می‌گرداند. به لطف متدی که برای کاربر تعریف شده است، می‌توان گفت که نوع محسوس کاربر رابط Stringer را با استفاده از نحوه معنایی مقدار اجرا می‌کند.

تابع محسوس فقط یک تابع است که داده محسوس را بر اساس نوع آن پذیرفته و از آن استفاده می‌کند. همینطور، تابع چندریختی همان‌طور که از نامش پیداست، یک تابع است که داده محسوس را بر اساس امکاناتی که دارد پذیرفته و از آن استفاده می‌کند. این تفاوت اصلی بین یک تابع محسوس و چندریختی است. یکی تنها به یک نوع داده محدود است و دیگری نه. با این حال، بر روی چه داده‌های محسوسی که می‌توان به تابع چندریختی منتقل کرد محدودیت وجود دارد.

رابط Stringer این محدودیت را با تعریف یک مجموعه از رفتارهایی که داده محسوس باید قادر به اجرا کردن آنها باشد، تعریف می‌کند. وقتی به عنوان نوع ورودی استفاده می‌شود، کامپایلر می‌تواند تضمین کند که همیشه محدودیت رفتاری هنگامی که تابع فراخوانی می‌شود برآورده می‌شود.

تعدادی تابع ژنریک وجود دارند که نیاز به همان نوع محدودیت رفتاری دارند.

    func stringify[T fmt.Stringer](slice []T) []string {
        ret := make([]string, 0, len(slice))
        
        for _, value := range slice {
            ret = append(ret, value.String())
        }
        
        return ret
    }

اینجا تابع ژنریک stringify وجود دارد. این تابع یک برش از نوع T را می‌پذیرد و یک برش از مقادیر رشته‌ای را که شامل نسخه رشته‌ای شده از هر مقدار از مجموعه ورودی است، باز می‌گرداند. کلید برای کار کردن این تابع تماس متد String با هر مقدار از نوع T است.

مشکل این است که کامپایلر باید بداند و تأیید کند که مقادیر از نوع T واقعاً دارای یک متد به نام String هستند. وقتی نوع ژنریک T اعلام می‌شود، رابط fmt.Stringer به عنوان محدودیت ارائه می‌شود. حالا کامپایلر می‌داند که باید هر نوع جایگزین و داده‌هایی که به تابع منتقل می‌شوند، را برای این مجموعه رفتار بررسی کند.

این بسیار عالی است زیرا رابط دوباره برای همان هدف استفاده می‌شود و زبان به یک کلمه جدید نیاز ندارد.

* تمرینات

از الگو به عنوان نقطه شروع برای انجام تمرینات استفاده کنید. یک راه حل ممکن ارائه شده است.

** تمرین 1

یک تابع ژنریک به نام marshal پیاده‌سازی کنید که می‌تواند JSON را marshal کند، اما تنها مقادیری را قبول کند که رابط json.Marshaler را پیاده‌سازی کرده‌اند.

.play generics/behavior-constraints/exercise1.go 
.play generics/behavior-constraints/answer1.go
