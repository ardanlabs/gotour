آرایه ها
آرایه‌ها (Arrays) در Go یک ساختار داده خاص هستند که به ما اجازه می‌دهند بلوک‌های پیوسته‌ای از حافظه با اندازه ثابت اختصاص دهیم.

* آرایه ها

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][تماشای ویدئو]]
- نیاز به کمک مالی دارید؟ از [[https://www.ardanlabs.com/scholarship/][فرم Scholarship]] ما استفاده کنید.

آرایه‌ها ساختار داده‌ای ویژه در زبان Go هستند که به ما اجازه می‌دهند حافظه‌های متوالی با اندازه ثابت را تخصیص دهیم. آرایه‌ها در Go ویژگی‌هایی ویژه مربوط به نحوه تعریف و مشاهده آنها به عنوان انواع دارند.

** بررسی کد

- *مثال* *1:* تعریف، مقداردهی اولیه و تکرار
- *مثال* *2:* آرایه‌های با انواع مختلف
- *مثال* *3:* تخصیص حافظه‌های متوالی
- *مثال* *4:* مکانیک محدوده

.play arrays/example1.go
.play arrays/example2.go
.play arrays/example3.go
.play arrays/example4.go

** تعریف و مقداردهی اولیه مقادیر

تعریف یک آرایه از پنج رشته که به حالت مقدار صفر مقداردهی اولیه شده است.

    var strings [5]string

یک رشته (string) ساختاری نامتغیر (immutable) است که دو کلمه‌ای است و نشانگر یک اشاره‌گر به یک آرایه پشتیبان از بایت‌ها و تعداد کل بایت‌ها در آرایه پشتیبان است. از آنجا که این آرایه به حالت مقدار صفر مقداردهی شده است، هر عنصر به حالت مقدار صفر خود تنظیم شده است. این بدان معنی است که هر رشته، کلمه اول را به `nil` و کلمه دوم را به `0` تنظیم شده است.

.image /tour/eng/static/img/a1.png

** تخصیص رشته

چه اتفاقی می افتد وقتی یک رشته به رشته دیگری اختصاص داده می شود؟

    strings[0] = "Apple"

زمانی که یک رشته به رشته دیگری اختصاص داده می‌شود، مقدار دو کلمه کپی می‌شود، در نتیجه دو مقدار رشته متفاوت ایجاد می‌شود که هر دو یک آرایه پشتیبان یکسان را به اشتراک می‌گذارند.

.image /tour/eng/static/img/a2.png

هزینه کپی کردن یک رشته صرف نظر از اندازه رشته، یک کپی دو کلمه ای، یکسان است.

** تکرار بر روی مجموعه‌ها

Go دو معنای مختلف برای تکرار بر روی مجموعه ارائه می‌دهد. من می‌توانم با استفاده از معنای مقدار یا معنای اشاره تکرار کنم.

    // Value Semantic Iteration
    for i, fruit := range strings {
        println(i, fruit)
    }


    // Pointer Semantic Iteration
    for i := range strings {
        println(i, strings[i])
    }

هنگامی که از تکرار معنای مقدار استفاده می کنید، دو اتفاق می افتد. اول، مجموعه ای که در حال تکرار بر روی آن هستید کپی می شود و شما بر روی کپی تکرار می کنید. در مورد آرایه، کپی کردن می تواند پرهزینه باشد، زیرا کل آرایه کپی می شود. در مورد اسلایس، هزینه واقعی وجود ندارد، زیرا فقط مقدار اسلایس داخلی کپی می شود و نه آرایه پشتیبان. دوم، شما یک نسخه از هر عنصر در حال تکرار دریافت می کنید.

هنگامی که از تکرار معنای اشاره استفاده می کنید، بر روی مجموعه اصلی تکرار می کنید و من به هر عنصر مرتبط با مجموعه به طور مستقیم دسترسی پیدا می کنم.

** تکرار معنای مقدار.

با توجه به کد و خروجی زیر.

    strings := [5]string{"Apple", "Orange", "Banana", "Grape", "Plum"}
    for i, fruit := range strings {
        println(i, fruit)
    }

خروجی:

    0 Apple
    1 Orange
    2 Banana
    3 Grape
    4 Plum

متغیر strings یک آرایه از 5 رشته است. حلقه تک تک رشته ها را در مجموعه تکرار می کند و موقعیت شاخص و مقدار رشته را نمایش می دهد. از آنجایی که این یک تکرار معنایی ارزش است، for range بر روی یک کپی کم عمق خود از آرایه تکرار می شود و در هر تکرار، متغیر fruit کپی هر رشته (ساختار داده دو کلمه) است.

توجه کنید که چگونه متغیر fruit با استفاده از معنایی ارزش به تابع print منتقل می شود. تابع print نیز کپی خود از مقدار رشته را دریافت می کند. تا زمانی که رشته به تابع print منتقل شود، 4 نسخه از مقدار رشته وجود دارد (آرایه، کپی کم عمق، متغیر fruit و کپی تابع print). همه 4 نسخه یک آرایه پشتیبان از بایت را به اشتراک می گذارند.

.image /tour/eng/static/img/a3.png

ایجاد کپی از مقدار رشته مهم است زیرا از فرار کردن مقدار رشته به پشته جلوگیری می کند. این کار تخصیص غیرمولد را روی پشته از بین می برد.

** تکرار معنایی اشاره گر

با توجه به کد و خروجی زیر.

    strings := [5]string{"Apple", "Orange", "Banana", "Grape", "Plum"}
    for i := range strings {
        println(i, strings[i])
    }

خروجی:

    0 Apple
    1 Orange
    2 Banana
    3 Grape
    4 Plum

دوباره، متغیر strings یک آرایه از 5 رشته است. حلقه تک تک رشته ها را در مجموعه تکرار می کند و موقعیت شاخص و مقدار رشته را نمایش می دهد. از آنجایی که این یک تکرار معنایی اشاره گر است، for range مستقیماً بر روی آرایه strings تکرار می شود و در هر تکرار، مقدار رشته برای هر موقعیت شاخص به طور مستقیم برای فراخوانی print دسترسی پیدا می کند.

** آرایه های انواع مختلف


جالب است که ببینیم کامپایلر هنگام انتساب آرایه‌هایی از همان نوع با طول‌های مختلف چه خطایی می‌دهد.

    var five [5]int
    four := [4]int{10, 20, 30, 40}

    five = four

خطای کامپایلر:

    نمی‌توان از چهار (نوع [4]int) به عنوان نوع [5]int در انتساب استفاده کرد.


در اینجا شما یک آرایه از 4 و 5 عدد صحیح را که به مقدار صفر خود مقداردهی شده اند اعلام می کنید. سپس سعی کنید آنها را به یکدیگر اختصاص دهید و کامپایلر می گوید: "نمی توان از چهار (نوع [4]int) به عنوان نوع [5]int در انتساب استفاده کرد."

مهم است که واضح باشیم که کامپایلر چه می گوید. این می گوید که یک آرایه از 4 عدد صحیح و یک آرایه از 5 عدد صحیح نشان دهنده داده های انواع مختلف هستند. اندازه یک آرایه بخشی از اطلاعات نوع آن است. در Go، اندازه یک آرایه باید در زمان کامپایل مشخص باشد.

** ساختار حافظه مجاور (Contiguous Memory Construction)

شما می خواهید ثابت کنید که یک آرایه یک چیدمان مجاور از حافظه را فراهم می کند.

    five := [5]string{"Annie", "Betty", "Charley", "Doug", "Bill"}

    for i, v := range five {
        fmt.Printf("Value[%s]\tAddress[%p]  IndexAddr[%p]\n",
            v, &v, &five[i])
    }

خروجی:

    Value[Annie]     Address[0xc000010250]    IndexAddr[0xc000052180]
    Value[Betty]     Address[0xc000010250]    IndexAddr[0xc000052190]
    Value[Charley]   Address[0xc000010250]    IndexAddr[0xc0000521a0]
    Value[Doug]      Address[0xc000010250]    IndexAddr[0xc0000521b0]
    Value[Bill]      Address[0xc000010250]    IndexAddr[0xc0000521c0]

در اینجا شما یک آرایه از 5 رشته را که با مقادیر مقداردهی اولیه شده اند اعلام می کنید. سپس از تکرار معنایی ارزش برای نمایش اطلاعات در مورد هر رشته استفاده کنید. خروجی هر مقدار رشته فردی، آدرس متغیر v و آدرس هر عنصر در آرایه را نشان می دهد.

می توانید ببینید که چگونه آرایه یک بلوک حافظه مجاور است و چگونه یک رشته یک ساختار داده دو کلمه ای یا 16 بایتی در معماری 64 بیتی من است. آدرس هر عنصر به فاصله 16 بایت فاصله دارد.

این واقعیت که متغیر v در هر تکرار دارای یک آدرس است، درک این را تقویت می کند که v یک متغیر محلی از نوع string است که در طول تکرار حاوی کپی هر مقدار رشته است.

** کش های CPU

تفاوت های مکانیکی زیادی بین پردازنده ها و طراحی آنها وجود دارد. در این بخش، در سطح بالایی در مورد پردازنده ها و معنایی صحبت خواهید کرد که تقریباً بین همه آنها یکسان است. این درک معنایی یک مدل ذهنی خوب از نحوه عملکرد پردازنده و همدردی را که می توانید ارائه کنید به شما ارائه می دهد.

هر هسته داخل پردازنده دارای کش حافظه محلی خود (L1 و L2) و کش حافظه مشترک (L3) است که برای ذخیره/دسترسی به داده ها و دستورالعمل ها استفاده می شود. رشته های سخت افزاری در هر هسته می توانند به کش های محلی L1 و L2 خود دسترسی داشته باشند. داده ها از L3 یا حافظه اصلی باید برای دسترسی در کش L1 یا L2 کپی شوند.

.image /tour/eng/static/img/a4.png

هزینه تأخیر در دسترسی به داده هایی که در کش های مختلف وجود دارند از کمترین به بیشترین تغییر می کند: L1 -> L2 -> L3 -> حافظه اصلی. همانطور که اسکات مایرز گفت: "اگر عملکرد مهم است، کل حافظه ای که شما دارید کل حافظه کش است. حافظه اصلی برای دسترسی بسیار کند است، عملاً ممکن است اصلاً وجود نداشته باشد."

عملکرد امروز در مورد این است که داده ها چگونه به طور کارآمد در سخت افزار جریان می یابند. اگر هر داده ای که سخت افزار نیاز دارد (در هر زمان معین) فقط در حافظه اصلی وجود داشته باشد، برنامه های من در مقایسه با داده هایی که قبلاً در کش های L1 یا L2 وجود دارند، کندتر اجرا می شوند.

    3 گیگاهرتز (3 سیکل کلاک بر نانوسکوند) * 4 دستورالعمل در هر سیکل = 12 دستورالعمل در هر نانوسکوند!

    1 ns ............. 1 ns .............. 12 instructions  (one) 
    1 µs ......... 1,000 ns .......... 12,000 instructions  (thousand)
    1 ms ..... 1,000,000 ns ...... 12,000,000 instructions  (million)
    1 s .. 1,000,000,000 ns .. 12,000,000,000 instructions  (billion)

    Industry Defined Latencies
    L1 cache reference ......................... 0.5 ns ...................  6 ins
    L2 cache reference ........................... 7 ns ................... 84 ins
    Main memory reference ...................... 100 ns ................. 1200 ins

چگونه می توان کدی نوشت که تضمین کند داده های مورد نیاز برای اجرای یک دستورالعمل همیشه در کش های L1 یا L2 وجود دارد؟ شما باید کدی بنویسید که از نظر مکانیکی با پیش بینی کننده پردازنده سازگار باشد. پیش بینی کننده سعی می کند قبل از اینکه دستورالعمل ها داده ها را درخواست کنند، پیش بینی کند که چه داده هایی مورد نیاز است، بنابراین آنها از قبل در کش L1 یا L2 وجود دارند.

بسته به اینکه دسترسی از کجا اتفاق می افتد، گرانولاریتی های مختلفی از دسترسی به حافظه وجود دارد. کد من می تواند یک بایت از حافظه را به عنوان کوچکترین واحد دسترسی به حافظه بخواند/بنویسد. با این حال، از نظر سیستم های کش، گرانولاریتی 64 بایت است. این بلوک 64 بایتی حافظه خط کش نامیده می شود.

پیش بینی کننده زمانی بهتر کار می کند که دستورالعمل های در حال اجرا الگوهای دسترسی قابل پیش بینی به حافظه ایجاد کنند. یکی از راه‌های ایجاد یک الگوی دسترسی قابل پیش بینی به حافظه، ساخت یک بلوک حافظه مجاور و سپس تکرار روی آن حافظه با انجام یک پیمایش خطی با گام قابل پیش بینی است.

آرایه مهمترین ساختار داده برای سخت افزار است زیرا از الگوهای دسترسی قابل پیش بینی پشتیبانی می کند. با این حال، اسلایس مهمترین ساختار داده در Go است. اسلایس ها در Go از یک آرایه در زیر استفاده می کنند.

هنگامی که یک آرایه می سازید، هر عنصر به طور مساوی از عنصر بعدی یا قبلی فاصله دارد. هنگامی که روی یک آرایه تکرار می کنید، شروع به حرکت در خطوط کش به خطوط کش متصل با گام قابل پیش بینی می کنید. پیش بینی کننده این الگوی دسترسی قابل پیش بینی به داده ها را دریافت می کند و شروع به کشیدن کارآمد داده ها به پردازنده می کند، در نتیجه هزینه های تأخیر دسترسی به داده را کاهش می دهد.

تصور کنید که یک ماتریس حافظه مربعی بزرگ و یک لیست پیوندی از گره ها دارید که مطابق با تعداد عناصر ماتریس هستند. اگر یک پیمایش در سراسر لیست پیوندی انجام دهید و سپس ماتریس را در هر دو جهت (ستون و ردیف) پیمایش کنید، عملکرد پیمایش های مختلف چگونه مقایسه می شود؟

    func RowTraverse() int {
        var ctr int
        for row := 0; row < rows; row++ {
            for col := 0; col < cols; col++ {
                if matrix[row][col] == 0xFF {
                    ctr++
                }
            }
        }
        return ctr
    }

پیمایش ردیفی بهترین عملکرد را خواهد داشت زیرا از حافظه، خط کش به خط کش متصل عبور می کند که یک الگوی دسترسی قابل پیش بینی ایجاد می کند. خطوط کش را می توان قبل از نیاز به داده ها، پیش بینی کرد و در کش L1 یا L2 کپی کرد.

    func ColumnTraverse() int {
        var ctr int
        for col := 0; col < cols; col++ {
            for row := 0; row < rows; row++ {
                if matrix[row][col] == 0xFF {
                    ctr++
                }
            }
        }
        return ctr
    }

پیمایش ستونی بدترین حالت است زیرا این الگوی دسترسی در هر دسترسی به حافظه از مرزهای صفحه OS عبور می کند. این باعث عدم پیش بینی برای پیش بازی خط کش می شود و اساساً به حافظه دسترسی تصادفی تبدیل می شود.

    func LinkedListTraverse() int {
        var ctr int
        d := list
        for d != nil {
            if d.v == 0xFF {
                ctr++
            }
            d = d.p
        }
        return ctr
    }

لیست پیوندی تقریباً دو برابر کندتر از پیمایش ردیفی است، زیرا خطای کش وجود دارد، اما خطاهای TLB (Translation Lookaside Buffer) کمتری وجود دارد. بخش زیادی از گره های متصل شده در لیست در داخل صفحات OS یکسانی وجود دارند.

    BenchmarkLinkListTraverse-16    128      28738407 ns/op
    BenchmarkColumnTraverse-16       30     126878630 ns/op
    BenchmarkRowTraverse-16         310      11060883 ns/op

** Translation Lookaside Buffer (TLB)

هر برنامه در حال اجرا توسط سیستم عامل یک نقشه حافظه کامل از حافظه مجازی دریافت می کند و آن برنامه در حال اجرا فکر می کند که تمام حافظه فیزیکی روی دستگاه را دارد. با این حال، حافظه فیزیکی باید با تمام برنامه های در حال اجرا به اشتراک گذاشته شود. سیستم عامل حافظه فیزیکی را با شکستن حافظه فیزیکی به صفحات و نگاشت صفحات به حافظه مجازی برای هر برنامه در حال اجرا به اشتراک می گذارد. هر سیستم عامل می تواند اندازه یک صفحه را تعیین کند، اما 4k، 8k، 16k اندازه های منطقی و رایج هستند.

TLB یک حافظه پنهان کوچک در داخل پردازنده است که به کاهش تأخیر در ترجمه یک آدرس مجازی به یک آدرس فیزیکی در محدوده یک صفحه OS و آفست داخل صفحه کمک می کند. یک خطای حافظه نهان TLB می تواند باعث تأخیرهای زیادی شود زیرا اکنون سخت افزار باید منتظر اسکن جدول صفحه سیستم عامل برای یافتن صفحه مناسب برای آدرس مجازی مورد نظر باشد. اگر برنامه روی یک ماشین مجازی (مانند ابر) اجرا شود، ابتدا باید جدول صفحه ماشین مجازی اسکن شود.

به یاد داشته باشید که چه گفته شد:

لیست پیوندی تقریباً دو برابر کندتر از پیمایش ردیفی است، زیرا خطاهای کش وجود دارد، اما خطاهای TLB کمتری وجود دارد (در ادامه توضیح داده شده است). بخش زیادی از گره های متصل شده در لیست در داخل صفحات OS یکسانی وجود دارند.

LinkedList به دلیل دسترسی TLB بسیار سریعتر از پیمایش ستونی است. حتی اگر خطاهای کش با پیمایش لیست پیوندی وجود داشته باشد، از آنجایی که اکثریت حافظه برای یک گروه از گره‌ها در داخل صفحه یکسانی قرار می‌گیرند، تأخیرهای TLB بر عملکرد تأثیر نمی‌گذارند. به همین دلیل است که برای برنامه هایی که از مقدار زیادی حافظه استفاده می کنند، مانند برنامه های مبتنی بر DNA، ممکن است بخواهید از توزیعی از لینوکس استفاده کنید که با اندازه صفحات در حدود یک مگابایت یا دو مگابایت حافظه پیکربندی شده است.

با این حال، طراحی مبتنی بر داده مهم است. نوشتن یک الگوریتم کارآمد باید نحوه دسترسی به داده ها را در نظر بگیرد. به یاد داشته باشید، عملکرد امروز در مورد این است که چگونه می توانید به طور کارآمد داده ها را به پردازنده منتقل کنید.

- [[https://youtu.be/WDIkqP4JbkE?t=1129][CPU Caches and Why You Care (18:50-20:30)]] - Scott Meyers  
- [[https://youtu.be/WDIkqP4JbkE?t=2676][CPU Caches and Why You Care (44:36-45:40)]] - Scott Meyers   
- [[https://youtu.be/jEG4Qyo_4Bc?t=266][Performance Through Cache-Friendliness (4:25-5:48)]] - Damian Gryski  

** نکات کش سی پی یو

.html arrays/array_list.html

** دیاگرام ها

*تاخیرهای* *تعریف شده* *صنعت*

    L1 cache reference ......................... 0.5 ns ...................  6 ins
    Branch mispredict ............................ 5 ns ................... 60 ins
    L2 cache reference ........................... 7 ns ................... 84 ins
    Mutex lock/unlock ........................... 25 ns .................. 300 ins
    Main memory reference ...................... 100 ns ................. 1200 ins           
    Compress 1K bytes with Zippy ............. 3,000 ns (3 µs) ........... 36k ins
    Send 2K bytes over 1 Gbps network ....... 20,000 ns (20 µs) ........  240k ins
    SSD random read ........................ 150,000 ns (150 µs) ........ 1.8M ins
    Read 1 MB sequentially from memory ..... 250,000 ns (250 µs) .......... 3M ins
    Round trip within same datacenter ...... 500,000 ns (0.5 ms) .......... 6M ins
    Read 1 MB sequentially from SSD- ..... 1,000,000 ns (1 ms) ........... 12M ins
    Disk seek ........................... 10,000,000 ns (10 ms) ......... 120M ins
    Read 1 MB sequentially from disk .... 20,000,000 ns (20 ms) ......... 240M ins
    Send packet CA->Netherlands->CA .... 150,000,000 ns (150 ms) ........ 1.8B ins

*تصویر* *تاخیرهای* *کش*

.image /tour/eng/static/img/cache_latencies_graph.png

** Extra Reading

*CPU* *Caches* */* *Memory*

- [[https://www.youtube.com/watch?v=WDIkqP4JbkE][CPU Caches and Why You Care - Video]] - Scott Meyers  
- [[https://www.youtube.com/watch?v=OFgxAFdxYAQ][A Crash Course in Modern Hardware - Video]] - Cliff Click  
- [[http://frankdenneman.nl/2016/07/06/introduction-2016-numa-deep-dive-series/][NUMA Deep Dive Series]] - Frank Denneman    
- [[http://www.aristeia.com/TalkNotes/codedive-CPUCachesHandouts.pdf][CPU Caches and Why You Care - Deck]] - Scott Meyers  
- [[https://www.youtube.com/watch?v=MC1EKLQ2Wmg][Mythbusting Modern Hardware to Gain 'Mechanical Sympathy']] - Martin Thompson  
- [[http://www.akkadia.org/drepper/cpumemory.pdf][What Every Programmer Should Know About Memory]] - Ulrich Drepper  
- [[http://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips][How CPU Caches Work and Why]] - Joel Hruska  
- [[http://www.lighterra.com/papers/modernmicroprocessors][Modern Microprocessors A 90 Minute Guide]] - Jason Robert Carey Patterson  
- [[http://lwn.net/Articles/252125][Memory part 2: CPU caches]] - Ulrich Drepper  
- [[http://www.gotw.ca/publications/concurrency-ddj.htm][The Free Lunch Is Over]] - Herb Sutter  
- [[https://m.youtube.com/watch?feature=youtu.be&v=QBu2Ae8-8LM][Data Center Computers: Modern Challenges in CPU Design]] - Dick Sites  
- [[https://en.wikipedia.org/wiki/Wirth%27s_law][Wirth's Law]] - Wikipedia  
- [[http://www.drdobbs.com/parallel/eliminate-false-sharing/217500206][Eliminate False Sharing]] - Herb Sutter  
- [[http://www.ilikebigbits.com/2014_04_21_myth_of_ram_1.html][The Myth Of Ram]] - Emil Ernerfeldt  
- [[https://www.infoq.com/presentations/hardware-transactional-memory][Understanding Transaction Hardware Memory]] - Gil Gene  
- [[https://youtu.be/jEG4Qyo_4Bc?t=266][Performance Through Cache-Friendliness (4:25-5:48)]] - Damian Gryski   
- [[https://www.youtube.com/watch?v=2EWejmkKlxs][Going Nowhere Faster]] - Chandler Carruth  

*Data-Oriented* *Design*

- [[https://www.youtube.com/watch?v=rX0ItVEVjHc][Data-Oriented Design and C++]] - Mike Acton  
- [[https://www.youtube.com/watch?v=fHNmRkzxHWs][Efficiency with Algorithms, Performance with Data Structures]] - Chandler Carruth  
- [[https://www.youtube.com/watch?v=LrVi9LHP8Bk][Taming the performance Beast]] - Klaus Iglberger  
- [[http://harmful.cat-v.org/software/OO_programming/_pdf/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf][Pitfalls of OOP]] - Tony Albrecht  
- [[https://www.youtube.com/watch?v=YQs6IC-vgmo][Why you should avoid Linked Lists]] - Bjarne Stroustrup  
- [[http://gamesfromwithin.com/data-oriented-design][Data-Oriented Design (Or Why You Might Be Shooting Yourself in The Foot With OOP)]] - Noel    
- [[https://www.quora.com/Was-object-oriented-programming-a-failure][Was object-oriented programming a failure?]] - Quora  

** نکات

- اگر داده ها را درک نکنید، مشکل را درک نمی کنید.
- اگر هزینه حل مشکل را درک نکنید، نمی توانید در مورد مشکل استدلال کنید.
- اگر سخت‌افزار را درک نکنید، نمی‌توانید در مورد هزینه حل مشکل استدلال کنید.
- آرایه‌ها ساختارهای داده‌ای با طول ثابت هستند که نمی‌توانند تغییر کنند.
- آرایه‌هایی با اندازه‌های مختلف به عنوان انواع مختلف در نظر گرفته می‌شوند.
- حافظه به صورت بلوک متصل اختصاص می‌یابد.
- Go به شما کنترل بر مکان محلی می‌دهد.

* تمرینات

از قالب به عنوان نقطه شروع برای تکمیل تمرینات استفاده کنید. یک راه حل ممکن ارائه شده است.

** تمرین 1

یک آرایه از 5 رشته با هر عنصر مقداردهی شده به مقدار صفر خود اعلام کنید.
یک آرایه دوم از 5 رشته اعلام کنید و این آرایه را با مقادیر رشته ای مقداریدهی کنید.
آرایه دوم را به آرایه اول اختصاص دهید و نتایج آرایه اول را نمایش دهید.
ارزش رشته و آدرس هر عنصر را نمایش دهید.

.play arrays/exercise1.go
.play arrays/answer1.go
